<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mogaland-Plume Simulator</title>
  <!-- Node.js Polyfills for WalletConnect v2 - MUST BE FIRST -->
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
  <script>
    // Polyfills for Node.js globals required by WalletConnect v2
    (function() {
      // Use buffer library loaded above
      if (typeof buffer !== 'undefined' && buffer.Buffer) {
        window.Buffer = buffer.Buffer;
      } else {
        // Fallback minimal Buffer implementation
        window.Buffer = window.Buffer || { 
          isBuffer: () => false,
          from: function(data, encoding) {
            if (typeof data === 'string') {
              // Basic string to Uint8Array conversion
              const encoder = new TextEncoder();
              return encoder.encode(data);
            }
            return data;
          },
          alloc: (size) => new Uint8Array(size),
          toString: function() { return '[Buffer]'; }
        };
      }
      
      // Mock process.env for WalletConnect
      window.process = window.process || { 
        env: { NODE_ENV: 'production' },
        version: 'v18.0.0', // Use recent LTS version
        nextTick: (fn) => setTimeout(fn, 0)
      };
      
      // Global reference
      window.global = window.global || window;
      
      console.log('‚úÖ Node.js polyfills loaded for WalletConnect v2');
    })();
  </script>
  
  <!-- Ethers.js with fallback CDN support -->
  <script>
    // Ethers.js CDN Fallback Loader
    (function() {
      const ethersCDNs = [
        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js',
        'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js',
        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js'
      ];
      let currentCDNIndex = 0;
      
      function loadEthers() {
        if (currentCDNIndex >= ethersCDNs.length) {
          console.error('‚ùå All ethers.js CDNs failed to load');
          window.ethersLoadFailed = true;
          return;
        }
        
        const script = document.createElement('script');
        script.src = ethersCDNs[currentCDNIndex];
        script.async = false;
        script.crossOrigin = 'anonymous';
        
        script.onload = function() {
          console.log('‚úÖ Ethers.js loaded successfully from: ' + ethersCDNs[currentCDNIndex]);
          window.ethersLoaded = true;
        };
        
        script.onerror = function() {
          console.warn('‚ö†Ô∏è Failed to load ethers.js from: ' + ethersCDNs[currentCDNIndex]);
          currentCDNIndex++;
          loadEthers();
        };
        
        document.head.appendChild(script);
      }
      
      loadEthers();
    })();
  </script>
  
  <!-- WalletConnect v2 Ethereum Provider with proper error handling -->
  <script type="module">
    (async function() {
      window.WalletConnectV2Available = false;
      window.WalletConnectProvider = null;
      
      try {
        const module = await import('https://unpkg.com/@walletconnect/ethereum-provider@2.11.0/dist/index.umd.js');
        
        // Properly expose EthereumProvider
        window.EthereumProvider = module.EthereumProvider || module.default || module;
        window.WalletConnectV2Available = true;
        
        console.log('‚úÖ WalletConnect v2 loaded successfully');
        console.log('   - EthereumProvider available:', typeof window.EthereumProvider !== 'undefined');
      } catch (err) {
        console.warn('‚ö†Ô∏è WalletConnect v2 failed to load:', err.message);
        console.warn('   WalletConnect will not be available. Use MetaMask, OKX, or Trust Wallet instead.');
      }
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.min.js"></script>
  <!-- TradingView Widget -->
  <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>

  <style>
    :root {
      --primary: #0d6efd;
      --dark: #0a2540;
      --darker: #071a2e;
      --light: #f8f9fa;
      --bell: #ffcc00;
      --success: #28a745;
      --danger: #dc3545;
      --card-bg: #1e293b;
      --border: #334155;
      --progress: #3b82f6;
      --progress-end: #60a5fa;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: var(--darker);
      color: var(--light);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .login-container {
      background: rgba(0,0,0,0.5);
      border-radius: 20px;
      padding: 80px 40px;
      width: 100%;
      max-width: 500px;
      text-align: center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.1);
      margin: 120px auto;
    }
    h1 { font-size: 3.2rem; margin-bottom: 12px; }
    .subtitle { font-size: 1.3rem; opacity: 0.8; margin-bottom: 50px; }
    .login-option {
      background: var(--primary);
      color: white;
      border: none;
      padding: 18px;
      font-size: 1.3rem;
      border-radius: 12px;
      cursor: pointer;
      margin: 20px 0;
      width: 100%;
      transition: all 0.3s;
    }
    .login-option:hover { background: #0b5ed7; transform: scale(1.02); }
    .wallet-choice {
      background: linear-gradient(135deg, rgba(13,110,253,0.3), rgba(13,110,253,0.5));
      color: white;
      border: 2px solid var(--primary);
      padding: 16px 20px;
      font-size: 1.15rem;
      border-radius: 12px;
      cursor: pointer;
      margin: 10px 0;
      width: 100%;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }
    .wallet-choice:hover { 
      background: linear-gradient(135deg, var(--primary), #0b5ed7);
      transform: scale(1.02);
      box-shadow: 0 4px 12px rgba(13,110,253,0.4);
    }
    .wallet-choice.primary-wallet {
      background: linear-gradient(135deg, rgba(13,110,253,0.4), rgba(13,110,253,0.6));
      border: 2px solid #60a5fa;
    }
    .wallet-choice.primary-wallet:hover {
      background: linear-gradient(135deg, var(--primary), #2563eb);
      border-color: #3b82f6;
    }
    .input-field {
      width: 100%;
      padding: 14px;
      margin: 10px 0;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.05);
      color: white;
      font-size: 1.1rem;
    }
    .main-app {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    header {
      padding: 20px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 12px;
    }
    .top-btn {
      background: rgba(13,110,253,0.3);
      color: white;
      border: 1px solid var(--primary);
      padding: 10px 18px;
      font-size: 1rem;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
    }
    .top-btn:hover { background: var(--primary); transform: scale(1.05); }
    .top-btn.connected { background: var(--success); border-color: var(--success); }
    
    .wallet-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 8px;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      min-width: 280px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.5);
      z-index: 1000;
      display: none;
      padding: 16px;
    }
    .wallet-dropdown.show { display: block; }
    .wallet-address {
      font-family: monospace;
      font-size: 0.85rem;
      background: rgba(13,110,253,0.1);
      padding: 10px;
      border-radius: 8px;
      word-break: break-all;
      margin-bottom: 12px;
      color: #60a5fa;
    }
    .wallet-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .wallet-action-btn {
      background: rgba(13,110,253,0.2);
      color: white;
      border: 1px solid var(--primary);
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .wallet-action-btn:hover {
      background: var(--primary);
      transform: translateX(4px);
    }
    .wallet-action-btn.disconnect {
      background: rgba(239,68,68,0.2);
      border-color: var(--danger);
    }
    .wallet-action-btn.disconnect:hover {
      background: var(--danger);
    }
    .nav-bar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      border-radius: 60px;
      padding: 12px 20px;
      display: flex;
      gap: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1);
      z-index: 100;
    }
    .nav-btn {
      background: rgba(13,110,253,0.2);
      color: white;
      border: none;
      padding: 12px 20px;
      font-size: 1rem;
      border-radius: 40px;
      cursor: pointer;
      transition: all 0.3s;
      white-space: nowrap;
    }
    .nav-btn:hover, .nav-btn.active { background: var(--primary); transform: scale(1.08); }
    .content { flex: 1; padding: 20px; padding-bottom: 100px; text-align: center; }
    .hidden { display: none !important; }
    .notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,204,0,0.2);
      border: 1px solid var(--bell);
      color: white;
      padding: 14px 24px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 1000;
      animation: bell 1.5s;
      max-width: 90%;
    }
    @keyframes bell { 0%,100% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.05); } }

    .flex-container {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: stretch;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 20px;
    }
    @media (min-width: 992px) { .flex-container { flex-wrap: nowrap; } }
    @media (max-width: 992px) { .flex-container { flex-direction: column; } }

    .progress-box, .question-card, .card {
      min-height: 520px !important;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      box-sizing:border-box;
    }
    .question-card {
      min-height: 520px !important;
      flex: 1 1 420px;
      max-width: 500px;
    }
    .progress-box, .card {
      min-height: 520px !important;
      flex: 1 1 320px;
      max-width: 420px;
    }
    .question-box {
      flex: 1 1 420px;
      min-width: 380px;
    }

    .card {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 24px;
      border: 1px solid var(--border);
      box-shadow: 0 8px 25px rgba(0,0,0,0.5);
    }
    .card h3 { color: #60a5fa; margin-bottom: 16px; text-align: center; font-size: 1.4em; }
    .progress-bar {
      background: var(--border);
      border-radius: 999px;
      height: 14px;
      overflow: hidden;
      margin: 12px 0;
    }
    .progress-fill {
      background: linear-gradient(90deg, var(--progress), var(--progress-end));
      height: 100%;
      transition: width 0.6s ease;
    }
    .btn-primary {
      width: 100%;
      padding: 14px;
      background: linear-gradient(90deg, var(--primary), var(--progress-end));
      border: none;
      border-radius: 12px;
      color: white;
      font-size: 1.1em;
      cursor: pointer;
      margin: 8px 0;
      transition: all 0.3s;
    }
    .btn-primary:hover { transform: scale(1.03); }
    .btn-success { background: linear-gradient(90deg, var(--success), #34d399); }
    .btn-group { display: flex; gap: 16px; margin-top: 24px; }

    .question-card {
      background: #0f172a;
      border-radius: 12px;
      padding: 28px;
      border: 1px solid var(--border);
      position: relative;
    }
    .question-number {
      position: absolute;
      top: -70px;
      left: -50px;
      font-size: 9rem;
      font-weight: bold;
      color: #60a5fa;
      opacity: 0.1;
      pointer-events: none;
      line-height: 1;
    }
    .question-title { font-size: 1.6em; margin-bottom: 24px; line-height: 1.4; }

    .progress-box {
      background: var(--card-bg);
      border-radius: 16px;
      padding: 24px;
      text-align: center;
    }
    .progress-box h4 { color: #60a5fa; margin-bottom: 16px; font-size: 1.4em; }
    .progress-box .reach { font-size: 2em; font-weight: bold; color: #10b981; margin: 20px 0; }

    #progressTitle {
      font-size: 1.4em;
      color: #60a5fa;
      margin-bottom: 16px;
    }
    .nft-container {
      margin: 20px 0;
      flex-grow: 1;
      display: flex;
      align-items: center;
    }
    .nft-placeholder {
      width: 100%;
      height: 280px;
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      box-shadow: 0 8px 25px rgba(0,0,0,0.5);
    }
    .nft-gradient {
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea, #764ba2, #ff9a9e, #fad0c4, #a18cd1);
      background-size: 400% 400%;
      animation: gradientFlow 20s ease infinite;
    }
    @keyframes gradientFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .nft-label {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.95em;
      backdrop-filter: blur(4px);
    }
    .progress-section {
      margin-top: 15px;
    }
    .progress-bar-long {
      height: 20px;
      background: var(--border);
      border-radius: 10px;
      overflow: hidden;
    }
    .progress-fill-long {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #60a5fa);
      transition: width 0.6s ease;
    }
    .progress-label {
      display: block;
      margin-top: 8px;
      font-weight: bold;
      color: #60a5fa;
      font-size: 1.1em;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      max-width: 960px;
      margin: 0 auto 40px auto;
    }
    .stats-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      min-height: 160px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .stats-card h4 {
      color: #94a3b8;
      font-size: 1.1em;
      margin-bottom: 12px;
    }
    .stats-value {
      font-size: 2.6em;
      font-weight: bold;
    }

    .nft-card {
      background: var(--card-bg);
      border-radius: 16px;
      overflow: hidden;
      transition: all 0.25s;
      position: relative;
    }
    .nft-card:hover { transform: translateY(-6px); box-shadow: 0 20px 25px -5px rgba(0,0,0,0.5); }
    .nft-image-placeholder {
      height: 220px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8em;
      font-weight: bold;
      color: white;
      opacity: 0.9;
    }
    .nft-staked-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      background: #10b981;
      color: white;
      font-size: 0.8em;
      padding: 4px 10px;
      border-radius: 999px;
      font-weight: bold;
    }

    /* Profile Panel Styles */
    .profile-slide-panel {
      position: fixed;
      top: 0; right: 0; bottom: 0;
      width: 380px;
      background: #0f121a;
      border-left: 1px solid #1e2535;
      z-index: 99;
      transform: translateX(100%);
      transition: transform 0.35s ease;
      box-shadow: -10px 0 35px rgba(0,0,0,0.7);
      overflow-y: auto;
    }
    .profile-slide-panel:not(.hidden) { transform: translateX(0); }

    .profile-slide-header {
      padding: 18px 24px;
      background: #0a0d14;
      border-bottom: 1px solid #1e2535;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .gear-icon, .close-slide {
      background: none;
      border: none;
      color: #94a3b8;
      font-size: 1.6rem;
      cursor: pointer;
    }

    .profile-slide-balance {
      padding: 32px 24px 20px;
      text-align: center;
    }

    .profile-slide-total {
      font-size: 3.4rem;
      font-weight: 800;
      color: #34d399;
    }

    .profile-slide-actions {
      display: flex;
      gap: 12px;
      padding: 20px 24px;
    }

    .profile-slide-action-btn {
      flex: 1;
      padding: 14px;
      border-radius: 12px;
      border: none;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    .profile-slide-action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }

    .profile-slide-action-btn.deposit { background: linear-gradient(90deg, #10b981, #34d399); }
    .profile-slide-action-btn.swap    { background: linear-gradient(90deg, #0d6efd, #60a5fa); }
    .profile-slide-action-btn.send    { background: linear-gradient(90deg, #8b5cf6, #c084fc); }

    .profile-slide-tabs {
      display: flex;
      margin: 0 24px;
      border-bottom: 1px solid #1e2535;
    }

    .profile-slide-tab {
      flex: 1;
      padding: 14px 0;
      background: none;
      border: none;
      color: #94a3b8;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s ease;
    }

    .profile-slide-tab:hover { color: #d1d5db; }
    .profile-slide-tab.active {
      color: white;
      border-bottom: 3px solid #60a5fa;
    }

    .profile-slide-tab:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(96,165,250,0.4);
    }

    /* Smooth tab content transition */
    .tab-content {
      padding: 20px;
      transition: opacity 0.28s ease, transform 0.28s ease;
      opacity: 0;
      transform: translateY(10px);
      pointer-events: none;
    }

    .tab-content.active {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .profile-slide-assets, .profile-slide-activity {
      min-height: 300px;
    }

    .profile-slide-asset-row {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px 0;
      border-bottom: 1px solid #1e2535;
    }
    .profile-slide-asset-row:last-child { border-bottom: none; }
    .profile-asset-hover {
      cursor: pointer;
      transition: background 0.2s;
    }
    .profile-asset-hover:hover {
      background: rgba(59,130,246,0.1);
      border-radius: 8px;
      padding: 16px 8px;
    }
    .profile-slide-asset-icon {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      object-fit: contain;
      background: #111;
      border: 1px solid #334155;
      flex-shrink: 0;
    }
    .profile-slide-asset-details { flex: 1; }
    .profile-slide-asset-name { font-weight: 600; font-size: 1.1em; }
    .profile-slide-asset-subtitle { font-size: 0.9em; color: #94a3b8; }
    .profile-slide-asset-amounts { text-align: right; }
    .profile-slide-token-amount { font-weight: bold; font-size: 1.1em; }
    .profile-slide-usd-amount { font-size: 0.95em; color: #94a3b8; }

    /* Back Profile Panel */
    .back-profile-panel {
      position: fixed;
      top: 0; right: 0; bottom: 0;
      width: 380px;
      background: #0f121a;
      border-left: 1px solid #1e2535;
      z-index: 99;
      transform: translateX(100%);
      transition: transform 0.35s ease;
      box-shadow: -10px 0 35px rgba(0,0,0,0.7);
      overflow-y: auto;
    }
    .back-profile-panel:not(.hidden) { transform: translateX(0); }

    .panel-content { padding: 24px; }
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }
    .section {
      margin-bottom: 24px;
      background: #11151f;
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #1e2535;
    }
    .section-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 14px;
      color: #cbd5e1;
    }
    .item {
      padding: 16px 0;
      border-bottom: 1px solid #1e2535;
    }
    .item:last-child { border-bottom: none; }
    .item-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }
    .item-text {
      flex: 1;
      font-size: 1.05rem;
      line-height: 1.45;
      word-break: break-word;
    }
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: flex-end;
    }
    .action-btn {
      padding: 7px 16px;
      font-size: 0.9rem;
      border-radius: 6px;
      cursor: pointer;
      border: none;
      color: white;
      min-width: 82px;
    }
    .connect-btn { background: #28a745; }
    .disconnect-btn { background: #ef4444; }
    .logout-btn {
      width: 100%;
      padding: 14px;
      background: #dc2626;
      color: white;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 1.05rem;
      cursor: pointer;
      margin-top: 20px;
    }

    /* Network Switcher */
    .network-switcher {
      display: flex;
      gap: 4px;
      background: rgba(255,255,255,0.06);
      border-radius: 10px;
      padding: 3px;
      margin: 0 8px;
    }
    .network-switcher-btn {
      padding: 5px 10px;
      border: none;
      border-radius: 8px;
      background: transparent;
      color: #94a3b8;
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    .network-switcher-btn:hover { color: #e2e8f0; background: rgba(255,255,255,0.08); }
    .network-switcher-btn.active {
      background: linear-gradient(135deg, #0d6efd, #8b5cf6);
      color: white;
      box-shadow: 0 2px 8px rgba(13,110,253,0.4);
    }

    /* OCID section in back-profile panel */
    .ocid-section {
      margin-top: 20px;
      padding: 14px;
      background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(59,130,246,0.1));
      border-radius: 10px;
      border-left: 3px solid #8b5cf6;
    }
    .ocid-section .section-title { color: #c084fc; margin-bottom: 10px; }
    .ocid-input-wrap { display: flex; gap: 8px; }
    .ocid-input {
      flex: 1;
      background: rgba(255,255,255,0.07);
      border: 1px solid #2e3650;
      color: #e2e8f0;
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 0.9rem;
    }
    .ocid-input:focus { outline: none; border-color: #8b5cf6; }
    .ocid-save-btn {
      background: linear-gradient(135deg, #8b5cf6, #6d28d9);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 14px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .ocid-save-btn:hover { opacity: 0.9; }
    .ocid-badge {
      margin-top: 8px;
      font-size: 0.82rem;
      color: #94a3b8;
    }
    .ocid-badge.verified { color: #34d399; }
    
    /* Ethers Loading Indicator */
    #ethersLoadingIndicator {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #0d6efd 0%, #0a2540 100%);
      color: white;
      padding: 8px 16px;
      text-align: center;
      z-index: 9999;
      font-size: 0.9em;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      display: none;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(-50%) translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }
    
    .ethers-error-overlay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #dc3545;
      color: white;
      padding: 24px;
      border-radius: 12px;
      z-index: 10000;
      max-width: 540px;
      text-align: center;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      border: 2px solid #ff4444;
      animation: slideIn 0.3s ease-out;
    }
    
    .ethers-error-overlay button {
      background: white;
      color: #dc3545;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.2s;
      margin: 0 5px;
    }
    
    .ethers-error-overlay button:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .ethers-error-overlay button.secondary {
      background: #f8f9fa;
      color: #333;
    }
    /* Transaction row hover effect (CSS instead of inline onmouseover/onmouseout) */
    .tx-row { transition: background 0.15s; }
    .tx-row:hover { background: rgba(59, 130, 246, 0.08); }
    
    /* Responsive Design Improvements */
    @media (max-width: 768px) {
      /* Login container ‚Äì smaller margins on mobile */
      .login-container {
        padding: 40px 20px;
        margin: 20px auto;
        border-radius: 16px;
      }
      h1 { font-size: 2.2rem; }
      .subtitle { font-size: 1rem; }

      /* Header stacks on mobile */
      header {
        flex-wrap: wrap;
        gap: 8px;
        padding: 12px 16px;
        justify-content: flex-start;
      }
      .network-switcher { order: -1; width: 100%; justify-content: flex-start; overflow-x: auto; flex-wrap: nowrap; }
      .network-switcher-btn { white-space: nowrap; padding: 6px 10px; font-size: 0.78em; }

      /* Nav bar scrolls horizontally on mobile */
      .nav-bar {
        left: 0;
        right: 0;
        bottom: 0;
        transform: none;
        width: 100%;
        border-radius: 0;
        padding: 10px 8px;
        gap: 6px;
        overflow-x: auto;
        justify-content: flex-start;
      }
      .nav-btn { padding: 10px 14px; font-size: 0.85em; white-space: nowrap; }
      .content { padding-bottom: 70px; }

      /* Profile panel full width on mobile */
      .profile-slide-panel { width: 100%; max-width: 100vw; }

      /* Cards ‚Äì no fixed min-height on mobile */
      .progress-box, .card { min-height: 0 !important; }
      .question-card { min-height: 0 !important; max-width: 100%; }
      .question-box { min-width: 0; width: 100%; }

      /* Flex containers stack on mobile */
      .flex-container > div { min-width: 100%; }

      /* Chart containers */
      .chart-container { width: 100% !important; height: 280px !important; }

      /* NFT cards */
      .nft-grid { grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)) !important; }

      /* Inputs full width */
      input[type="number"], input[type="text"], select { width: 100% !important; max-width: 100%; }

      /* Buttons stack */
      .btn-group { flex-direction: column; gap: 8px; }
      .btn-group button { width: 100%; }

      /* Wallet dropdown width on mobile */
      .wallet-dropdown { min-width: 240px; right: -10px; }

      /* Top buttons smaller on mobile */
      .top-btn { padding: 8px 12px; font-size: 0.85em; }
    }
    
    @media (min-width: 769px) and (max-width: 1024px) {
      /* Tablet adjustments */
      .profile-slide-panel {
        width: 60%;
        max-width: 480px;
      }
      
      /* Flex containers adapt to tablet */
      .flex-container {
        gap: 16px;
      }
    }
    
    @media (max-width: 480px) {
      h1 { font-size: 1.9rem; }
      .subtitle { font-size: 0.9rem; }
      .card { padding: 14px; }
      #walletBtn { font-size: 0.8em; padding: 7px 10px; }
      nav { padding: 10px 14px; }
      .nav-btn { padding: 8px 10px; font-size: 0.82em; }
      .login-container { padding: 30px 16px; }
    }
  </style>
</head>
<body>
  
  <!-- Loading Indicator for Ethers Library -->
  <div id="ethersLoadingIndicator">
    <span style="display:inline-block;margin-right:8px;">‚è≥</span>
    <span id="loadingText">Loading Web3 libraries...</span>
    <span style="display:inline-block;margin-left:8px;animation:pulse 1.5s ease-in-out infinite;">‚óè</span>
  </div>

  <!-- Login Page -->
  <div class="login-container" id="loginPage">
    <h1>Mogaland-Plume Simulator</h1>
    <p class="subtitle">Connect your wallet to get started</p>

    <div style="margin-bottom: 30px;">
      <h3 style="margin-bottom: 15px; color: #60a5fa; font-size: 1.2rem;">Connect Wallet</h3>
      <button class="wallet-choice primary-wallet" onclick="connectMetaMask()">
        <span style="font-size: 1.5rem; margin-right: 10px;">ü¶ä</span>
        MetaMask
      </button>
      <button class="wallet-choice primary-wallet" onclick="connectOKX()">
        <span style="font-size: 1.5rem; margin-right: 10px;">‚ö´</span>
        OKX Wallet
      </button>
      <button class="wallet-choice primary-wallet" onclick="connectTrustWallet()">
        <span style="font-size: 1.5rem; margin-right: 10px;">üõ°Ô∏è</span>
        Trust Wallet
      </button>
      <button class="wallet-choice primary-wallet" onclick="connectWalletConnect()">
        <span style="font-size: 1.5rem; margin-right: 10px;">üîó</span>
        WalletConnect
      </button>
      <p style="margin-top: 15px; font-size: 0.85rem; color: #94a3b8;" id="networkInfoText">
        <strong>Testnet Required</strong><br>
        Connect your wallet to get started<br>
        <span id="faucetLinkText">Need test tokens? <a href="https://sepoliafaucet.com" id="faucetLink" target="_blank" style="color: #60a5fa;">Get faucet tokens</a></span>
      </p>
    </div>

    <div style="margin: 30px 0; display: flex; align-items: center; opacity: 0.5;">
      <div style="flex: 1; height: 1px; background: rgba(255,255,255,0.2);"></div>
      <span style="margin: 0 15px; font-size: 0.9rem;">OR</span>
      <div style="flex: 1; height: 1px; background: rgba(255,255,255,0.2);"></div>
    </div>

    <button class="login-option" onclick="showEmailLogin()">
      <span style="font-size: 1.2rem; margin-right: 8px;">üìß</span>
      Login with Email
    </button>
    <button class="login-option" onclick="showXLogin()">
      <span style="font-size: 1.2rem; margin-right: 8px;">ùïè</span>
      Login with X
    </button>

    <div id="emailLogin" class="hidden">
      <input type="email" id="emailInput" class="input-field" placeholder="Gmail or Yahoo email" pattern="[a-zA-Z0-9._%+-]+@(gmail\.com|yahoo\.com)" title="Please use a valid Gmail or Yahoo email address" />
      <button class="login-option" onclick="sendEmailCode()">Send Mock OTP</button>
      <input type="text" id="otpInput" class="input-field hidden" placeholder="OTP (123456)" maxlength="6" pattern="[0-9]{6}" title="Enter 6-digit OTP" />
      <button class="login-option hidden" id="verifyOtpBtn" onclick="verifyEmailOtp()">Verify</button>
    </div>

    <div id="xLogin" class="hidden">
      <input type="text" id="xInput" class="input-field" placeholder="@yourusername" title="Enter a valid X username starting with @ (e.g., @username)" />
      <button class="login-option" onclick="confirmXLogin()">Confirm</button>
    </div>

    <div id="notification-area"></div>
  </div>

  <!-- Main Dashboard -->
  <div class="main-app hidden" id="mainApp">
    <header>
      <div style="position: relative;">
        <button class="top-btn" id="walletBtn" onclick="toggleWalletDropdown()">Connect Wallet</button>
        <div class="wallet-dropdown" id="walletDropdown">
          <div class="wallet-address" id="walletAddressDisplay">Not Connected</div>
          <div class="wallet-actions">
            <button class="wallet-action-btn" onclick="copyWalletAddress()">
              üìã Copy Address
            </button>
            <button class="wallet-action-btn" onclick="viewOnExplorer()">
              üîç View on Explorer
            </button>
            <button class="wallet-action-btn disconnect" onclick="handleWalletDisconnect()">
              üîå Disconnect Wallet
            </button>
          </div>
        </div>
      </div>
      <!-- Network Switcher (3 chains) -->
      <div class="network-switcher" id="networkSwitcher">
        <button class="network-switcher-btn active" id="netBtn_sepolia"     onclick="switchNetwork('sepolia')">üîµ ETH Sepolia</button>
        <button class="network-switcher-btn"        id="netBtn_educhain"    onclick="switchNetwork('educhain')">üéì EDU Testnet</button>
        <button class="network-switcher-btn"        id="netBtn_basesepolia" onclick="switchNetwork('basesepolia')">üî∑ Base Sepolia</button>
      </div>
      <button class="top-btn" onclick="showVolumeLeaderboard()" style="background:linear-gradient(90deg,#fbbf24,#f59e0b); margin-left:8px;">
        üèÜ Leaderboard
      </button>
      <button class="top-btn" onclick="showProfile()">Profile</button>
    </header>

    <h1>Mogaland-Plume</h1>
    <div class="subtitle">Welcome!</div>

    <div class="content" id="content">
      <p>Select an option below to explore the simulator.</p>
    </div>

    <div class="nav-bar">
      <button class="nav-btn" onclick="showSection('learning', event)">Learning</button>
      <button class="nav-btn" onclick="showSection('market', event)">Market Prediction</button>
      <button class="nav-btn active" onclick="showSection('swap', event)">Swap</button>
      <button class="nav-btn" onclick="showSection('bridge', event)">Bridge</button>
      <button class="nav-btn" onclick="showSection('nft', event)">NFT Staking</button>
    </div>

    <!-- Profile Slide-in Panel -->
    <div id="profileSlidePanel" class="profile-slide-panel hidden">
      <div class="profile-slide-header">
        <button class="gear-icon" onclick="openBackProfile()">‚öôÔ∏è</button>
        <div class="account-title">Main Account ‚ñº</div>
        <button class="close-slide" onclick="closeProfileSlide()">√ó</button>
      </div>

      <div class="profile-slide-balance">
        <div class="profile-slide-total" id="profileBalanceDisplay">Connect Wallet</div>
        <div class="profile-slide-addresses">Addresses ></div>
      </div>

      <div class="profile-slide-actions">
        <button class="profile-slide-action-btn deposit" onclick="openDepositModal()">+ Deposit</button>
        <button class="profile-slide-action-btn swap" onclick="openSwapModal()">‚Üª Swap</button>
        <button class="profile-slide-action-btn send" onclick="openSendModal()">‚Üë Send</button>
      </div>

      <div style="margin: 15px 0; padding: 12px; background: linear-gradient(135deg, rgba(16,185,129,0.1), rgba(59,130,246,0.1)); border-radius: 8px; border-left: 3px solid #10b981;">
        <button onclick="openContributeToTreasury()" style="width: 100%; background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 12px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 0.95em;">
          üè¶ Contribute USDC to Treasury
        </button>
      </div>

      <div class="profile-slide-tabs">
        <button class="profile-slide-tab active" data-tab="assets">Assets</button>
        <button class="profile-slide-tab" data-tab="activity">Activity</button>
      </div>

      <div class="tab-wrapper" style="position:relative; min-height:300px;">
        <div id="assetsContent" class="tab-content active">
          <a href="#" id="ethExplorerLink" target="_blank" rel="noopener noreferrer" style="text-decoration:none; color:inherit;">
            <div class="profile-slide-asset-row profile-asset-hover">
              <img src="https://cryptologos.cc/logos/ethereum-eth-logo.png?v=035" alt="ETH" class="profile-slide-asset-icon">
              <div class="profile-slide-asset-details">
                <div class="profile-slide-asset-name">ETH</div>
                <div class="profile-slide-asset-subtitle" id="ethNetworkSubtitle">Sepolia Testnet ‚Ä¢ View on Explorer ‚Üí</div>
              </div>
              <div class="profile-slide-asset-amounts">
                <div class="profile-slide-token-amount" id="ethBalance">0.0000</div>
                <div class="profile-slide-usd-amount">Testnet</div>
              </div>
            </div>
          </a>

          <a href="#" id="wbtcExplorerLink" target="_blank" rel="noopener noreferrer" style="text-decoration:none; color:inherit;">
            <div class="profile-slide-asset-row profile-asset-hover">
              <img src="https://cryptologos.cc/logos/wrapped-bitcoin-wbtc-logo.png?v=035" alt="WBTC" class="profile-slide-asset-icon">
              <div class="profile-slide-asset-details">
                <div class="profile-slide-asset-name">WBTC</div>
                <div class="profile-slide-asset-subtitle">Wrapped Bitcoin ‚Ä¢ View on Explorer ‚Üí</div>
              </div>
              <div class="profile-slide-asset-amounts">
                <div class="profile-slide-token-amount" id="wbtcBalance">0.0000</div>
                <div class="profile-slide-usd-amount" id="wbtcBalanceUSD">$0.00</div>
              </div>
            </div>
          </a>

          <a href="#" id="usdcExplorerLink" target="_blank" rel="noopener noreferrer" style="text-decoration:none; color:inherit;">
            <div class="profile-slide-asset-row profile-asset-hover">
              <img src="https://cryptologos.cc/logos/usd-coin-usdc-logo.png?v=035" alt="USDC" class="profile-slide-asset-icon">
              <div class="profile-slide-asset-details">
                <div class="profile-slide-asset-name">USDC</div>
                <div class="profile-slide-asset-subtitle">USD Coin ‚Ä¢ View on Explorer ‚Üí</div>
              </div>
              <div class="profile-slide-asset-amounts">
                <div class="profile-slide-token-amount" id="usdcBalance">0.0000</div>
                <div class="profile-slide-usd-amount" id="usdcBalanceUSD">$0.00</div>
              </div>
            </div>
          </a>

          <a href="#" id="usdtExplorerLink" target="_blank" rel="noopener noreferrer" style="text-decoration:none; color:inherit;">
            <div class="profile-slide-asset-row profile-asset-hover">
              <img src="https://cryptologos.cc/logos/tether-usdt-logo.png?v=035" alt="USDT" class="profile-slide-asset-icon">
              <div class="profile-slide-asset-details">
                <div class="profile-slide-asset-name">USDT</div>
                <div class="profile-slide-asset-subtitle">Tether ‚Ä¢ View on Explorer ‚Üí</div>
              </div>
              <div class="profile-slide-asset-amounts">
                <div class="profile-slide-token-amount" id="usdtBalance">0.0000</div>
                <div class="profile-slide-usd-amount" id="usdtBalanceUSD">$0.00</div>
              </div>
            </div>
          </a>
        </div>

        <div id="activityContent" class="tab-content">
          <div id="activityList" style="padding: 10px;">
            <div style="height: 300px; display: flex; align-items: center; justify-content: center; text-align: center; color: #94a3b8; font-size: 1.1em; padding: 20px;">
              <div>
                <div style="font-size: 2.8em; margin-bottom: 12px;">üì≠</div>
                No recent on-chain activity yet.
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Back Profile Panel -->
    <div id="backProfilePanel" class="back-profile-panel hidden">
      <div class="panel-content">
        <div class="panel-header">
          <button class="gear-icon">‚öôÔ∏è</button>
          <div class="account-title">Main Account ‚ñº</div>
          <button class="close-panel" onclick="closeBackProfile()">√ó</button>
        </div>

        <div class="section login">
          <div class="section-title">Login & Connections</div>

          <div class="item" id="walletConnection">
            <div class="item-header">
              <span class="icon">üîó</span>
              <div class="item-text" id="walletConnectionText">
                <span id="walletStatusText">Not Connected</span>
              </div>
            </div>
            <div class="button-group">
              <button class="action-btn connect-btn" onclick="handleWalletConnect()" id="walletConnectBtn">Connect</button>
              <button class="action-btn disconnect-btn" onclick="handleWalletDisconnect()" id="walletDisconnectBtn" style="display:none;">Disconnect</button>
            </div>
          </div>

          <div class="item" id="xConnection">
            <div class="item-header">
              <span class="icon">ùïè</span>
              <div class="item-text">
                <span id="xStatusText">Twitter/X - Not Connected</span>
              </div>
            </div>
            <div class="button-group">
              <button class="action-btn connect-btn" onclick="connectSocial('x')" id="xConnectBtn">Connect</button>
              <button class="action-btn disconnect-btn" onclick="disconnectSocial('x')" id="xDisconnectBtn" style="display:none;">Disconnect</button>
            </div>
          </div>

          <div class="item" id="telegramConnection">
            <div class="item-header">
              <span class="icon">‚úàÔ∏è</span>
              <div class="item-text">
                <span id="telegramStatusText">Telegram - Not Connected</span>
              </div>
            </div>
            <div class="button-group">
              <button class="action-btn connect-btn" onclick="connectSocial('telegram')" id="telegramConnectBtn">Connect</button>
              <button class="action-btn disconnect-btn" onclick="disconnectSocial('telegram')" id="telegramDisconnectBtn" style="display:none;">Disconnect</button>
            </div>
          </div>

          <div class="item" id="discordConnection">
            <div class="item-header">
              <span class="icon">üí¨</span>
              <div class="item-text">
                <span id="discordStatusText">Discord - Not Connected</span>
              </div>
            </div>
            <div class="button-group">
              <button class="action-btn connect-btn" onclick="connectSocial('discord')" id="discordConnectBtn">Connect</button>
              <button class="action-btn disconnect-btn" onclick="disconnectSocial('discord')" id="discordDisconnectBtn" style="display:none;">Disconnect</button>
            </div>
          </div>

          <div class="item" id="farcasterConnection">
            <div class="item-header">
              <span class="icon">üé≠</span>
              <div class="item-text">
                <span id="farcasterStatusText">Farcaster - Not Connected</span>
              </div>
            </div>
            <div class="button-group">
              <button class="action-btn connect-btn" onclick="connectSocial('farcaster')" id="farcasterConnectBtn">Connect</button>
              <button class="action-btn disconnect-btn" onclick="disconnectSocial('farcaster')" id="farcasterDisconnectBtn" style="display:none;">Disconnect</button>
            </div>
          </div>
        </div>

        <!-- OCID (Open Campus ID) -->
        <div class="ocid-section">
          <div class="section-title">üéì Open Campus ID (OCID)</div>
          <div class="ocid-input-wrap">
            <input type="text" id="ocidInput" class="ocid-input" placeholder="Enter your OCID (e.g. 0x123...)" maxlength="42" />
            <button class="ocid-save-btn" onclick="saveOCID()">Save</button>
          </div>
          <div class="ocid-badge" id="ocidBadge">No OCID connected</div>
        </div>

        <button class="logout-btn" onclick="logoutUser()">Log Out</button>
      </div>
    </div>
  </div>

  <script>
    // === FULL SCRIPT - ALL FEATURES INCLUDED ===
    
    // Wait for ethers library to load before initializing
    const MAX_LOAD_TIMEOUT_MS = 15000; // Maximum time to wait for ethers.js (increased to 15s for fallback CDNs)
    const POLL_INTERVAL_MS = 100; // Check every 100ms
    const maxEthersLoadAttempts = MAX_LOAD_TIMEOUT_MS / POLL_INTERVAL_MS; // 150 attempts
    let ethersLoadAttempts = 0;
    
    // Global constants for Sepolia network
    const SEPOLIA_CHAIN_ID = 11155111;
    const SEPOLIA_CHAIN_HEX = "0xaa36a7";
    // Multiple RPC endpoints for better reliability
    const SEPOLIA_RPC_URLS = [
      "https://1rpc.io/sepolia",
      "https://rpc.sepolia.org",
      "https://ethereum-sepolia.publicnode.com",
      "https://rpc2.sepolia.org"
    ];
    const SEPOLIA_RPC = SEPOLIA_RPC_URLS[0]; // Primary RPC
    const SEPOLIA_EXPLORER = "https://sepolia.etherscan.io";
    const SEPOLIA_FAUCET = "https://sepoliafaucet.com";

    // EDU Chain Testnet constants
    const EDU_CHAIN_ID = 656476;
    const EDU_CHAIN_HEX = "0xa045c";
    const EDU_RPC_URL = "https://rpc.open-campus-codex.gelato.digital";
    const EDU_EXPLORER = "https://edu-chain-testnet.blockscout.com";
    const EDU_FAUCET = "https://educhain-community-faucet.vercel.app/";

    // Base Sepolia constants
    const BASE_SEPOLIA_CHAIN_ID = 84532;
    const BASE_SEPOLIA_CHAIN_HEX = "0x14a34";
    const BASE_SEPOLIA_RPC_URL = "https://sepolia.base.org";
    const BASE_SEPOLIA_EXPLORER = "https://sepolia.basescan.org";
    const BASE_SEPOLIA_FAUCET = "https://www.coinbase.com/faucets/base-ethereum-sepolia-faucet";

    // Network configurations map
    const NETWORKS = {
      sepolia: {
        id: 'sepolia',
        name: 'ETH Sepolia',
        chainId: SEPOLIA_CHAIN_ID,
        chainHex: SEPOLIA_CHAIN_HEX,
        rpcUrls: SEPOLIA_RPC_URLS,
        explorer: SEPOLIA_EXPLORER,
        faucet: SEPOLIA_FAUCET,
        currency: 'ETH',
        label: 'üîµ ETH Sepolia'
      },
      educhain: {
        id: 'educhain',
        name: 'EDU Chain Testnet',
        chainId: EDU_CHAIN_ID,
        chainHex: EDU_CHAIN_HEX,
        rpcUrls: [EDU_RPC_URL],
        explorer: EDU_EXPLORER,
        faucet: EDU_FAUCET,
        currency: 'EDU',
        label: 'üéì EDU Chain Testnet'
      },
      basesepolia: {
        id: 'basesepolia',
        name: 'Base Sepolia',
        chainId: BASE_SEPOLIA_CHAIN_ID,
        chainHex: BASE_SEPOLIA_CHAIN_HEX,
        rpcUrls: [BASE_SEPOLIA_RPC_URL],
        explorer: BASE_SEPOLIA_EXPLORER,
        faucet: BASE_SEPOLIA_FAUCET,
        currency: 'ETH',
        label: 'üî∑ Base Sepolia'
      }
    };

    // Active network ‚Äì persisted in localStorage
    let currentNetworkId = localStorage.getItem('currentNetworkId') || 'sepolia';
    function getActiveNetwork() { return NETWORKS[currentNetworkId] || NETWORKS.sepolia; }
    // Helper: returns the block explorer API base URL for the active network
    function getExplorerApiUrl() {
      const net = getActiveNetwork();
      if (net.id === 'sepolia') return 'https://api-sepolia.etherscan.io/api';
      if (net.id === 'basesepolia') return 'https://api-sepolia.basescan.org/api';
      if (net.id === 'educhain') return 'https://edu-chain-testnet.blockscout.com/api';
      return null;
    }
    // Helper: native currency symbol for the active network
    function getNetworkCurrency() { return getActiveNetwork().currency; }

    // WalletConnect v2 Project ID from https://cloud.reown.com (formerly WalletConnect Cloud)
    const WALLETCONNECT_PROJECT_ID = "51e44cec955a70475db9cc1900283704";
    
    // Global wallet variables
    let provider = null;
    let userAddress = null;
    
    // Uniswap V3 Contract Addresses on Sepolia
    const UNISWAP_V3_QUOTER_V2 = "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3";
    const WETH9_SEPOLIA = "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14";
    const USDC_SEPOLIA = "0x94a9D9AC8a22534E3FaCa9F4e7F2E2cf85d5E4C8";
    const USDT_SEPOLIA = "0x7169D38820dfd117C3FA1f22a697dBA58d90BA06";
    const GHO_SEPOLIA = "0xc4bF5CbDaBE595361438F8c6a187bDc330539c60"; // Aave GHO Token
    const LINK_SEPOLIA = "0x779877A7B0D9E8603169DdbD7836e478b4624789";
    const WBTC_SEPOLIA = "0x29f2D40B0605204364af54EC677bD022dA425d03";
    const AAVE_SEPOLIA = "0x88541670E55cC00bEEFD87eB59EDd1b7C511AC9a";
    const EURO_SEPOLIA = "0x08210F9170F89Ab7658F0B5E3fF39b0E03C594D4";
    
    // Aliases for backward compatibility
    const USDC_SEPOLIA_ADDRESS = USDC_SEPOLIA;
    const USDT_SEPOLIA_ADDRESS = USDT_SEPOLIA;
    const GHO_SEPOLIA_ADDRESS = GHO_SEPOLIA;
    const LINK_SEPOLIA_ADDRESS = LINK_SEPOLIA;
    const WBTC_SEPOLIA_ADDRESS = WBTC_SEPOLIA;
    const AAVE_SEPOLIA_ADDRESS = AAVE_SEPOLIA;
    const EURO_SEPOLIA_ADDRESS = EURO_SEPOLIA;
    
    // Uniswap V3 Quoter ABI (minimal for price quotes)
    const UNISWAP_V3_QUOTER_ABI = [
      "function quoteExactInputSingle(tuple(address tokenIn, address tokenOut, uint256 amountIn, uint24 fee, uint160 sqrtPriceLimitX96) params) external returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)"
    ];
    
    // Uniswap V3 SwapRouter02 on Sepolia
    const UNISWAP_V3_ROUTER = "0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E";
    
    // Uniswap V3 SwapRouter ABI (minimal for swaps)
    const UNISWAP_V3_ROUTER_ABI = [
      "function exactInputSingle(tuple(address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96) params) external payable returns (uint256 amountOut)",
      "function exactInput(tuple(bytes path, address recipient, uint256 amountIn, uint256 amountOutMinimum) params) external payable returns (uint256 amountOut)",
      "function unwrapWETH9(uint256 amountMinimum, address recipient) external payable"
    ];
    
    // Gas and price constants
    let ETH_TO_USDC_RATE = 2500; // 1 ETH = 2500 USDC (will be updated with real Uniswap price)
    const GAS_FEE_ETH = 0.00001; // Gas fee in ETH Sepolia (approximately 0.00001 ETH per action)
    const GAS_FEE_USDC = 0.025; // Gas fee in USDC equivalent (approximately 0.025 USDC per action)
    const CHART_HEIGHT = 420; // Standard height for trading charts in pixels
    
    // CORS proxy for CoinGecko API (fallback when direct access fails)
    // Note: For production, consider:
    // 1. Backend proxy server (Node.js/Express) for better security and control
    // 2. CoinGecko Pro API with CORS support
    // 3. Your own API server that caches price data
    // Current proxy: allorigins.win (free CORS proxy service)
    const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
    
    // Helper function to fetch with CORS proxy fallback
    // Attempts direct fetch first, then falls back to proxy if CORS blocks the request
    async function fetchWithCORSFallback(url) {
      try {
        // Try direct fetch first
        const response = await fetch(url);
        if (response.ok) {
          return await response.json();
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      } catch (error) {
        console.log(`[CORS] Direct fetch failed for ${url}:`, error.message);
        try {
          // Try with CORS proxy
          const proxyResponse = await fetch(CORS_PROXY + encodeURIComponent(url));
          if (proxyResponse.ok) {
            return await proxyResponse.json();
          }
          throw new Error(`Proxy HTTP ${proxyResponse.status}: ${proxyResponse.statusText}`);
        } catch (proxyError) {
          console.log('[CORS] Proxy fetch also failed:', proxyError.message);
        }
        // Return null if both fail - caller should handle fallback
        return null;
      }
    }
    
    // Gas estimation constants for different transaction types
    const GAS_LIMITS = {
      LEARNING: 50000,
      SWAP: 150000,
      BRIDGE: 200000,
      STAKE_BASE: 100000,
      STAKE_PER_NFT: 50000,
      TRADE: 120000,
      DEFAULT: 100000,
      GAS_FEE_PAYMENT: 30000, // ETH transfer with optional data for gas fee
      NFT_STAKE_TX: 60000, // ETH transfer with NFT staking data
      POSITION_OPEN: 100000, // ETH transfer for opening position
      POSITION_CLOSE: 80000 // ETH transfer with position close data
    };
    
    // Liquidation system constants
    const LIQUIDATION_CONFIG = {
      MAINTENANCE_MARGIN_PERCENT: 20, // 20% of position value must remain as equity
      LIQUIDATION_THRESHOLD_PERCENT: 15, // Liquidation triggers at 15% equity
      WARNING_THRESHOLD_PERCENT: 30, // Show warning at 30% equity
      LIQUIDATION_FEE_PERCENT: 5, // 5% fee goes to treasury on liquidation
      CHECK_INTERVAL_MS: 5000 // Check for liquidations every 5 seconds
    };
    
    // Price update constants
    const PRICE_UPDATE_CONFIG = {
      MIN_CHANGE_THRESHOLD_RATIO: 0.001, // 0.1% minimum price change to update (as decimal ratio: 0.001 = 0.1%)
      UPDATE_INTERVAL_MS: 5000, // Update prices every 5 seconds
      CHAINLINK_STALENESS_THRESHOLD_SECONDS: 3600 // Reject Chainlink data older than 1 hour
    };
    
    // Price simulation constants
    const SIMULATED_PRICE_VARIATION = 0.02; // 2% price variation for fallback when API unavailable
    
    // Function to fetch live ETH/USDC rate from Uniswap V3
    async function fetchLiveETHtoUSDCRate() {
      try {
        if (!provider) {
          console.log('[Uniswap] Provider not available, using default rate');
          return ETH_TO_USDC_RATE;
        }
        
        const quoterContract = new ethers.Contract(UNISWAP_V3_QUOTER_V2, UNISWAP_V3_QUOTER_ABI, provider);
        
        // Quote 1 ETH to USDC (use 0.3% fee tier - 3000)
        const amountIn = ethers.utils.parseEther("1"); // 1 ETH
        const params = {
          tokenIn: WETH9_SEPOLIA,
          tokenOut: USDC_SEPOLIA,
          amountIn: amountIn,
          fee: 3000, // 0.3% fee tier
          sqrtPriceLimitX96: 0
        };
        
        const result = await quoterContract.callStatic.quoteExactInputSingle(params);
        const amountOut = result.amountOut || result[0]; // Handle both tuple and single return
        
        // USDC has 6 decimals
        const rate = parseFloat(ethers.utils.formatUnits(amountOut, 6));
        
        if (rate > 0 && rate < 10000) { // Sanity check
          ETH_TO_USDC_RATE = rate;
          console.log(`[Uniswap] Live ETH/USDC rate: ${rate.toFixed(2)} USDC per ETH`);
          return rate;
        } else {
          console.log('[Uniswap] Rate out of expected range, using default');
          return ETH_TO_USDC_RATE;
        }
      } catch (error) {
        console.log('[Uniswap] Error fetching rate:', error.message);
        return ETH_TO_USDC_RATE;
      }
    }
    
    // Wallet persistence constants
    const WALLET_CONNECTION_EXPIRY_MS = 24 * 60 * 60 * 1000; // 24 hours
    const AUTO_RECONNECT_DELAY_MS = 1000; // 1 second
    const BALANCE_REFRESH_DELAY_MS = 1000; // 1 second
    
    // Wallet persistence helpers
    function saveWalletConnection(walletType, address) {
      localStorage.setItem('lastWalletType', walletType);
      localStorage.setItem('lastWalletAddress', address);
      localStorage.setItem('walletConnectedAt', Date.now().toString());
    }
    
    function clearWalletConnection() {
      localStorage.removeItem('lastWalletType');
      localStorage.removeItem('lastWalletAddress');
      localStorage.removeItem('walletConnectedAt');
    }
    
    function getSavedWalletConnection() {
      const walletType = localStorage.getItem('lastWalletType');
      const address = localStorage.getItem('lastWalletAddress');
      const connectedAt = localStorage.getItem('walletConnectedAt');
      
      // Check if connection is less than expiry time
      if (walletType && address && connectedAt) {
        const age = Date.now() - parseInt(connectedAt);
        if (age < WALLET_CONNECTION_EXPIRY_MS) {
          return { walletType, address };
        }
      }
      return null;
    }
    
    // Auto-reconnect wallet on page load
    async function autoReconnectWallet() {
      const saved = getSavedWalletConnection();
      if (!saved) return false;
      
      console.log(`[Auto-reconnect] Attempting to reconnect ${saved.walletType}...`);
      
      try {
        // Check for OKX wallet first (more specific)
        if ((saved.walletType === 'OKX') && (window.okxwallet || window.okex)) {
          await connectOKX();
          return true;
        }
        // WalletConnect
        else if (saved.walletType === 'WalletConnect' && window.WalletConnectV2Available) {
          await connectWalletConnect();
          return true;
        }
        // Then check for MetaMask
        else if (saved.walletType === 'MetaMask' && window.ethereum) {
          await connectMetaMask();
          return true;
        }
        // Trust Wallet (uses ethereum but less specific)
        else if ((saved.walletType === 'Trust' || saved.walletType === 'Trust Wallet') && window.ethereum) {
          await connectTrustWallet();
          return true;
        }
      } catch (e) {
        console.log('[Auto-reconnect] Failed:', e.message);
        clearWalletConnection();
      }
      return false;
    }
    
    // Wallet event listeners for account/chain changes
    function setupWalletEventListeners() {
      // Get the active wallet provider (window.ethereum for MetaMask/Trust, window.okxwallet for OKX, etc.)
      const activeProvider = provider?.provider || window.ethereum || window.okxwallet;
      
      if (activeProvider && activeProvider.on) {
        // Listen for account changes
        activeProvider.on('accountsChanged', async (accounts) => {
          if (accounts.length === 0) {
            // User disconnected wallet
            showNotification("Wallet disconnected", true);
            disconnectWallet();
          } else if (accounts[0].toLowerCase() !== (userAddress?.toLowerCase() || '')) {
            // User switched account
            showNotification("Account changed. Reconnecting...", false);
            userAddress = accounts[0].toLowerCase();
            saveWalletConnection(localStorage.getItem('lastWalletType') || 'MetaMask', userAddress);
            updateWalletUI();
            if (typeof fetchRealBalances === 'function') {
              fetchRealBalances();
            }
          }
        });
        
        // Listen for chain changes
        activeProvider.on('chainChanged', (chainId) => {
          const incomingId = parseInt(chainId, 16);
          const net = getActiveNetwork();
          if (incomingId !== net.chainId) {
            showNotification(`‚ö†Ô∏è Network changed. Please switch back to ${net.name} or use the network switcher.`, true);
          } else {
            showNotification(`‚úÖ Switched to ${net.name}`, false);
          }
          // Reload balances on chain change
          if (typeof fetchRealBalances === 'function') {
            setTimeout(() => fetchRealBalances(), BALANCE_REFRESH_DELAY_MS);
          }
        });
        
        console.log('‚úÖ Wallet event listeners configured');
      } else {
        console.warn('‚ö†Ô∏è No compatible wallet provider found for event listeners');
      }
    }
    
    // Update wallet UI helper
    function updateWalletUI() {
      if (!userAddress) return;
      
      const walletBtn = document.getElementById('walletBtn');
      if (walletBtn) {
        walletBtn.textContent = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;
        walletBtn.classList.add('connected');
      }
      
      const addressDisplay = document.getElementById('walletAddressDisplay');
      if (addressDisplay) {
        addressDisplay.textContent = userAddress;
      }
    }
    
    // Login UI functions - Available immediately (don't need ethers.js)
    function showEmailLogin() { toggleSections('emailLogin'); }
    function showXLogin() { toggleSections('xLogin'); }
    
    // Expose login functions to window for onclick handlers
    window.showEmailLogin = showEmailLogin;
    window.showXLogin = showXLogin;
    
    function toggleSections(showId) {
      ['emailLogin', 'xLogin'].forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.classList.toggle('hidden', id !== showId);
        }
      });
    }
    
    // Notification system - available before ethers loads
    function showNotification(msg, error = false) {
      const div = document.createElement('div');
      div.className = 'notification';
      div.style.borderColor = error ? 'var(--danger)' : 'var(--bell)';
      
      const icon = document.createElement('span');
      icon.textContent = error ? '‚ö†Ô∏è' : 'üîî';
      
      const text = document.createTextNode(' ' + msg);
      
      div.appendChild(icon);
      div.appendChild(text);
      document.body.appendChild(div);
      setTimeout(() => div.remove(), 6000);
    }
    
    // Mock login variables and functions - available before ethers loads
    const mockOtp = "123456";
    let loginMethod = null; // 'wallet', 'email', or 'x'
    let walletConnected = false;
    
    function sendEmailCode() {
      try {
        const email = document.getElementById('emailInput').value.trim();
        // Proper email validation with regex
        const emailRegex = /^[a-zA-Z0-9._%+-]+@(gmail\.com|yahoo\.com)$/;
        if (!emailRegex.test(email)) {
          return showNotification("Please use a valid Gmail or Yahoo email address.", true);
        }
        showNotification(`Mock OTP sent: ${mockOtp}`);
        document.getElementById('otpInput').classList.remove('hidden');
        document.getElementById('verifyOtpBtn').classList.remove('hidden');
      } catch (error) {
        console.error("Email login error:", error);
        showNotification("Error sending OTP. Please try again.", true);
      }
    }
    window.sendEmailCode = sendEmailCode;

    function verifyEmailOtp() {
      try {
        const otpValue = document.getElementById('otpInput').value.trim();
        if (otpValue === mockOtp) {
          enterDashboard("Email");
        } else {
          showNotification("Wrong OTP", true);
        }
      } catch (error) {
        console.error("OTP verification error:", error);
        showNotification("Error verifying OTP. Please try again.", true);
      }
    }
    window.verifyEmailOtp = verifyEmailOtp;

    function confirmXLogin() {
      try {
        const handle = document.getElementById('xInput').value.trim();
        // Proper X username validation: starts with @, followed by 1-15 alphanumeric/underscore characters
        const xUsernameRegex = /^@[a-zA-Z0-9_]{1,15}$/;
        if (!xUsernameRegex.test(handle)) {
          return showNotification("Please enter a valid X username (e.g., @username)", true);
        }
        enterDashboard("X");
      } catch (error) {
        console.error("X login error:", error);
        showNotification("Error with X login. Please try again.", true);
      }
    }
    window.confirmXLogin = confirmXLogin;

    function enterDashboard(method) {
      loginMethod = method.toLowerCase();
      if (method === 'Wallet' || method === 'MetaMask' || method === 'OKX' || method === 'Trust' || method === 'Trust Wallet' || method === 'WalletConnect') {
        loginMethod = 'wallet';
        walletConnected = true;
      } else if (method === 'Email') {
        loginMethod = 'email';
      } else if (method === 'X') {
        loginMethod = 'x';
      }
      console.log(`[Login] Method: ${loginMethod}, Wallet: ${walletConnected}`);
      showNotification(`Entered via ${method}`, false);
      document.getElementById('loginPage').classList.add('hidden');
      document.getElementById('mainApp').classList.remove('hidden');
      
      // Initialize network switcher UI
      updateNetworkSwitcherUI();

      // Load OCID
      loadOCID();

      // Initialize profile tabs if startApp has loaded
      if (typeof initProfileTabs === 'function') {
        initProfileTabs();
      }
      
      // Load social connections status if startApp has loaded
      if (typeof loadSocialConnections === 'function') {
        loadSocialConnections();
      }
      
      // Restore last visited section
      const lastSection = localStorage.getItem('lastSection');
      if (lastSection) {
        setTimeout(() => {
          if (typeof showSection === 'function') {
            showSection(lastSection);
            localStorage.removeItem('lastSection'); // Clear after restoring
          }
        }, 500);
      } else {
        // Default to swap section after brief delay to ensure DOM is ready
        setTimeout(() => {
          if (typeof showSection === 'function') {
            showSection('swap');
          }
        }, 100); // 100ms delay for DOM readiness
      }
      
      // Start sports auto-update (every 5 minutes) if available
      if (typeof startSportsAutoUpdate === 'function') {
        startSportsAutoUpdate();
      }
    }
    
    // Wallet connection functions - need to be global for onclick handlers
    // These will be populated once ethers.js loads
    async function connectWallet(walletType, getProvider) {
      if (typeof ethers === 'undefined') {
        return showNotification("Web3 libraries still loading. Please wait...", true);
      }
      
      try {
        // Show loading notification
        showNotification(`üîÑ Connecting to ${walletType}...`, false);
        
        provider = getProvider();
        
        // Get the raw provider for network operations
        const rawProvider = provider.provider;
        
        // Request account access
        await provider.send("eth_requestAccounts", []);
        
        // Check current network and auto-switch to the selected network if needed
        showNotification(`üîÑ Checking network...`, false);
        const net = getActiveNetwork();
        const network = await provider.getNetwork();
        if (network.chainId !== net.chainId) {
          showNotification(`üîÑ Switching to ${net.name}...`, false);
          try {
            // Try to switch to the selected network using the raw provider
            await rawProvider.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: net.chainHex }],
            });
            showNotification(`‚úÖ Switched to ${net.name}`, false);
          } catch (switchError) {
            // If network doesn't exist, add it
            if (switchError.code === 4902) {
              try {
                await rawProvider.request({
                  method: 'wallet_addEthereumChain',
                  params: [{
                    chainId: net.chainHex,
                    chainName: net.name,
                    nativeCurrency: {
                      name: net.currency,
                      symbol: net.currency,
                      decimals: 18
                    },
                    rpcUrls: net.rpcUrls,
                    blockExplorerUrls: [net.explorer]
                  }],
                });
                showNotification(`‚úÖ Added and switched to ${net.name}`, false);
              } catch (addError) {
                showNotification(`Failed to add ${net.name}`, true);
                console.error("Add network error:", addError);
                return;
              }
            } else {
              showNotification(`Failed to switch to ${net.name}. Please switch manually.`, true);
              console.error("Switch network error:", switchError);
              return;
            }
          }
        }
        
        // Get user address and balance
        userAddress = (await provider.getSigner().getAddress()).toLowerCase();
        const balanceWei = await provider.getBalance(userAddress);
        const balanceEth = ethers.utils.formatEther(balanceWei);
        
        // Update UI - wallet button
        const walletBtn = document.getElementById('walletBtn');
        if (walletBtn) {
          walletBtn.textContent = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;
          walletBtn.classList.add('connected');
        }
        
        // Update wallet dropdown address display
        const addressDisplay = document.getElementById('walletAddressDisplay');
        if (addressDisplay) {
          addressDisplay.textContent = userAddress;
        }
        
        // Update profile balance displays
        const profileTotal = document.querySelector('.profile-slide-total');
        if (profileTotal) {
          profileTotal.textContent = `${parseFloat(balanceEth).toFixed(4)} ETH`;
        }
        
        const ethBalanceEl = document.getElementById('ethBalance');
        if (ethBalanceEl) {
          ethBalanceEl.textContent = parseFloat(balanceEth).toFixed(4);
        }
        
        // Save wallet connection for auto-reconnect
        saveWalletConnection(walletType, userAddress);
        if (typeof loadTxHistory === 'function') loadTxHistory();
        
        // Setup wallet event listeners
        setupWalletEventListeners();
        
        showNotification(`‚úÖ Connected via ${walletType} on ${getActiveNetwork().name} ‚Äì Balance: ${parseFloat(balanceEth).toFixed(4)} ${getNetworkCurrency()}`, false);
        
        // Show faucet notification if balance is low
        const balanceNum = parseFloat(balanceEth);
        if (balanceNum < 0.01) {
          setTimeout(() => {
            showNotification(`üí∞ Low balance detected. Get free test ${getNetworkCurrency()} from: ${getActiveNetwork().faucet}`, false);
          }, 3000);
        }
        
        enterDashboard(walletType);
        
        // Load user trading volume data
        loadUserTradingVolume();
        
        // Fetch real balances if function is available (may not be defined yet if startApp() hasn't completed)
        if (typeof fetchRealBalances === 'function') {
          fetchRealBalances();
        }
      } catch (e) {
        showNotification("Connection failed: " + (e.message || "Error"), true);
        clearWalletConnection();
      }
    }

    function connectMetaMask() {
      if (typeof ethers === 'undefined') {
        return showNotification("Web3 libraries still loading. Please wait...", true);
      }
      
      if (!window.ethereum) {
        showNotification("MetaMask not found. Please install MetaMask extension from https://metamask.io", true);
        return;
      }
      
      // Check if it's actually MetaMask
      if (window.ethereum.isMetaMask) {
        connectWallet("MetaMask", () => new ethers.providers.Web3Provider(window.ethereum));
      } else {
        // Fallback for injected ethereum provider
        showNotification("MetaMask not detected. Connecting with available wallet...", false);
        connectWallet("MetaMask", () => new ethers.providers.Web3Provider(window.ethereum));
      }
    }
    window.connectMetaMask = connectMetaMask;

    function connectOKX() {
      if (typeof ethers === 'undefined') {
        return showNotification("Web3 libraries still loading. Please wait...", true);
      }
      
      // OKX Wallet can be available at window.okxwallet or window.okex
      const okxProvider = window.okxwallet || window.okex;
      
      if (!okxProvider) {
        showNotification("OKX Wallet not found. Please install OKX Wallet extension from https://okx.com/web3", true);
        return;
      }
      
      connectWallet("OKX", () => new ethers.providers.Web3Provider(okxProvider));
    }
    window.connectOKX = connectOKX;

    function connectTrustWallet() {
      if (typeof ethers === 'undefined') {
        return showNotification("Web3 libraries still loading. Please wait...", true);
      }
      
      // Trust Wallet uses window.ethereum but has isTrust property when in Trust Wallet browser
      if (!window.ethereum) {
        showNotification("Trust Wallet not detected. Please install Trust Wallet extension or use Trust Wallet browser from https://trustwallet.com", true);
        return;
      }
      
      // Check if it's Trust Wallet
      if (window.ethereum.isTrust) {
        connectWallet("Trust Wallet", () => new ethers.providers.Web3Provider(window.ethereum));
      } else {
        // Fallback - might work with other wallets
        showNotification("Trust Wallet not specifically detected. Connecting with available wallet...", false);
        connectWallet("Trust Wallet", () => new ethers.providers.Web3Provider(window.ethereum));
      }
    }
    window.connectTrustWallet = connectTrustWallet;

    async function connectWalletConnect() {
      if (typeof ethers === 'undefined') {
        return showNotification("Web3 libraries still loading. Please wait...", true);
      }
      
      if (!window.WalletConnectV2Available || typeof window.EthereumProvider === 'undefined') {
        showNotification("‚è≥ WalletConnect v2 library still loading. Please wait a moment and try again.", true);
        console.warn('WalletConnect not available:', {
          v2Available: window.WalletConnectV2Available,
          providerType: typeof window.EthereumProvider
        });
        return;
      }
      
      try {
        showNotification("üîÑ Initializing WalletConnect...", false);
        
        // Check if provider already exists and is connected
        if (window.WalletConnectProvider && window.WalletConnectProvider.connected) {
          console.log('Using existing WalletConnect session');
          connectWallet("WalletConnect", () => new ethers.providers.Web3Provider(window.WalletConnectProvider));
          return;
        }
        
        // Initialize WalletConnect v2 provider with proper configuration
        const wcProvider = await window.EthereumProvider.init({
          projectId: WALLETCONNECT_PROJECT_ID,
          chains: [SEPOLIA_CHAIN_ID], // eip155 format handled internally
          optionalChains: [SEPOLIA_CHAIN_ID],
          rpcMap: {
            [SEPOLIA_CHAIN_ID]: SEPOLIA_RPC
          },
          showQrModal: true,
          qrModalOptions: {
            themeMode: 'dark',
            themeVariables: {
              '--wcm-z-index': '10000'
            }
          },
          metadata: {
            name: 'Mogaland-Plume Simulator',
            description: 'DeFi Learning & Trading Simulator',
            url: window.location.origin,
            icons: ['https://avatars.githubusercontent.com/u/37784886']
          }
        });
        
        console.log('WalletConnect provider initialized');
        
        // Store provider globally for reuse
        window.WalletConnectProvider = wcProvider;
        
        // Enable session (shows QR code modal)
        showNotification("üì± Scan QR code with your wallet app...", false);
        await wcProvider.enable();
        
        console.log('WalletConnect session enabled');
        
        // Assign to window for ethers.js access
        window.walletProvider = wcProvider;
        
        // Connect wallet
        connectWallet("WalletConnect", () => new ethers.providers.Web3Provider(wcProvider));
      } catch (e) {
        // Clear stored provider on error
        window.WalletConnectProvider = null;
        
        if (e.message && e.message.includes('User closed modal')) {
          showNotification("‚ùå WalletConnect connection cancelled", false);
        } else if (e.message && e.message.includes('User rejected')) {
          showNotification("‚ùå Connection rejected by user", false);
        } else {
          showNotification("‚ùå WalletConnect error: " + (e.message || "Connection failed"), true);
          console.error("WalletConnect v2 error:", e);
        }
      }
    }
    window.connectWalletConnect = connectWalletConnect;
    
    // Function to connect wallet from within the app (after email/X login)
    function connectWalletFromApp() {
      if (userAddress) {
        showNotification("Wallet already connected!", false);
        return;
      }
      
      // Create modal using DOM methods for security
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; z-index:10000;';
      
      const modalContent = document.createElement('div');
      modalContent.style.cssText = 'background:var(--card-bg); border-radius:20px; padding:40px; max-width:400px; width:90%; text-align:center; border:1px solid var(--border);';
      
      const title = document.createElement('h2');
      title.style.cssText = 'margin-bottom:24px; color:white;';
      title.textContent = 'Connect Wallet';
      modalContent.appendChild(title);
      
      // Helper function to create wallet buttons
      function createWalletButton(text, connectFn) {
        const btn = document.createElement('button');
        btn.className = 'wallet-choice';
        btn.style.cssText = 'width:100%; margin:12px 0; padding:16px; background:var(--primary); color:white; border:none; border-radius:12px; cursor:pointer; font-size:1.1em;';
        btn.textContent = text;
        btn.addEventListener('click', () => {
          connectFn();
          document.body.removeChild(modal);
        });
        return btn;
      }
      
      // Add wallet buttons (now includes WalletConnect v2)
      modalContent.appendChild(createWalletButton('MetaMask', connectMetaMask));
      modalContent.appendChild(createWalletButton('OKX Wallet', connectOKX));
      modalContent.appendChild(createWalletButton('Trust Wallet', connectTrustWallet));
      modalContent.appendChild(createWalletButton('WalletConnect', connectWalletConnect));
      
      // Cancel button
      const cancelBtn = document.createElement('button');
      cancelBtn.style.cssText = 'width:100%; margin:20px 0 0; padding:14px; background:var(--danger); color:white; border:none; border-radius:12px; cursor:pointer; font-size:1em;';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      modalContent.appendChild(cancelBtn);
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
    }
    window.connectWalletFromApp = connectWalletFromApp;
    
    function initializeApp() {
      // Initialize network switcher UI immediately (doesn't require ethers)
      if (ethersLoadAttempts === 0) {
        updateNetworkSwitcherUI();
      }

      // Cache loading indicator reference to avoid redundant DOM queries
      const loadingIndicator = document.getElementById('ethersLoadingIndicator');
      const loadingText = document.getElementById('loadingText');
      
      // Show loading indicator on first attempt
      if (loadingIndicator && ethersLoadAttempts === 0) {
        loadingIndicator.style.display = 'block';
      }
      
      if (typeof ethers === 'undefined') {
        ethersLoadAttempts++;
        
        // Update loading text periodically with actual attempt count
        if (loadingText && ethersLoadAttempts % 10 === 0) {
          loadingText.textContent = 'Loading Web3 libraries... (' + ethersLoadAttempts + '/' + maxEthersLoadAttempts + ')';
        }
        
        // Check if all CDNs have failed
        if (window.ethersLoadFailed || ethersLoadAttempts >= maxEthersLoadAttempts) {
          console.error('Failed to load ethers library after ' + MAX_LOAD_TIMEOUT_MS + 'ms');
          
          // Hide loading indicator
          if (loadingIndicator) {
            loadingIndicator.style.display = 'none';
          }
          
          // Create error overlay using DOM methods for better security
          const errorDiv = document.createElement('div');
          errorDiv.className = 'ethers-error-overlay';
          errorDiv.setAttribute('role', 'alert');
          
          // Create error content
          const icon = document.createElement('div');
          icon.style.cssText = 'font-size:2em;margin-bottom:12px;';
          icon.textContent = '‚ö†Ô∏è';
          
          const title = document.createElement('strong');
          title.style.cssText = 'font-size:1.3em;display:block;margin-bottom:12px;';
          title.textContent = 'Connection Failed - ethers not defined';
          
          const description = document.createElement('p');
          description.style.cssText = 'margin-bottom:16px;line-height:1.5;';
          description.textContent = 'Failed to load required libraries. This prevents wallet connections (MetaMask, TrustWallet, OKX).';
          
          const tryText = document.createElement('p');
          tryText.style.cssText = 'font-size:0.9em;opacity:0.9;margin-bottom:12px;';
          tryText.textContent = 'Please try:';
          
          const suggestions = document.createElement('ul');
          suggestions.style.cssText = 'text-align:left;margin:0 auto 16px;display:inline-block;font-size:0.9em;';
          
          // Create list items using DOM methods for consistency and security
          const suggestionItems = [
            '‚úì Check your internet connection',
            '‚úì Disable ad blockers/content blockers for this site',
            '‚úì Try a different browser or device',
            '‚úì Check firewall/proxy settings'
          ];
          
          suggestionItems.forEach(function(text) {
            const li = document.createElement('li');
            li.textContent = text;
            suggestions.appendChild(li);
          });
          
          const buttonContainer = document.createElement('div');
          buttonContainer.style.cssText = 'display:flex;gap:10px;justify-content:center;';
          
          const refreshBtn = document.createElement('button');
          refreshBtn.textContent = 'üîÑ Refresh Page';
          refreshBtn.addEventListener('click', function() {
            location.reload();
          });
          
          const clearCacheBtn = document.createElement('button');
          clearCacheBtn.className = 'secondary';
          clearCacheBtn.textContent = 'üóëÔ∏è Clear & Reload';
          clearCacheBtn.addEventListener('click', function() {
            // Clear any cached data and reload with cache-busting parameter
            if ('caches' in window) {
              caches.keys().then(function(names) {
                names.forEach(function(name) {
                  caches.delete(name);
                });
              });
            }
            // Add timestamp to force fresh load
            window.location.href = window.location.pathname + '?t=' + Date.now();
          });
          
          buttonContainer.appendChild(refreshBtn);
          buttonContainer.appendChild(clearCacheBtn);
          
          errorDiv.appendChild(icon);
          errorDiv.appendChild(title);
          errorDiv.appendChild(description);
          errorDiv.appendChild(tryText);
          errorDiv.appendChild(suggestions);
          errorDiv.appendChild(buttonContainer);
          
          document.body.insertBefore(errorDiv, document.body.firstChild);
          return;
        }
        
        if (ethersLoadAttempts % 20 === 0) {
          console.log('Waiting for ethers library to load... (attempt ' + ethersLoadAttempts + '/' + maxEthersLoadAttempts + ')');
        }
        setTimeout(initializeApp, POLL_INTERVAL_MS);
        return;
      }
      
      // Hide loading indicator on success (using cached reference from above)
      if (loadingIndicator) {
        loadingIndicator.style.display = 'none';
      }
      
      console.log('‚úÖ Ethers library loaded successfully - Wallet connections enabled');
      startApp();
      
      // Try to auto-reconnect wallet after a brief delay (allowing startApp to initialize)
      setTimeout(async () => {
        const reconnected = await autoReconnectWallet();
        if (reconnected) {
          console.log('‚úÖ Wallet auto-reconnected successfully');
        }
      }, AUTO_RECONNECT_DELAY_MS);
    }
    
    // Helper function to show wallet confirmation dialog with gas estimation
    async function requestWalletConfirmation(action, details = {}) {
      if (!userAddress || !provider) {
        showNotification("‚ö†Ô∏è Please connect wallet first!", true);
        return false;
      }
      
      try {
        // Get current gas price from network
        const gasPrice = await provider.getGasPrice();
        const gasPriceGwei = parseFloat(ethers.utils.formatUnits(gasPrice, 'gwei'));
        
        // Estimate gas fee in ETH (approximate) - use DEFAULT if not specified
        const estimatedGasLimit = details.gasLimit || GAS_LIMITS.DEFAULT;
        const gasFeeWei = gasPrice.mul(estimatedGasLimit);
        const gasFeeEth = parseFloat(ethers.utils.formatEther(gasFeeWei));
        
        // Show confirmation dialog
        const message = `
          <div style="text-align: left; line-height: 1.6;">
            <strong>Transaction Confirmation</strong><br><br>
            <strong>Action:</strong> ${action}<br>
            ${details.amount ? `<strong>Amount:</strong> ${details.amount}<br>` : ''}
            ${details.from ? `<strong>From:</strong> ${details.from}<br>` : ''}
            ${details.to ? `<strong>To:</strong> ${details.to}<br>` : ''}
            <br>
            <strong>‚õΩ Estimated Gas Fee:</strong><br>
            ${gasFeeEth.toFixed(6)} ETH (~$${(gasFeeEth * ETH_TO_USDC_RATE).toFixed(2)})<br>
            <small style="color: #94a3b8;">${gasPriceGwei.toFixed(2)} Gwei | Note: ETH price approximation</small>
          </div>
        `;
        
        // Create confirmation modal
        return new Promise((resolve) => {
          const modal = document.createElement('div');
          modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 10000;';
          
          const content = document.createElement('div');
          content.style.cssText = 'background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); padding: 30px; border-radius: 16px; max-width: 450px; width: 90%; border: 1px solid #334155; box-shadow: 0 10px 40px rgba(0,0,0,0.5);';
          
          content.innerHTML = message;
          
          const buttonContainer = document.createElement('div');
          buttonContainer.style.cssText = 'display: flex; gap: 12px; margin-top: 24px;';
          
          const confirmBtn = document.createElement('button');
          confirmBtn.textContent = '‚úÖ Confirm';
          confirmBtn.style.cssText = 'flex: 1; padding: 14px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;';
          confirmBtn.onmouseover = () => confirmBtn.style.transform = 'scale(1.02)';
          confirmBtn.onmouseout = () => confirmBtn.style.transform = 'scale(1)';
          confirmBtn.onclick = () => {
            modal.remove();
            resolve(true);
          };
          
          const cancelBtn = document.createElement('button');
          cancelBtn.textContent = '‚ùå Cancel';
          cancelBtn.style.cssText = 'flex: 1; padding: 14px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;';
          cancelBtn.onmouseover = () => cancelBtn.style.transform = 'scale(1.02)';
          cancelBtn.onmouseout = () => cancelBtn.style.transform = 'scale(1)';
          cancelBtn.onclick = () => {
            modal.remove();
            resolve(false);
          };
          
          buttonContainer.appendChild(confirmBtn);
          buttonContainer.appendChild(cancelBtn);
          content.appendChild(buttonContainer);
          modal.appendChild(content);
          document.body.appendChild(modal);
        });
      } catch (error) {
        console.error('Error getting gas estimation:', error);
        showNotification('‚ö†Ô∏è Error estimating gas fee: ' + error.message, true);
        return false;
      }
    }
    window.requestWalletConfirmation = requestWalletConfirmation;
    
    function startApp() {
    // Note: SEPOLIA constants, provider, and userAddress are now in global scope
    // WalletConnect v1 has been removed due to deprecation
    
    // Note: connectWallet, connectMetaMask, connectOKX, and connectTrustWallet are now in global scope
    
    // Fetch real token balances from Sepolia
    // Helper function to reset all balance displays
    function resetBalanceDisplay() {
      // Configuration object for balance elements with their default values
      const balanceElements = [
        { id: null, selector: '.profile-slide-total', value: 'Connect Wallet' },
        { id: 'ethBalance', value: '0.0000' },
        { id: 'usdcBalance', value: '0.0000' },
        { id: 'usdcBalanceUSD', value: '$0.00' },
        { id: 'usdtBalance', value: '0.0000' },
        { id: 'usdtBalanceUSD', value: '$0.00' },
        { id: 'ghoBalance', value: '0.0000' },
        { id: 'ghoBalanceUSD', value: '$0.00' },
        { id: 'wbtcBalance', value: '0.0000' },
        { id: 'wbtcBalanceUSD', value: '$0.00' }
      ];
      
      balanceElements.forEach(item => {
        const el = item.id ? document.getElementById(item.id) : document.querySelector(item.selector);
        if (el) el.textContent = item.value;
      });
    }
    
    async function fetchRealBalances() {
      if (!userAddress || !provider) {
        // Not connected - reset all balances
        resetBalanceDisplay();
        return;
      }
      
      try {
        // Show loading notification
        showNotification("üîÑ Updating balances...", false);
        
        // Update asset explorer links when wallet is connected
        updateAssetLinks();
        
        // Fetch live ETH/USDC rate from Uniswap in the background
        fetchLiveETHtoUSDCRate().catch(err => console.log('[Uniswap] Rate fetch error:', err));
        
        // Fetch ETH balance
        const ethBalanceWei = await provider.getBalance(userAddress);
        const ethBalance = parseFloat(ethers.utils.formatEther(ethBalanceWei));
        
        // Fetch USDC balance
        const usdcContract = new ethers.Contract(USDC_SEPOLIA_ADDRESS, ERC20_ABI, provider);
        const usdcBalanceRaw = await usdcContract.balanceOf(userAddress);
        const usdcBalance = parseFloat(ethers.utils.formatUnits(usdcBalanceRaw, 6)); // USDC has 6 decimals
        
        // Fetch USDT balance
        const usdtContract = new ethers.Contract(USDT_SEPOLIA_ADDRESS, ERC20_ABI, provider);
        const usdtBalanceRaw = await usdtContract.balanceOf(userAddress);
        const usdtBalance = parseFloat(ethers.utils.formatUnits(usdtBalanceRaw, 6)); // USDT has 6 decimals
        
        // Fetch GHO balance
        const ghoContract = new ethers.Contract(GHO_SEPOLIA_ADDRESS, ERC20_ABI, provider);
        const ghoBalanceRaw = await ghoContract.balanceOf(userAddress);
        const ghoBalance = parseFloat(ethers.utils.formatUnits(ghoBalanceRaw, 18)); // GHO has 18 decimals
        
        // Fetch WBTC balance
        const wbtcContract = new ethers.Contract(WBTC_SEPOLIA_ADDRESS, ERC20_ABI, provider);
        const wbtcBalanceRaw = await wbtcContract.balanceOf(userAddress);
        const wbtcBalance = parseFloat(ethers.utils.formatUnits(wbtcBalanceRaw, 8)); // WBTC has 8 decimals
        
        // Fetch all token balances from Etherscan API
        await fetchAllTokenBalancesFromEtherscan();
        
        // Update UI with real balances
        const ethBalanceEl = document.getElementById('ethBalance');
        if (ethBalanceEl) ethBalanceEl.textContent = ethBalance.toFixed(4);
        
        const profileTotal = document.querySelector('.profile-slide-total');
        if (profileTotal) profileTotal.textContent = `${ethBalance.toFixed(4)} ETH`;
        
        // Update USDC display using IDs
        const usdcBalanceEl = document.getElementById('usdcBalance');
        if (usdcBalanceEl) usdcBalanceEl.textContent = usdcBalance.toFixed(4);
        
        const usdcBalanceUSDEl = document.getElementById('usdcBalanceUSD');
        if (usdcBalanceUSDEl) usdcBalanceUSDEl.textContent = `$${usdcBalance.toFixed(2)}`;
        
        // Update USDT display using IDs
        const usdtBalanceEl = document.getElementById('usdtBalance');
        if (usdtBalanceEl) usdtBalanceEl.textContent = usdtBalance.toFixed(4);
        
        const usdtBalanceUSDEl = document.getElementById('usdtBalanceUSD');
        if (usdtBalanceUSDEl) usdtBalanceUSDEl.textContent = `$${usdtBalance.toFixed(2)}`;
        
        // Update GHO display using IDs
        const ghoBalanceEl = document.getElementById('ghoBalance');
        if (ghoBalanceEl) ghoBalanceEl.textContent = ghoBalance.toFixed(4);
        
        const ghoBalanceUSDEl = document.getElementById('ghoBalanceUSD');
        if (ghoBalanceUSDEl) ghoBalanceUSDEl.textContent = `$${ghoBalance.toFixed(2)}`; // GHO is a stablecoin ~$1
        
        // Update WBTC display using IDs
        const wbtcBalanceEl = document.getElementById('wbtcBalance');
        if (wbtcBalanceEl) wbtcBalanceEl.textContent = wbtcBalance.toFixed(8);
        
        const wbtcBalanceUSDEl = document.getElementById('wbtcBalanceUSD');
        // Fetch BTC price from CoinGecko for WBTC USD value with CORS fallback
        try {
          const btcPriceData = await fetchWithCORSFallback('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
          if (btcPriceData && btcPriceData.bitcoin?.usd) {
            const wbtcPriceUSD = btcPriceData.bitcoin.usd;
            if (wbtcBalanceUSDEl) wbtcBalanceUSDEl.textContent = `$${(wbtcBalance * wbtcPriceUSD).toFixed(2)}`;
          } else {
            // Fallback to approximate price if API fails
            const wbtcPriceUSD = 45000;
            if (wbtcBalanceUSDEl) wbtcBalanceUSDEl.textContent = `$${(wbtcBalance * wbtcPriceUSD).toFixed(2)}`;
          }
        } catch (error) {
          console.log('BTC price fetch error, using fallback:', error);
          const wbtcPriceUSD = 45000; // Fallback to approximate price
          if (wbtcBalanceUSDEl) wbtcBalanceUSDEl.textContent = `$${(wbtcBalance * wbtcPriceUSD).toFixed(2)}`;
        }
        
        // Update trading balance in Market section if it exists
        if (typeof tradingUSDCBalance !== 'undefined') {
          tradingUSDCBalance = usdcBalance;
          if (typeof updateTradingBalance === 'function') {
            updateTradingBalance();
          }
        }
        
        console.log(`‚úÖ Balances updated: ETH=${ethBalance}, USDC=${usdcBalance}, USDT=${usdtBalance}, GHO=${ghoBalance}, WBTC=${wbtcBalance}`);
      } catch (error) {
        console.error('Error fetching balances:', error);
        showNotification("‚ö†Ô∏è Failed to fetch balances: " + (error.message || "Unknown error"), true);
      }
    }

    // Fetch all token balances from Etherscan API
    async function fetchAllTokenBalancesFromEtherscan() {
      if (!userAddress) return;
      
      try {
        const apiKey = ''; // Free tier: 5 calls/second, 100k calls/day
        // Sign up at: https://etherscan.io/apis
        const apiBase = getExplorerApiUrl();
        if (!apiBase) return; // unsupported network - skip
        const url = `${apiBase}?module=account&action=tokentx&address=${userAddress}&startblock=0&endblock=99999999&page=1&offset=100&sort=desc&apikey=${apiKey}`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        if (data.status === '1' && data.result && data.result.length > 0) {
          console.log(`[Etherscan] Found ${data.result.length} token transactions for ${userAddress}`);
          
          // Extract unique tokens from transactions
          const uniqueTokens = new Set();
          data.result.forEach(tx => {
            if (tx.contractAddress && tx.tokenSymbol) {
              uniqueTokens.add(JSON.stringify({
                address: tx.contractAddress,
                symbol: tx.tokenSymbol,
                name: tx.tokenName,
                decimals: parseInt(tx.tokenDecimal)
              }));
            }
          });
          
          console.log(`[Etherscan] Detected ${uniqueTokens.size} unique tokens in wallet`);
        }
      } catch (error) {
        console.log('[Etherscan] Token balance fetch error:', error);
      }
    }

    // Render local transaction history in the activity panel
    async function fetchTransactionHistory() {
      const activityContainer = document.getElementById('activityList');
      if (!activityContainer) return;

      if (!userAddress) {
        activityContainer.innerHTML = `
          <div style="padding:40px 20px; text-align:center; color:#94a3b8;">
            <div style="font-size:2.8em;margin-bottom:12px;">üîå</div>
            <div style="margin-bottom:16px;">Connect your wallet to view activity</div>
            <button onclick="connectWalletFromApp()" style="background:linear-gradient(135deg,#3b82f6,#2563eb);color:white;padding:12px 24px;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;">Connect Wallet</button>
          </div>`;
        return;
      }

      loadTxHistory();

      if (txHistory.length === 0) {
        const net = getActiveNetwork();
        activityContainer.innerHTML = `
          <div style="padding:40px 20px; text-align:center; color:#94a3b8;">
            <div style="font-size:2.8em;margin-bottom:12px;">üì≠</div>
            <div style="margin-bottom:8px;">No transactions recorded yet</div>
            <div style="font-size:0.85em;margin-bottom:16px;opacity:0.7;">Transactions will appear here after you swap, stake, learn, or trade.</div>
            <a href="${getActiveNetwork().explorer}/address/${userAddress}" target="_blank"
               style="background:linear-gradient(135deg,#3b82f6,#2563eb);color:white;padding:10px 20px;border-radius:8px;text-decoration:none;font-size:0.9em;display:inline-block;">
              View on ${getActiveNetwork().name} Explorer
            </a>
          </div>`;
        return;
      }

      // Network filter tabs
      const networks = ['all', 'sepolia', 'educhain', 'basesepolia'];
      const netLabels = { all: 'All', sepolia: 'üîµ Sepolia', educhain: 'üéì EDU', basesepolia: 'üî∑ Base' };
      let activeFilter = activityContainer.dataset.filter || 'all';

      function renderList(filter) {
        activityContainer.dataset.filter = filter;
        const filtered = filter === 'all' ? txHistory : txHistory.filter(t => t.networkId === filter);

        const typeIcons = {
          'Swap': 'üîÑ', 'Bridge': 'üåâ', 'NFT Stake': 'üè¶', 'NFT Unstake': '‚Ü©Ô∏è', 'NFT Claim': 'üéÅ',
          'Learning': 'üéì', 'Market': 'üìà', 'Sports Bet': 'üèÜ', 'Send': '‚Üë', 'Gas Fee': '‚õΩ',
          'Treasury': 'üèõÔ∏è', 'NFT Mint': 'üé®', 'Stake': 'üîí', 'Unstake': 'üîì', 'Redeem': 'üí±', 'Default': 'üîó'
        };

        // Build a map of hash ‚Üí tx entry for safe lookup (hash is unique per blockchain)
        const txByHash = {};
        txHistory.forEach(t => { if (t.hash) txByHash[t.hash] = t; });

        let html = `
          <div id="txFilterBar" style="display:flex;gap:6px;padding:10px 10px 0;flex-wrap:wrap;">
            ${networks.map(n => `
              <button data-net="${n}"
                style="padding:5px 12px;border-radius:20px;border:1px solid ${n===filter?'#3b82f6':'#334155'};background:${n===filter?'#1e40af':'transparent'};color:${n===filter?'white':'#94a3b8'};cursor:pointer;font-size:0.8em;transition:all 0.2s;">
                ${netLabels[n]}
              </button>`).join('')}
          </div>
          <div id="txItemList" style="padding:0 0 10px;">`;

        if (filtered.length === 0) {
          html += `<div style="padding:30px;text-align:center;color:#64748b;font-size:0.9em;">No transactions for this network yet</div>`;
        } else {
          filtered.slice(0, MAX_TX_DISPLAY_ENTRIES).forEach(tx => {
            const icon = typeIcons[tx.type] || typeIcons['Default'];
            const date = new Date(tx.timestamp).toLocaleDateString('en-US', {month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'});
            const netBadgeColor = tx.networkId === 'sepolia' ? '#3b82f6' : tx.networkId === 'educhain' ? '#a78bfa' : '#34d399';
            // Use hex TX hash (sanitised: only hex chars) as the safe data attribute for lookup
            const safeHash = tx.hash ? tx.hash.replace(/[^0-9a-fA-Fx]/g, '') : '';
            html += `
              <div class="activity-item tx-row"
                   data-tx-hash="${safeHash}"
                   style="display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid rgba(255,255,255,0.06);cursor:pointer;transition:background 0.15s;">
                <div style="width:36px;height:36px;border-radius:50%;background:rgba(59,130,246,0.15);display:flex;align-items:center;justify-content:center;font-size:1.1em;flex-shrink:0;">${icon}</div>
                <div style="flex:1;min-width:0;">
                  <div style="font-weight:600;font-size:0.95em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${tx.type}</div>
                  <div style="font-size:0.78em;color:#94a3b8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${tx.description}</div>
                  <div style="margin-top:3px;">
                    <span style="font-size:0.7em;padding:2px 7px;border-radius:10px;background:${netBadgeColor}22;color:${netBadgeColor};border:1px solid ${netBadgeColor}44;">${tx.networkName}</span>
                  </div>
                </div>
                <div style="text-align:right;flex-shrink:0;">
                  <div style="font-size:0.8em;color:#94a3b8;">${date}</div>
                  <div style="font-size:0.75em;color:#60a5fa;font-family:monospace;">${tx.hash ? tx.hash.slice(0,8)+'...' : ''}</div>
                </div>
              </div>`;
          });
        }
        html += `</div>`;
        activityContainer.innerHTML = html;
        // Attach filter button click handlers
        activityContainer.querySelectorAll('#txFilterBar button[data-net]').forEach(btn => {
          btn.addEventListener('click', () => renderList(btn.dataset.net));
        });
        // Attach tx item click handlers using hash as unique key (no inline JSON)
        activityContainer.querySelectorAll('.tx-row[data-tx-hash]').forEach(el => {
          const hash = el.dataset.txHash;
          const found = txByHash[hash];
          if (found) el.addEventListener('click', () => window.showTxDetail(found));
        });
      }

      renderList(activeFilter);
    }

    window.showTxDetail = function(tx) {
      if (!tx || typeof tx !== 'object') return;
      const date = new Date(tx.timestamp).toLocaleString();
      const explorerTxUrl = `${tx.networkExplorer}/tx/${tx.hash}`;
      const explorerFromUrl = `${tx.networkExplorer}/address/${tx.from}`;
      const explorerToUrl = tx.to ? `${tx.networkExplorer}/address/${tx.to}` : null;
      const netBadgeColor = tx.networkId === 'sepolia' ? '#3b82f6' : tx.networkId === 'educhain' ? '#a78bfa' : '#34d399';

      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:20000;padding:16px;';
      modal.innerHTML = `
        <div style="background:#1e293b;border-radius:20px;padding:28px;max-width:480px;width:100%;border:1px solid #334155;box-shadow:0 20px 60px rgba(0,0,0,0.7);max-height:90vh;overflow-y:auto;">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
            <h3 style="color:#60a5fa;font-size:1.2em;">Transaction Detail</h3>
            <button id="closeTxModal" style="background:none;border:none;color:#94a3b8;font-size:1.5em;cursor:pointer;line-height:1;">√ó</button>
          </div>
          
          <div style="background:rgba(59,130,246,0.08);border-radius:12px;padding:16px;margin-bottom:16px;text-align:center;">
            <div style="font-size:2em;margin-bottom:8px;">‚úÖ</div>
            <div style="font-weight:700;font-size:1.1em;color:white;">${tx.type}</div>
            <div style="color:#94a3b8;font-size:0.9em;margin-top:4px;">${tx.description}</div>
            <div style="margin-top:8px;"><span style="font-size:0.78em;padding:3px 10px;border-radius:12px;background:${netBadgeColor}22;color:${netBadgeColor};border:1px solid ${netBadgeColor}44;">${tx.networkName}</span></div>
          </div>
          
          <div style="display:flex;flex-direction:column;gap:10px;font-size:0.9em;">
            <div style="display:flex;justify-content:space-between;padding:10px;background:#0f172a;border-radius:8px;gap:8px;">
              <span style="color:#94a3b8;flex-shrink:0;">TX Hash</span>
              <div style="display:flex;align-items:center;gap:6px;min-width:0;">
                <span style="font-family:monospace;color:#60a5fa;font-size:0.85em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${tx.hash ? tx.hash.slice(0,18)+'...' : 'N/A'}</span>
                ${tx.hash ? `<button id="txCopyHashBtn" data-copy-hash style="background:none;border:1px solid #334155;color:#94a3b8;padding:2px 6px;border-radius:4px;cursor:pointer;font-size:0.75em;flex-shrink:0;">Copy</button>` : ''}
              </div>
            </div>
            <div style="display:flex;justify-content:space-between;padding:10px;background:#0f172a;border-radius:8px;">
              <span style="color:#94a3b8;">Status</span>
              <span style="color:#10b981;font-weight:600;">‚úÖ Confirmed</span>
            </div>
            <div style="display:flex;justify-content:space-between;padding:10px;background:#0f172a;border-radius:8px;">
              <span style="color:#94a3b8;">Timestamp</span>
              <span style="color:white;font-size:0.85em;">${date}</span>
            </div>
            ${tx.amount ? `<div style="display:flex;justify-content:space-between;padding:10px;background:#0f172a;border-radius:8px;">
              <span style="color:#94a3b8;">Amount</span>
              <span style="color:white;font-weight:600;">${tx.amount} ${tx.token || ''}</span>
            </div>` : ''}
            <div style="display:flex;justify-content:space-between;padding:10px;background:#0f172a;border-radius:8px;gap:8px;">
              <span style="color:#94a3b8;flex-shrink:0;">From</span>
              <span style="font-family:monospace;color:#60a5fa;font-size:0.82em;overflow:hidden;text-overflow:ellipsis;">${tx.from ? tx.from.slice(0,10)+'...'+tx.from.slice(-8) : 'N/A'}</span>
            </div>
            ${tx.to ? `<div style="display:flex;justify-content:space-between;padding:10px;background:#0f172a;border-radius:8px;gap:8px;">
              <span style="color:#94a3b8;flex-shrink:0;">To</span>
              <span style="font-family:monospace;color:#60a5fa;font-size:0.82em;overflow:hidden;text-overflow:ellipsis;">${tx.to.slice(0,10)+'...'+tx.to.slice(-8)}</span>
            </div>` : ''}
            <div style="display:flex;justify-content:space-between;padding:10px;background:#0f172a;border-radius:8px;">
              <span style="color:#94a3b8;">Network</span>
              <span style="color:white;">${tx.networkName}</span>
            </div>
          </div>
          
          ${tx.hash ? `<a href="${explorerTxUrl}" target="_blank" rel="noopener noreferrer"
             style="display:block;margin-top:16px;padding:12px;background:linear-gradient(135deg,#3b82f6,#2563eb);color:white;text-align:center;border-radius:10px;text-decoration:none;font-weight:600;font-size:0.95em;">
            üîç View on ${tx.networkName} Explorer
          </a>` : ''}
        </div>`;
      document.body.appendChild(modal);
      document.getElementById('closeTxModal').addEventListener('click', () => modal.remove());
      modal.addEventListener('click', e => { if (e.target === modal) modal.remove(); });
      // Attach copy button handler safely (avoids inline onclick with hash interpolation)
      const copyBtn = modal.querySelector('#txCopyHashBtn');
      if (copyBtn && tx.hash) {
        copyBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          navigator.clipboard.writeText(tx.hash).then(() => {
            copyBtn.textContent = '‚úì Copied';
            setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
          }).catch(() => {});
        });
      }
    };

    // Profile panel functions
    window.showProfile = function() {
      document.getElementById('profileSlidePanel').classList.remove('hidden');
      // Refresh data when profile is opened
      if (userAddress && provider) {
        fetchRealBalances();
        fetchTransactionHistory();
      } else {
        // Not connected - ensure "Connect Wallet" is shown
        fetchRealBalances(); // This will handle the not-connected state
      }
    }

    window.closeProfileSlide = function() {
      document.getElementById('profileSlidePanel').classList.add('hidden');
    }

    window.openBackProfile = function() {
      document.getElementById('backProfilePanel').classList.remove('hidden');
      closeProfileSlide();
      loadOCID();
    }

    window.closeBackProfile = function() {
      document.getElementById('backProfilePanel').classList.add('hidden');
    }

    function logoutUser() {
      // Clear wallet connection and persistence
      userAddress = null;
      provider = null;
      walletConnected = false;
      clearWalletConnection();
      
      // Clear social connections status
      localStorage.removeItem('socialConnections');
      localStorage.removeItem('lastSection');
      
      showNotification("‚úÖ Logged out successfully", false);
      
      // Hide main app and show login page
      document.getElementById('mainApp').classList.add('hidden');
      document.getElementById('loginPage').classList.remove('hidden');
      
      // Close profile panels
      closeBackProfile();
      closeProfileSlide();
      
      // Reset wallet button
      const walletBtn = document.getElementById('walletBtn');
      if (walletBtn) {
        walletBtn.textContent = 'Connect Wallet';
        walletBtn.classList.remove('connected');
      }
      
      // Hide wallet dropdown
      const dropdown = document.getElementById('walletDropdown');
      if (dropdown) {
        dropdown.classList.remove('show');
      }
      
      // Reset all balances
      resetBalanceDisplay();
      
      console.log('[Logout] User logged out, returned to login screen');
    }
    window.logoutUser = logoutUser;

    // Wallet dropdown functions
    window.toggleWalletDropdown = function() {
      const dropdown = document.getElementById('walletDropdown');
      if (!dropdown) return;
      
      // If not connected, show wallet options instead
      if (!userAddress) {
        showWalletOptions();
        return;
      }
      
      // Update address display
      const addressDisplay = document.getElementById('walletAddressDisplay');
      if (addressDisplay && userAddress) {
        addressDisplay.textContent = userAddress;
      }
      
      dropdown.classList.toggle('show');
    }

    window.copyWalletAddress = function() {
      if (!userAddress) return;
      
      navigator.clipboard.writeText(userAddress).then(() => {
        showNotification('Address copied to clipboard!', false);
      }).catch(() => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = userAddress;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Address copied to clipboard!', false);
      });
    }

    window.viewOnExplorer = function() {
      if (!userAddress) return;
      
      const net = getActiveNetwork();
      const explorerUrl = `${net.explorer}/address/${userAddress}`;
      window.open(explorerUrl, '_blank');
      showNotification(`Opening ${net.name} Explorer...`, false);
    }

    // ‚îÄ‚îÄ Network Switcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    window.switchNetwork = async function(networkId) {
      if (!NETWORKS[networkId]) return;
      const net = NETWORKS[networkId];

      // Update UI immediately
      currentNetworkId = networkId;
      localStorage.setItem('currentNetworkId', networkId);
      updateNetworkSwitcherUI();

      // If a wallet is connected, attempt to switch the wallet to this network
      if (provider && userAddress) {
        const rawProvider = provider.provider || window.ethereum || window.okxwallet;
        if (rawProvider && rawProvider.request) {
          try {
            await rawProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: net.chainHex }] });
            showNotification(`‚úÖ Switched to ${net.name}`, false);
          } catch (switchError) {
            if (switchError.code === 4902) {
              try {
                await rawProvider.request({
                  method: 'wallet_addEthereumChain',
                  params: [{
                    chainId: net.chainHex,
                    chainName: net.name,
                    nativeCurrency: { name: net.currency, symbol: net.currency, decimals: 18 },
                    rpcUrls: net.rpcUrls,
                    blockExplorerUrls: [net.explorer]
                  }]
                });
                showNotification(`‚úÖ Added and switched to ${net.name}`, false);
              } catch (addError) {
                showNotification(`Could not add ${net.name}: ${addError.message}`, true);
              }
            } else {
              showNotification(`‚ö†Ô∏è Could not auto-switch: ${switchError.message}`, true);
            }
          }
          // Delay to allow the provider to settle after chain switch before re-fetching balances
          if (typeof fetchRealBalances === 'function') setTimeout(() => fetchRealBalances(), BALANCE_REFRESH_DELAY_MS);
        }
      } else {
        showNotification(`üåê Network set to ${net.name}. Connect your wallet to use it.`, false);
      }

      // Refresh asset explorer links
      updateAssetLinks();
    };

    function updateNetworkSwitcherUI() {
      Object.keys(NETWORKS).forEach(id => {
        // Main app switcher
        const btn = document.getElementById(`netBtn_${id}`);
        if (btn) btn.classList.toggle('active', id === currentNetworkId);
        // Login page switcher
        const loginBtn = document.getElementById(`loginNetBtn_${id}`);
        if (loginBtn) loginBtn.classList.toggle('active', id === currentNetworkId);
      });
      // Update ETH asset subtitle in profile panel
      const net = getActiveNetwork();
      const ethSubtitle = document.getElementById('ethNetworkSubtitle');
      if (ethSubtitle) ethSubtitle.textContent = `${net.name} ‚Ä¢ View on Explorer ‚Üí`;
      // Update faucet link on login page
      const faucetLink = document.getElementById('faucetLink');
      if (faucetLink) {
        faucetLink.href = net.faucet;
        faucetLink.textContent = `${net.name} Faucet`;
      }
    }

    window.selectLoginNetwork = function(networkId) {
      if (!NETWORKS[networkId]) return;
      currentNetworkId = networkId;
      localStorage.setItem('currentNetworkId', networkId);
      updateNetworkSwitcherUI();
      const net = getActiveNetwork();
      showNotification(`üåê Network set to ${net.name}`, false);
    };

    // ‚îÄ‚îÄ OCID (Open Campus ID) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function loadOCID() {
      const ocid = localStorage.getItem('mogaland_ocid') || '';
      const input = document.getElementById('ocidInput');
      const badge = document.getElementById('ocidBadge');
      if (input) input.value = ocid;
      if (badge) {
        if (ocid) {
          badge.textContent = `‚úÖ OCID: ${ocid.slice(0,8)}...${ocid.slice(-4)}`;
          badge.className = 'ocid-badge verified';
        } else {
          badge.textContent = 'No OCID connected';
          badge.className = 'ocid-badge';
        }
      }
    }

    window.saveOCID = function() {
      const input = document.getElementById('ocidInput');
      if (!input) return;
      const value = input.value.trim();
      // Basic validation: allow empty (to clear), Ethereum address, or numeric ID (max 20 digits)
      if (value && !/^(0x[0-9a-fA-F]{40}|\d{1,20})$/.test(value)) {
        showNotification('‚ö†Ô∏è Please enter a valid OCID (Ethereum address or numeric ID)', true);
        return;
      }
      localStorage.setItem('mogaland_ocid', value);
      loadOCID();
      showNotification(value ? '‚úÖ OCID saved successfully!' : '‚úÖ OCID cleared', false);
    };

    window.disconnectWallet = function() {
      if (confirm('Are you sure you want to disconnect your wallet?')) {
        // Clear wallet connection
        userAddress = null;
        provider = null;
        walletConnected = false;
        
        // Clear saved connection from localStorage
        clearWalletConnection();
        
        // Update UI
        const walletBtn = document.getElementById('walletBtn');
        if (walletBtn) {
          walletBtn.textContent = 'Connect Wallet';
          walletBtn.classList.remove('connected');
        }
        
        // Reset all balance displays using helper function
        resetBalanceDisplay();
        
        // Hide dropdown
        const dropdown = document.getElementById('walletDropdown');
        if (dropdown) {
          dropdown.classList.remove('show');
        }
        
        showNotification('Wallet disconnected', false);
      }
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
      const dropdown = document.getElementById('walletDropdown');
      const walletBtn = document.getElementById('walletBtn');
      
      if (dropdown && walletBtn) {
        if (!dropdown.contains(event.target) && !walletBtn.contains(event.target)) {
          dropdown.classList.remove('show');
        }
      }
    });


    window.openDepositModal = function() {
      if (!userAddress) {
        showNotification("Please connect wallet first", true);
        return;
      }
      
      // Create deposit modal with QR code
      const modal = document.createElement('div');
      modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';
      modal.innerHTML = `
        <div style="background: var(--card-bg); padding: 32px; border-radius: 16px; max-width: 400px; text-align: center; border: 1px solid var(--border);">
          <h3 style="color: #60a5fa; margin-bottom: 16px;">Deposit to Your Wallet</h3>
          <p style="color: #94a3b8; margin-bottom: 8px;">Send ETH, USDC, or USDT to your address:</p>
          <p style="color: #f59e0b; font-size: 0.85em; margin-bottom: 16px;">üí° Deposits are managed by treasury</p>
          <div style="background: white; padding: 16px; border-radius: 12px; margin: 16px 0;">
            <div id="depositQR"></div>
          </div>
          <div style="background: rgba(13,110,253,0.1); padding: 12px; border-radius: 8px; word-break: break-all; font-family: monospace; font-size: 0.9em; color: #60a5fa; margin-bottom: 16px;">
            ${userAddress}
          </div>
          <button onclick="copyToClipboard('${userAddress}')" style="background: var(--primary); color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; margin-right: 8px;">
            üìã Copy Address
          </button>
          <button onclick="this.parentElement.parentElement.remove()" style="background: var(--danger); color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer;">
            Close
          </button>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Generate QR code using external service
      // Note: This sends the address to qrserver.com for QR generation
      // Consider using a client-side library for better privacy in production
      const qrDiv = document.getElementById('depositQR');
      // Clear any existing QR codes
      while (qrDiv.firstChild) {
        qrDiv.removeChild(qrDiv.firstChild);
      }
      const qrImg = document.createElement('img');
      qrImg.src = 'https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=' + encodeURIComponent(userAddress);
      qrImg.alt = 'QR Code';
      qrImg.style.cssText = 'width: 200px; height: 200px;';
      qrDiv.appendChild(qrImg);
      
      console.log('[Treasury] Deposit modal opened - deposits will be processed through treasury');
    }

    window.copyToClipboard = function(text) {
      navigator.clipboard.writeText(text).then(() => {
        showNotification('Address copied to clipboard!', false);
      }).catch(() => {
        showNotification('Failed to copy address', true);
      });
    }

    window.openSwapModal = function() {
      showNotification("Opening Swap interface...", false);
      closeProfileSlide();
      showSection('swap');
    }

    window.openSendModal = function() {
      if (!userAddress) {
        showNotification("Please connect wallet first", true);
        return;
      }
      
      // Create send modal
      const modal = document.createElement('div');
      modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';
      modal.innerHTML = `
        <div style="background: var(--card-bg); padding: 32px; border-radius: 16px; max-width: 500px; width: 90%; border: 1px solid var(--border);">
          <h3 style="color: #60a5fa; margin-bottom: 20px;">Send Crypto</h3>
          
          <div style="margin-bottom: 16px;">
            <label style="display: block; color: #94a3b8; margin-bottom: 8px;">Token</label>
            <select id="sendToken" style="width: 100%; padding: 12px; background: var(--darker); border: 1px solid var(--border); border-radius: 8px; color: white; font-size: 1em;">
              <option value="ETH">ETH (Sepolia)</option>
              <option value="USDC">USDC (Sepolia)</option>
              <option value="USDT">USDT (Sepolia)</option>
              <option value="LINK">LINK (Sepolia)</option>
              <option value="WBTC">WBTC (Sepolia)</option>
              <option value="AAVE">AAVE (Sepolia)</option>
              <option value="EURO">EURO (Sepolia)</option>
            </select>
          </div>
          
          <div style="margin-bottom: 16px;">
            <label style="display: block; color: #94a3b8; margin-bottom: 8px;">Recipient Address</label>
            <input type="text" id="sendAddress" placeholder="0x..." style="width: 100%; padding: 12px; background: var(--darker); border: 1px solid var(--border); border-radius: 8px; color: white; font-size: 1em;">
          </div>
          
          <div style="margin-bottom: 20px;">
            <label style="display: block; color: #94a3b8; margin-bottom: 8px;">Amount</label>
            <input type="number" id="sendAmount" placeholder="0.0" step="0.001" min="0" style="width: 100%; padding: 12px; background: var(--darker); border: 1px solid var(--border); border-radius: 8px; color: white; font-size: 1em;">
          </div>
          
          <div style="display: flex; gap: 12px;">
            <button onclick="executeSend()" style="flex: 1; background: var(--primary); color: white; padding: 14px; border: none; border-radius: 8px; cursor: pointer; font-size: 1.1em;">
              Send
            </button>
            <button onclick="this.parentElement.parentElement.parentElement.remove()" style="flex: 1; background: var(--danger); color: white; padding: 14px; border: none; border-radius: 8px; cursor: pointer; font-size: 1.1em;">
              Cancel
            </button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }

    async function executeSend() {
      const token = document.getElementById('sendToken').value;
      const toAddress = document.getElementById('sendAddress').value;
      const amount = document.getElementById('sendAmount').value;
      
      if (!toAddress || !amount || parseFloat(amount) <= 0) {
        showNotification('Please enter valid address and amount', true);
        return;
      }
      
      if (!ethers.utils.isAddress(toAddress)) {
        showNotification('Invalid Ethereum address', true);
        return;
      }
      
      // Block sending to treasury address
      if (toAddress.toLowerCase() === TREASURY_WALLET_ADDRESS.toLowerCase()) {
        showNotification('‚ùå Cannot send to treasury address! Use "Contribute to Treasury" button instead.', true);
        return;
      }
      
      try {
        if (!provider || !userAddress) {
          throw new Error('Wallet not connected');
        }
        
        const signer = provider.getSigner();
        const amountFloat = parseFloat(amount);
        
        showNotification(`üí∏ Preparing to send ${amountFloat} ${token}...`, false);
        
        if (token === 'ETH') {
          // Send ETH
          const amountWei = ethers.utils.parseEther(amountFloat.toString());
          
          const tx = await signer.sendTransaction({
            to: toAddress,
            value: amountWei,
            gasLimit: 21000
          });
          
          showNotification(`üîÑ Transaction sent! Waiting for confirmation...`, false);
          console.log('[Send] Transaction hash:', tx.hash);
          
          const receipt = await tx.wait();
          console.log('[Send] Transaction confirmed!', receipt);
          
          recordTransaction(tx.hash, 'Send', `Sent ${amountFloat} ${getNetworkCurrency()} to ${toAddress.slice(0,8)}...`, {amount: amountFloat, token: getNetworkCurrency(), to: toAddress});
          showNotification(
            `‚úÖ Sent ${amountFloat} ETH to ${toAddress.slice(0,6)}...${toAddress.slice(-4)}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
            false
          );
        } else {
          // Send ERC20 token
          const getTokenAddress = (token) => {
            const addresses = {
              'USDC': USDC_SEPOLIA,
              'USDT': USDT_SEPOLIA,
              'LINK': LINK_SEPOLIA,
              'WBTC': WBTC_SEPOLIA,
              'AAVE': AAVE_SEPOLIA
            };
            return addresses[token];
          };
          
          const tokenAddress = getTokenAddress(token);
          if (!tokenAddress) {
            throw new Error(`Unsupported token: ${token}`);
          }
          
          const decimals = token === 'WBTC' ? 8 : (token === 'USDC' || token === 'USDT' ? 6 : 18);
          const amountInUnits = ethers.utils.parseUnits(amountFloat.toString(), decimals);
          
          const tokenContract = new ethers.Contract(tokenAddress, [
            "function transfer(address to, uint256 amount) external returns (bool)"
          ], signer);
          
          const tx = await tokenContract.transfer(toAddress, amountInUnits, {
            gasLimit: 100000
          });
          
          showNotification(`üîÑ Transaction sent! Waiting for confirmation...`, false);
          console.log('[Send] Transaction hash:', tx.hash);
          
          const receipt = await tx.wait();
          console.log('[Send] Transaction confirmed!', receipt);
          
          recordTransaction(tx.hash, 'Send', `Sent ${amountFloat} ${token} to ${toAddress.slice(0,8)}...`, {amount: amountFloat, token: token, to: toAddress});
          showNotification(
            `‚úÖ Sent ${amountFloat} ${token} to ${toAddress.slice(0,6)}...${toAddress.slice(-4)}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
            false
          );
        }
        
        // Close modal and refresh balances
        const modal = document.querySelector('[style*="position: fixed"]');
        if (modal) modal.remove();
        
        setTimeout(() => {
          fetchAndDisplayBalances();
        }, 2000);
        
      } catch (error) {
        console.error('[Send] Error:', error);
        showNotification('‚ùå Transaction failed: ' + error.message, true);
      }
    }
    window.executeSend = executeSend;

    // Contribute USDC to Treasury
    window.openContributeToTreasury = function() {
      if (!userAddress) {
        showNotification("‚ö†Ô∏è Please connect wallet first", true);
        return;
      }
      
      // Fetch user's USDC balance
      let userUSDCBalance = 0;
      if (provider) {
        const usdcContract = new ethers.Contract(USDC_SEPOLIA_ADDRESS, ERC20_ABI, provider);
        usdcContract.balanceOf(userAddress).then(balance => {
          userUSDCBalance = parseFloat(ethers.utils.formatUnits(balance, 6));
          document.getElementById('userUSDCBalanceDisplay').textContent = userUSDCBalance.toFixed(2);
        }).catch(err => {
          console.error('Error fetching USDC balance:', err);
        });
      }
      
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
          <h2 style="text-align: center; margin-bottom: 20px;">üè¶ Contribute to Treasury</h2>
          
          <div style="background: linear-gradient(135deg, rgba(16,185,129,0.1), rgba(59,130,246,0.1)); 
                      padding: 20px; border-radius: 12px; margin-bottom: 20px; text-align: center;">
            <div style="font-size: 0.9em; color: #94a3b8; margin-bottom: 8px;">Your USDC Balance (Sepolia)</div>
            <div style="font-size: 2em; font-weight: bold; color: #10b981;" id="userUSDCBalanceDisplay">
              ${tradingUSDCBalance.toFixed(2)}
            </div>
            <div style="font-size: 0.85em; color: #60a5fa; margin-top: 5px;">USDC</div>
          </div>

          <div style="margin-bottom: 20px; padding: 15px; background: rgba(59,130,246,0.1); 
                      border-radius: 8px; border-left: 4px solid #3b82f6;">
            <div style="font-weight: bold; color: #60a5fa; margin-bottom: 8px;">üìù About Treasury Contributions</div>
            <div style="font-size: 0.85em; color: #94a3b8; line-height: 1.5;">
              ‚Ä¢ Contribute USDC from your Sepolia wallet to the treasury<br>
              ‚Ä¢ This is a REAL on-chain transfer to Sepolia testnet<br>
              ‚Ä¢ Your contribution will increase the treasury's USDC balance<br>
              ‚Ä¢ Treasury manages all platform liquidity and rewards<br>
              ‚Ä¢ Treasury Owner: ${TREASURY_WALLET_ADDRESS.slice(0,10)}...${TREASURY_WALLET_ADDRESS.slice(-8)}<br>
              ‚Ä¢ <a href="${getActiveNetwork().explorer}/address/${TREASURY_WALLET_ADDRESS}" target="_blank" style="color: #10b981;">View Treasury on Explorer</a>
            </div>
          </div>

          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; color: #94a3b8;">Amount to Contribute (USDC):</label>
            <input type="number" id="contributeAmount" placeholder="0.0" step="0.01" min="0"
                   style="width: 100%; padding: 12px; background: var(--card-bg); 
                          border: 1px solid var(--border); border-radius: 8px; color: white; font-size: 1.1em;">
            <div style="margin-top: 8px; display: flex; gap: 8px;">
              <button onclick="document.getElementById('contributeAmount').value = (${tradingUSDCBalance} * 0.25).toFixed(2)"
                      style="flex: 1; background: rgba(59,130,246,0.2); color: #60a5fa; 
                             padding: 8px; border: 1px solid #3b82f6; border-radius: 6px; cursor: pointer; font-size: 0.9em;">
                25%
              </button>
              <button onclick="document.getElementById('contributeAmount').value = (${tradingUSDCBalance} * 0.5).toFixed(2)"
                      style="flex: 1; background: rgba(59,130,246,0.2); color: #60a5fa; 
                             padding: 8px; border: 1px solid #3b82f6; border-radius: 6px; cursor: pointer; font-size: 0.9em;">
                50%
              </button>
              <button onclick="document.getElementById('contributeAmount').value = (${tradingUSDCBalance} * 0.75).toFixed(2)"
                      style="flex: 1; background: rgba(59,130,246,0.2); color: #60a5fa; 
                             padding: 8px; border: 1px solid #3b82f6; border-radius: 6px; cursor: pointer; font-size: 0.9em;">
                75%
              </button>
              <button onclick="document.getElementById('contributeAmount').value = ${tradingUSDCBalance.toFixed(2)}"
                      style="flex: 1; background: rgba(16,185,129,0.2); color: #10b981; 
                             padding: 8px; border: 1px solid #10b981; border-radius: 6px; cursor: pointer; font-size: 0.9em;">
                MAX
              </button>
            </div>
          </div>

          <button onclick="executeContributeToTreasury()" 
                  style="width: 100%; background: linear-gradient(135deg, #10b981, #059669); 
                         color: white; padding: 15px; border: none; border-radius: 8px; 
                         cursor: pointer; font-size: 1.1em; font-weight: bold;">
            ‚úÖ Confirm Contribution
          </button>

          <div style="margin-top: 15px; padding: 12px; background: rgba(234,179,8,0.1); 
                      border-radius: 8px; text-align: center; font-size: 0.85em; color: #eab308;">
            ‚ö†Ô∏è Gas fee: 0.01 USDC
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }

    window.executeContributeToTreasury = async function() {
      const amount = parseFloat(document.getElementById('contributeAmount').value);

      // Validation
      if (isNaN(amount) || amount <= 0) {
        showNotification('‚ùå Please enter a valid amount!', true);
        return;
      }

      if (!provider || !userAddress) {
        showNotification('‚ùå Please connect wallet first!', true);
        return;
      }

      try {
        showNotification(`üí∞ Preparing to contribute ${amount} USDC to treasury...`, false);
        
        const signer = provider.getSigner();
        const amountInUnits = ethers.utils.parseUnits(amount.toString(), 6); // USDC has 6 decimals
        
        // Check user's USDC balance
        const usdcContract = new ethers.Contract(USDC_SEPOLIA_ADDRESS, [
          "function balanceOf(address) view returns (uint256)",
          "function transfer(address to, uint256 amount) external returns (bool)"
        ], signer);
        
        const balance = await usdcContract.balanceOf(userAddress);
        const balanceFloat = parseFloat(ethers.utils.formatUnits(balance, 6));
        
        if (balanceFloat < amount) {
          showNotification(`‚ùå Insufficient USDC! You have ${balanceFloat.toFixed(2)} USDC`, true);
          return;
        }
        
        // Execute transfer to treasury
        const tx = await usdcContract.transfer(TREASURY_WALLET_ADDRESS, amountInUnits, {
          gasLimit: 100000
        });
        
        showNotification(`üîÑ Transaction sent! Waiting for confirmation...`, false);
        console.log('[Treasury] Contribution transaction hash:', tx.hash);
        
        const receipt = await tx.wait();
        console.log('[Treasury] Transaction confirmed!', receipt);
        
        recordTransaction(tx.hash, 'Treasury', `Contributed ${amount} USDC to treasury`, {amount: amount, token: 'USDC', to: TREASURY_WALLET_ADDRESS});
        showNotification(
          `‚úÖ Successfully contributed ${amount} USDC to treasury!<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
          false
        );
        
        // Close modal
        document.querySelectorAll('.modal').forEach(m => m.remove());
        
        // Refresh balances
        setTimeout(() => {
          fetchAndDisplayBalances();
          fetchTreasuryBalances();
        }, 2000);

      } catch (error) {
        console.error('[Treasury] Contribution error:', error);
        showNotification('‚ùå Contribution failed: ' + error.message, true);
      }
    }

    // === FIXED PROFILE TABS ===
    function initProfileTabs() {
      document.querySelectorAll('.profile-slide-tab').forEach(button => {
        button.addEventListener('click', () => {
          const tabName = button.dataset.tab;

          // Update tab buttons
          document.querySelectorAll('.profile-slide-tab').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabName);
          });

          // Update content panels
          document.getElementById('assetsContent').classList.toggle('active', tabName === 'assets');
          document.getElementById('activityContent').classList.toggle('active', tabName === 'activity');
          
          // Fetch transaction history when activity tab is opened
          if (tabName === 'activity') {
            fetchTransactionHistory();
          }
          
          // Update asset links when assets tab is opened
          if (tabName === 'assets') {
            updateAssetLinks();
          }
        });
      });
    }
    
    // Function to update asset links dynamically
    function updateAssetLinks() {
      if (!userAddress) return;
      
      const net = getActiveNetwork();
      const explorer = net.explorer;

      // Update ETH link
      const ethLink = document.getElementById('ethExplorerLink');
      if (ethLink) {
        ethLink.href = `${explorer}/address/${userAddress}`;
      }
      
      // Update WBTC link (token address only meaningful on Sepolia)
      const wbtcLink = document.getElementById('wbtcExplorerLink');
      if (wbtcLink) {
        wbtcLink.href = currentNetworkId === 'sepolia'
          ? `${explorer}/token/${WBTC_SEPOLIA}?a=${userAddress}`
          : `${explorer}/address/${userAddress}`;
      }
      
      // Update USDC link
      const usdcLink = document.getElementById('usdcExplorerLink');
      if (usdcLink) {
        usdcLink.href = currentNetworkId === 'sepolia'
          ? `${explorer}/token/${USDC_SEPOLIA_ADDRESS}?a=${userAddress}`
          : `${explorer}/address/${userAddress}`;
      }
      
      // Update USDT link
      const usdtLink = document.getElementById('usdtExplorerLink');
      if (usdtLink) {
        usdtLink.href = currentNetworkId === 'sepolia'
          ? `${explorer}/token/${USDT_SEPOLIA_ADDRESS}?a=${userAddress}`
          : `${explorer}/address/${userAddress}`;
      }
    }

    // Social Media Connection Management
    const SOCIAL_OAUTH_URLS = {
      x: 'https://twitter.com/i/oauth2/authorize', // Twitter OAuth 2.0
      telegram: 'https://t.me/botfather', // Telegram bot linking
      discord: 'https://discord.com/api/oauth2/authorize', // Discord OAuth
      farcaster: 'https://warpcast.com/~/signin' // Farcaster auth
    };

    function loadSocialConnections() {
      const connections = JSON.parse(localStorage.getItem('socialConnections') || '{}');
      
      // Update wallet status
      if (userAddress) {
        document.getElementById('walletStatusText').textContent = `Wallet: ${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;
        document.getElementById('walletConnectBtn').style.display = 'none';
        document.getElementById('walletDisconnectBtn').style.display = 'inline-block';
      }
      
      // Update social connection states
      ['x', 'telegram', 'discord', 'farcaster'].forEach(platform => {
        if (connections[platform]) {
          const statusEl = document.getElementById(`${platform}StatusText`);
          const connectBtn = document.getElementById(`${platform}ConnectBtn`);
          const disconnectBtn = document.getElementById(`${platform}DisconnectBtn`);
          
          if (statusEl && connectBtn && disconnectBtn) {
            statusEl.textContent = connections[platform].displayText;
            connectBtn.style.display = 'none';
            disconnectBtn.style.display = 'inline-block';
          }
        }
      });
    }

    window.connectSocial = function(platform) {
      const platformNames = {
        x: 'Twitter/X',
        telegram: 'Telegram',
        discord: 'Discord',
        farcaster: 'Farcaster'
      };
      
      const platformName = platformNames[platform];
      
      // In a real implementation, this would initiate OAuth flow
      showNotification(`Opening ${platformName} authentication...`, false);
      
      // Simulate OAuth flow with a prompt
      setTimeout(() => {
        const username = prompt(`Enter your ${platformName} username to connect (demo):`);
        if (username) {
          const connections = JSON.parse(localStorage.getItem('socialConnections') || '{}');
          connections[platform] = {
            username: username,
            displayText: `${platformName}: @${username}`,
            connectedAt: new Date().toISOString()
          };
          localStorage.setItem('socialConnections', JSON.stringify(connections));
          
          showNotification(`‚úÖ Connected to ${platformName} as @${username}`, false);
          loadSocialConnections();
        }
      }, 500);
    }

    window.disconnectSocial = function(platform) {
      const platformNames = {
        x: 'Twitter/X',
        telegram: 'Telegram',
        discord: 'Discord',
        farcaster: 'Farcaster'
      };
      
      if (confirm(`Disconnect from ${platformNames[platform]}?`)) {
        const connections = JSON.parse(localStorage.getItem('socialConnections') || '{}');
        delete connections[platform];
        localStorage.setItem('socialConnections', JSON.stringify(connections));
        
        // Reset UI
        const statusEl = document.getElementById(`${platform}StatusText`);
        const connectBtn = document.getElementById(`${platform}ConnectBtn`);
        const disconnectBtn = document.getElementById(`${platform}DisconnectBtn`);
        
        if (statusEl && connectBtn && disconnectBtn) {
          statusEl.textContent = `${platformNames[platform]} - Not Connected`;
          connectBtn.style.display = 'inline-block';
          disconnectBtn.style.display = 'none';
        }
        
        showNotification(`Disconnected from ${platformNames[platform]}`, false);
      }
    }

    function handleWalletConnect() {
      // Close back profile and connect wallet using modal
      closeBackProfile();
      if (!userAddress) {
        connectWalletFromApp();
      } else {
        showNotification('Wallet already connected!', false);
      }
    }
    window.handleWalletConnect = handleWalletConnect;

    function handleWalletDisconnect() {
      if (confirm('Disconnect your wallet?')) {
        logoutUser();
      }
    }
    window.handleWalletDisconnect = handleWalletDisconnect;

    // === MAIN SECTION SWITCHER ===
    let stakedUSDC = 0;
    let mogalandPoints = 0;
    let currentQuestionIndex = 0;
    let completedTasks = 0;
    let historyLog = [];
    let answerHistory = []; // Track answer history: {question, correct, pointChange, timestamp}
    let usdcBalance = "0.00";
    let nftMinted = false;

    // Treasury Wallet Configuration
    const TREASURY_WALLET_ADDRESS = "0xa959f26847211f71A22aDb087EBe50E0743e7D66";
    let treasuryUSDCBalance = 0; // Will be fetched from Sepolia
    let treasuryETHBalance = 0; // Will be fetched from Sepolia
    let tradingUSDCBalance = 0; // Will be populated with real wallet balance asynchronously
    
    // Helper function for consistent address truncation
    function formatAddress(address, startChars = 10, endChars = 8) {
      if (!address) return 'N/A';
      return `${address.slice(0, startChars)}...${address.slice(-endChars)}`;
    }

    // Fetch real treasury balances from Sepolia
    async function fetchTreasuryBalances() {
      if (!provider) {
        console.log('[Treasury] Provider not available, using demo balances');
        treasuryUSDCBalance = 1000000;
        treasuryETHBalance = 100;
        return;
      }

      try {
        // Fetch ETH balance
        const ethBalance = await provider.getBalance(TREASURY_WALLET_ADDRESS);
        treasuryETHBalance = parseFloat(ethers.utils.formatEther(ethBalance));
        
        // Fetch USDC balance
        const usdcContract = new ethers.Contract(USDC_SEPOLIA_ADDRESS, ERC20_ABI, provider);
        const usdcBalance = await usdcContract.balanceOf(TREASURY_WALLET_ADDRESS);
        treasuryUSDCBalance = parseFloat(ethers.utils.formatUnits(usdcBalance, 6));
        
        console.log(`[Treasury] Real Balances Fetched:`);
        console.log(`[Treasury] ETH: ${treasuryETHBalance.toFixed(4)} ETH`);
        console.log(`[Treasury] USDC: ${treasuryUSDCBalance.toFixed(2)} USDC`);
        
        updateTreasuryDisplay();
      } catch (error) {
        console.error('[Treasury] Error fetching balances:', error);
        // Fallback to demo balances on error
        treasuryUSDCBalance = 1000000;
        treasuryETHBalance = 100;
      }
    }
    window.fetchTreasuryBalances = fetchTreasuryBalances;

    function updateTreasuryDisplay() {
      // Update treasury displays if they exist
      const ethDisplay = document.getElementById('treasuryETHDisplay');
      const usdcDisplay = document.getElementById('treasuryUSDCDisplay');
      
      if (ethDisplay) {
        ethDisplay.textContent = treasuryETHBalance.toFixed(4);
      }
      if (usdcDisplay) {
        usdcDisplay.textContent = treasuryUSDCBalance.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
      }
    }
    
    // NFT Contract Configuration (Same as treasury for this implementation)
    const NFT_CONTRACT_ADDRESS = "0xa959f26847211f71A22aDb087EBe50E0743e7D66";
    const NFT_ABI = [
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function mint(address to) returns (uint256)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "function approve(address to, uint256 tokenId) external",
      "function setApprovalForAll(address operator, bool approved) external"
    ];
    
    // NFT Staking Contract (would be deployed separately in production)
    // For testnet purposes, we'll simulate staking through NFT approvals
    // TODO: Deploy actual staking contract and update this address
    const NFT_STAKING_CONTRACT = "0x0000000000000000000000000000000000000001"; // Placeholder for staking contract
    const NFT_STAKING_ABI = [
      "function stake(uint256[] tokenIds) external",
      "function unstake(uint256[] tokenIds) external",
      "function claimRewards() external",
      "function getStakedNFTs(address user) view returns (uint256[])",
      "function getPendingRewards(address user) view returns (uint256)"
    ];
    
    // Trading/Prediction Market Contract (simplified for testnet)
    // TODO: Deploy actual trading contract with proper position management and settlement
    // For now, positions are recorded on-chain via transactions to treasury wallet
    const TRADING_CONTRACT = "0x0000000000000000000000000000000000000002"; // Placeholder
    const TRADING_ABI = [
      "function openPosition(string asset, bool isLong, uint256 amount, uint256 leverage, uint256 entryPrice) external payable",
      "function closePosition(uint256 positionId) external",
      "function getPosition(uint256 positionId) view returns (tuple)",
      "function getUserPositions(address user) view returns (uint256[])"
    ];
    
    // ‚îÄ‚îÄ Transaction History Store (multi-network, persisted per user) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const MAX_TX_HISTORY_ENTRIES = 200; // Max entries stored in localStorage
    const MAX_TX_DISPLAY_ENTRIES = 50;  // Max entries shown at once in activity panel
    let txHistory = []; // Array of {hash, type, description, networkId, networkName, networkExplorer, amount, token, timestamp, from, to, status}

    function loadTxHistory() {
      if (!userAddress) return;
      try {
        const raw = localStorage.getItem(`txHistory_${userAddress}`);
        if (!raw) { txHistory = []; return; }
        const parsed = JSON.parse(raw);
        // Validate: must be an array of objects with at minimum a hash and timestamp
        if (!Array.isArray(parsed)) { txHistory = []; return; }
        txHistory = parsed.filter(t => t && typeof t === 'object' && typeof t.hash === 'string' && typeof t.timestamp === 'number');
      } catch(e) { console.error('[txHistory] Failed to parse stored history:', e); txHistory = []; }
    }

    function saveTxHistory() {
      if (!userAddress) return;
      try {
        if (txHistory.length > MAX_TX_HISTORY_ENTRIES) txHistory = txHistory.slice(0, MAX_TX_HISTORY_ENTRIES);
        localStorage.setItem(`txHistory_${userAddress}`, JSON.stringify(txHistory));
      } catch(e) {}
    }

    function recordTransaction(hash, type, description, details = {}) {
      if (!hash) return;
      const net = getActiveNetwork();
      const entry = {
        hash,
        type,
        description,
        networkId: net.id,
        networkName: net.name,
        networkExplorer: net.explorer,
        networkCurrency: net.currency,
        amount: details.amount || '',
        token: details.token || net.currency,
        from: details.from || userAddress || '',
        to: details.to || '',
        timestamp: Date.now(),
        status: 'confirmed'
      };
      txHistory.unshift(entry); // newest first
      saveTxHistory();
    }
    window.recordTransaction = recordTransaction;

    // Login method tracking - moved outside startApp() to global scope
    let socialConnected = false;
    
    const ERC20_ABI = [
      "function balanceOf(address owner) view returns (uint256)",
      "function transfer(address to, uint256 amount) returns (bool)",
      "function approve(address spender, uint256 amount) returns (bool)",
      "function decimals() view returns (uint8)",
      "function symbol() view returns (string)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    const USDC_ABI = ERC20_ABI;

    // Chainlink Price Feed ABI
    const CHAINLINK_AGGREGATOR_V3_ABI = [
      "function latestRoundData() view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)",
      "function decimals() view returns (uint8)"
    ];

    // Chainlink Price Feed Addresses on Sepolia Testnet
    const CHAINLINK_PRICE_FEEDS = {
      'BTCUSD': '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43',  // BTC/USD
      'ETHUSD': '0x694AA1769357215DE4FAC081bf1f309aDC325306',  // ETH/USD
      'LINKUSD': '0xc59E3633BAAC79493d908e63626716e204A45EdF', // LINK/USD
      'USDCUSD': '0xA2F78ab2355fe2f984D808B5CeE7FD0A93D5270E', // USDC/USD
      'DAIUSD': '0x14866185B1962B63C3Ea9E03Bc1da838bab34C19',  // DAI/USD
      // Add more as needed
    };

    // Helper function to calculate dynamic price change threshold
    function calculatePriceChangeThreshold(currentPrice) {
      return currentPrice * PRICE_UPDATE_CONFIG.MIN_CHANGE_THRESHOLD_RATIO;
    }

    // Function to fetch price from Chainlink
    async function fetchChainlinkPrice(symbol) {
      try {
        if (!provider) {
          console.log('[Chainlink] No provider available');
          return null;
        }

        const feedAddress = CHAINLINK_PRICE_FEEDS[symbol];
        if (!feedAddress) {
          console.log(`[Chainlink] No price feed available for ${symbol}`);
          return null;
        }

        const priceFeed = new ethers.Contract(feedAddress, CHAINLINK_AGGREGATOR_V3_ABI, provider);
        const [roundId, answer, , updatedAt, answeredInRound] = await priceFeed.latestRoundData();
        const decimals = await priceFeed.decimals();
        
        // Check if data is stale (older than configured threshold)
        const currentTime = Math.floor(Date.now() / 1000);
        const dataAge = currentTime - updatedAt;
        if (dataAge > PRICE_UPDATE_CONFIG.CHAINLINK_STALENESS_THRESHOLD_SECONDS) {
          console.log(`[Chainlink] Price data for ${symbol} is stale (${dataAge}s old)`);
          return null;
        }
        
        // Additional staleness check: if answeredInRound < roundId, 
        // the price feed has not been updated in the current round, indicating stale data
        if (answeredInRound < roundId) {
          console.log(`[Chainlink] Price data for ${symbol} may be stale (answeredInRound < roundId)`);
          return null;
        }
        
        // Convert answer to price with proper decimals
        const price = parseFloat(ethers.utils.formatUnits(answer, decimals));
        
        console.log(`[Chainlink] ${symbol} price: $${price.toFixed(2)}`);
        return price;
      } catch (error) {
        console.log(`[Chainlink] Error fetching ${symbol} price:`, error.message);
        return null;
      }
    }

    // Function to check if Chainlink feed is available for asset
    function hasChainlinkFeed(symbol) {
      return symbol in CHAINLINK_PRICE_FEEDS;
    }

    const questions = [
      // Blockchain Basics (1-20)
      { question: "What is a blockchain?", options: ["A) A type of cryptocurrency", "B) A distributed ledger technology", "C) A mining hardware", "D) A wallet application"], correct: 1 },
      { question: "Who created Bitcoin?", options: ["A) Vitalik Buterin", "B) Satoshi Nakamoto", "C) Charlie Lee", "D) Gavin Wood"], correct: 1 },
      { question: "What is the first cryptocurrency?", options: ["A) Ethereum", "B) Litecoin", "C) Bitcoin", "D) Ripple"], correct: 2 },
      { question: "What does 'decentralized' mean in blockchain?", options: ["A) Controlled by one entity", "B) No central authority", "C) Faster transactions", "D) Lower fees"], correct: 1 },
      { question: "What is a block in blockchain?", options: ["A) A single transaction", "B) A group of transactions", "C) A mining reward", "D) A wallet address"], correct: 1 },
      { question: "What is consensus mechanism?", options: ["A) A way to agree on ledger state", "B) A type of wallet", "C) A mining pool", "D) A trading strategy"], correct: 0 },
      { question: "What is Proof of Work (PoW)?", options: ["A) A consensus algorithm", "B) A wallet type", "C) A token standard", "D) A smart contract"], correct: 0 },
      { question: "What is Proof of Stake (PoS)?", options: ["A) Mining algorithm", "B) Consensus requiring stake", "C) Wallet security", "D) Token distribution"], correct: 1 },
      { question: "What is a hash function in blockchain?", options: ["A) A trading tool", "B) A one-way cryptographic function", "C) A wallet generator", "D) A mining device"], correct: 1 },
      { question: "What is a Merkle tree?", options: ["A) A data structure for efficient verification", "B) A type of wallet", "C) A consensus mechanism", "D) A mining strategy"], correct: 0 },
      { question: "What is Byzantine Fault Tolerance?", options: ["A) A wallet type", "B) System resilience to failures", "C) A mining algorithm", "D) A token standard"], correct: 1 },
      { question: "What is a node in blockchain?", options: ["A) A mining machine", "B) A computer maintaining blockchain copy", "C) A wallet", "D) A transaction"], correct: 1 },
      { question: "What is immutability in blockchain?", options: ["A) Fast transactions", "B) Cannot be altered once recorded", "C) Low fees", "D) Privacy feature"], correct: 1 },
      { question: "What is a genesis block?", options: ["A) Latest block", "B) First block in blockchain", "C) Largest block", "D) Failed block"], correct: 1 },
      { question: "What is mining in cryptocurrency?", options: ["A) Buying coins", "B) Validating transactions and creating blocks", "C) Trading coins", "D) Storing coins"], correct: 1 },
      { question: "What is a mining pool?", options: ["A) Solo mining", "B) Group of miners combining resources", "C) A wallet", "D) A blockchain"], correct: 1 },
      { question: "What is block time?", options: ["A) Transaction fee", "B) Time to create a new block", "C) Mining difficulty", "D) Confirmation time"], correct: 1 },
      { question: "What is blockchain fork?", options: ["A) A bug", "B) Split in blockchain", "C) A wallet", "D) A token"], correct: 1 },
      { question: "What is a hard fork?", options: ["A) Backward compatible change", "B) Non-backward compatible protocol change", "C) A wallet update", "D) A bug fix"], correct: 1 },
      { question: "What is a soft fork?", options: ["A) Non-compatible change", "B) Backward compatible protocol upgrade", "C) A new blockchain", "D) A token swap"], correct: 1 },
      
      // Ethereum & Smart Contracts (21-40)
      { question: "Who founded Ethereum?", options: ["A) Satoshi Nakamoto", "B) Vitalik Buterin", "C) Charles Hoskinson", "D) Joseph Lubin"], correct: 1 },
      { question: "What is a smart contract?", options: ["A) A legal document", "B) Self-executing code on blockchain", "C) A wallet", "D) A mining algorithm"], correct: 1 },
      { question: "What language is used for Ethereum smart contracts?", options: ["A) JavaScript", "B) Python", "C) Solidity", "D) C++"], correct: 2 },
      { question: "What is gas in Ethereum?", options: ["A) A token", "B) Unit measuring computational effort", "C) A wallet", "D) A protocol"], correct: 1 },
      { question: "What is EVM?", options: ["A) Ethereum Virtual Machine", "B) Extra Value Mining", "C) Electronic Voting Method", "D) Efficient Value Management"], correct: 0 },
      { question: "What is Ether (ETH)?", options: ["A) A smart contract", "B) Native cryptocurrency of Ethereum", "C) A wallet", "D) A consensus mechanism"], correct: 1 },
      { question: "What is Wei?", options: ["A) A blockchain", "B) Smallest unit of Ether", "C) A wallet", "D) A token standard"], correct: 1 },
      { question: "What is Gwei?", options: ["A) A token", "B) Unit equal to 10^9 Wei", "C) A wallet", "D) A protocol"], correct: 1 },
      { question: "What is ERC-20?", options: ["A) A wallet", "B) Token standard for fungible tokens", "C) A blockchain", "D) A consensus"], correct: 1 },
      { question: "What is ERC-721?", options: ["A) Fungible token standard", "B) NFT token standard", "C) A wallet", "D) A protocol"], correct: 1 },
      { question: "What is ERC-1155?", options: ["A) Fungible only", "B) Multi-token standard", "C) NFT only", "D) A wallet"], correct: 1 },
      { question: "What is a DApp?", options: ["A) Desktop Application", "B) Decentralized Application", "C) Data Application", "D) Digital Application"], correct: 1 },
      { question: "What is The Merge in Ethereum?", options: ["A) Token swap", "B) Transition from PoW to PoS", "C) A wallet", "D) A fork"], correct: 1 },
      { question: "What is Ethereum 2.0?", options: ["A) A new token", "B) Upgraded Ethereum with PoS", "C) A wallet", "D) A competitor"], correct: 1 },
      { question: "What is sharding in Ethereum?", options: ["A) Token splitting", "B) Splitting blockchain into smaller parts", "C) A wallet", "D) Mining technique"], correct: 1 },
      { question: "What is a rollup?", options: ["A) Token sale", "B) Layer 2 scaling solution", "C) A wallet", "D) A consensus"], correct: 1 },
      { question: "What is Optimistic Rollup?", options: ["A) A token", "B) Layer 2 assuming validity", "C) A wallet", "D) A blockchain"], correct: 1 },
      { question: "What is ZK-Rollup?", options: ["A) Token type", "B) Layer 2 with zero-knowledge proofs", "C) A wallet", "D) Mining method"], correct: 1 },
      { question: "What is Polygon?", options: ["A) A token", "B) Ethereum scaling solution", "C) A wallet", "D) A consensus"], correct: 1 },
      { question: "What is Arbitrum?", options: ["A) A token", "B) Optimistic rollup solution", "C) A wallet", "D) A blockchain"], correct: 1 },
      
      // DeFi (41-60)
      { question: "What does DeFi stand for?", options: ["A) Digital Finance", "B) Decentralized Finance", "C) Defined Finance", "D) Derivative Finance"], correct: 1 },
      { question: "What is a DEX?", options: ["A) Digital Exchange", "B) Decentralized Exchange", "C) Data Exchange", "D) Defined Exchange"], correct: 1 },
      { question: "What is Uniswap?", options: ["A) A wallet", "B) An automated market maker DEX", "C) A blockchain", "D) A token"], correct: 1 },
      { question: "What is an AMM?", options: ["A) Automated Money Manager", "B) Automated Market Maker", "C) Advanced Mining Method", "D) Asset Management Model"], correct: 1 },
      { question: "What is liquidity pool?", options: ["A) Mining pool", "B) Pool of tokens for trading", "C) Staking pool", "D) Wallet collection"], correct: 1 },
      { question: "What is yield farming?", options: ["A) Mining", "B) Earning rewards by providing liquidity", "C) Trading", "D) Staking only"], correct: 1 },
      { question: "What is staking?", options: ["A) Mining", "B) Locking tokens to support network", "C) Trading", "D) Buying tokens"], correct: 1 },
      { question: "What is APY?", options: ["A) Annual Price Yield", "B) Annual Percentage Yield", "C) Asset Price Year", "D) Average Profit Yearly"], correct: 1 },
      { question: "What is APR?", options: ["A) Annual Price Rate", "B) Annual Percentage Rate", "C) Asset Profit Rate", "D) Average Price Return"], correct: 1 },
      { question: "What is impermanent loss?", options: ["A) Permanent loss", "B) Temporary loss in liquidity providing", "C) Mining loss", "D) Fee loss"], correct: 1 },
      { question: "What is a lending protocol?", options: ["A) Mining protocol", "B) Platform for borrowing/lending crypto", "C) Trading platform", "D) Wallet service"], correct: 1 },
      { question: "What is Aave?", options: ["A) A token", "B) A DeFi lending protocol", "C) A wallet", "D) A blockchain"], correct: 1 },
      { question: "What is Compound?", options: ["A) A wallet", "B) A DeFi lending protocol", "C) A token only", "D) A blockchain"], correct: 1 },
      { question: "What is collateral in DeFi?", options: ["A) Trading fee", "B) Assets locked to secure loan", "C) Mining reward", "D) Staking reward"], correct: 1 },
      { question: "What is over-collateralization?", options: ["A) No collateral", "B) Collateral value exceeds loan", "C) Equal collateral", "D) Under collateral"], correct: 1 },
      { question: "What is liquidation?", options: ["A) Selling tokens", "B) Forced closure of under-collateralized position", "C) Mining process", "D) Staking reward"], correct: 1 },
      { question: "What is flash loan?", options: ["A) Long-term loan", "B) Uncollateralized loan repaid in same transaction", "C) Collateralized loan", "D) Personal loan"], correct: 1 },
      { question: "What is governance token?", options: ["A) Payment token", "B) Token for voting on protocol decisions", "C) Staking token only", "D) Meme coin"], correct: 1 },
      { question: "What is TVL?", options: ["A) Token Value Locked", "B) Total Value Locked", "C) Trading Volume Limit", "D) Total Verified Liquidity"], correct: 1 },
      { question: "What is slippage?", options: ["A) Trading fee", "B) Price difference between expected and executed", "C) Mining difficulty", "D) Staking reward"], correct: 1 },
      
      // NFTs & Gaming (61-80)
      { question: "What does NFT stand for?", options: ["A) New Financial Token", "B) Non-Fungible Token", "C) Network File Transfer", "D) Next Future Technology"], correct: 1 },
      { question: "What makes an NFT unique?", options: ["A) Price", "B) Each token is distinct and non-interchangeable", "C) Color", "D) Size"], correct: 1 },
      { question: "What is OpenSea?", options: ["A) A blockchain", "B) An NFT marketplace", "C) A wallet", "D) A token"], correct: 1 },
      { question: "What is minting an NFT?", options: ["A) Buying NFT", "B) Creating and recording NFT on blockchain", "C) Selling NFT", "D) Trading NFT"], correct: 1 },
      { question: "What is metadata in NFT?", options: ["A) Price data", "B) Information describing NFT properties", "C) Owner data", "D) Trading data"], correct: 1 },
      { question: "What is IPFS?", options: ["A) A token", "B) Decentralized storage system", "C) A blockchain", "D) A wallet"], correct: 1 },
      { question: "What is gas war?", options: ["A) Mining competition", "B) Users bidding high gas fees", "C) Trading battle", "D) Staking competition"], correct: 1 },
      { question: "What is rarity in NFTs?", options: ["A) Price", "B) How uncommon trait combinations are", "C) Age", "D) Size"], correct: 1 },
      { question: "What is a PFP NFT?", options: ["A) Payment NFT", "B) Profile Picture NFT", "C) Public NFT", "D) Private NFT"], correct: 1 },
      { question: "What is generative art NFT?", options: ["A) Hand-drawn art", "B) Art created by algorithm", "C) Photography", "D) Video art"], correct: 1 },
      { question: "What is Play-to-Earn (P2E)?", options: ["A) Gambling", "B) Gaming model where players earn crypto", "C) Mining", "D) Trading"], correct: 1 },
      { question: "What is GameFi?", options: ["A) Game Finance", "B) Combination of gaming and DeFi", "C) Gaming Platform", "D) Game Token"], correct: 1 },
      { question: "What is Axie Infinity?", options: ["A) A wallet", "B) A play-to-earn game", "C) A DEX", "D) A blockchain"], correct: 1 },
      { question: "What is metaverse?", options: ["A) A token", "B) Virtual shared space", "C) A blockchain", "D) A wallet"], correct: 1 },
      { question: "What is Decentraland?", options: ["A) A token", "B) A virtual world platform", "C) A wallet", "D) A DEX"], correct: 1 },
      { question: "What is The Sandbox?", options: ["A) A mining tool", "B) A virtual world and gaming platform", "C) A wallet", "D) A token"], correct: 1 },
      { question: "What is royalty in NFT?", options: ["A) Initial price", "B) Percentage paid to creator on resales", "C) Gas fee", "D) Trading fee"], correct: 1 },
      { question: "What is lazy minting?", options: ["A) Fast minting", "B) Minting only when NFT is sold", "C) Delayed minting", "D) Bulk minting"], correct: 1 },
      { question: "What is dynamic NFT?", options: ["A) Static image", "B) NFT that changes based on conditions", "C) Video NFT", "D) Audio NFT"], correct: 1 },
      { question: "What is fractional NFT?", options: ["A) Broken NFT", "B) NFT divided into multiple shares", "C) Small NFT", "D) Cheap NFT"], correct: 1 },
      
      // Security & Wallets (81-100)
      { question: "What is a private key?", options: ["A) Public address", "B) Secret key to access wallet", "C) Password", "D) Username"], correct: 1 },
      { question: "What is a public key?", options: ["A) Password", "B) Address to receive funds", "C) Private key", "D) Secret code"], correct: 1 },
      { question: "What is a seed phrase?", options: ["A) Password", "B) 12-24 words to recover wallet", "C) Username", "D) Email"], correct: 1 },
      { question: "What is a hardware wallet?", options: ["A) Software wallet", "B) Physical device storing keys offline", "C) Online wallet", "D) Exchange wallet"], correct: 1 },
      { question: "What is MetaMask?", options: ["A) A blockchain", "B) A browser extension wallet", "C) A DEX", "D) A token"], correct: 1 },
      { question: "What is cold storage?", options: ["A) Online wallet", "B) Offline storage of crypto", "C) Exchange wallet", "D) Hot wallet"], correct: 1 },
      { question: "What is hot wallet?", options: ["A) Offline wallet", "B) Wallet connected to internet", "C) Hardware wallet", "D) Paper wallet"], correct: 1 },
      { question: "What is 2FA?", options: ["A) Two Addresses", "B) Two-Factor Authentication", "C) Two Fees", "D) Two Forks"], correct: 1 },
      { question: "What is a rug pull?", options: ["A) Marketing strategy", "B) Scam where developers abandon project", "C) Token burn", "D) Airdrop"], correct: 1 },
      { question: "What is phishing in crypto?", options: ["A) Mining", "B) Tricking users to reveal private keys", "C) Trading", "D) Staking"], correct: 1 },
      { question: "What is a smart contract audit?", options: ["A) Price check", "B) Security review of contract code", "C) Marketing review", "D) User review"], correct: 1 },
      { question: "What is a honeypot scam?", options: ["A) Good investment", "B) Token you can buy but not sell", "C) Mining scam", "D) Wallet scam"], correct: 1 },
      { question: "What is KYC?", options: ["A) Keep Your Crypto", "B) Know Your Customer", "C) Key Your Code", "D) Keep Your Keys"], correct: 1 },
      { question: "What is AML?", options: ["A) Advanced Mining Logic", "B) Anti-Money Laundering", "C) Automated Market Listing", "D) Asset Management Layer"], correct: 1 },
      { question: "What is a multi-sig wallet?", options: ["A) Single signature", "B) Multiple signatures required", "C) Multiple addresses", "D) Multiple tokens"], correct: 1 },
      { question: "What is a paper wallet?", options: ["A) Digital wallet", "B) Keys printed on paper", "C) Hardware wallet", "D) Exchange wallet"], correct: 1 },
      { question: "What is address poisoning?", options: ["A) Good practice", "B) Scam using similar addresses", "C) Mining technique", "D) Trading strategy"], correct: 1 },
      { question: "What is sandwich attack?", options: ["A) Food-related", "B) MEV attack manipulating transactions", "C) Mining attack", "D) Wallet hack"], correct: 1 },
      { question: "What is front-running?", options: ["A) Fast trading", "B) Exploiting knowledge of pending transactions", "C) Mining first", "D) First buyer"], correct: 1 },
      { question: "What is a smart contract exploit?", options: ["A) Good feature", "B) Vulnerability allowing unauthorized actions", "C) Upgrade", "D) Optimization"], correct: 1 }
    ];

    let tokenTreasury = 100000;
    let plumeBalance = "0.00";
    let mogaBalance = 0;
    let currentSlippageTolerance = 0.5;

    let stakedNFTs = 0;
    let nftRewards = 0;
    let selectedNFTs = new Set();
    let userNFTs = []; // User's actual NFTs from wallet
    let mintedNFTs = []; // NFTs minted from learning
    let nftAPYs = {
      'Common': 5,
      'Rare': 10,
      'Epic': 15,
      'Legendary': 20
    };
    let stakedNFTsData = []; // [{nftId, apy, stakedTime, rewards}]
    let lastRewardClaim = Date.now();

    // Trading Volume Tracking for Leaderboard
    let userTradingVolume = {
      crypto: 0,
      stocks: 0,
      commodities: 0,
      forex: 0,
      sports: 0,
      total: 0 // Total volume in USDC
    };
    let volumeRewardsClaimable = 0; // Accumulated USDC rewards from trading volume
    let leaderboardData = []; // Global leaderboard data
    const VOLUME_TO_REWARD_RATE = 0.001; // 0.1% of trading volume converted to claimable USDC
    const LEARNING_POINTS_TO_USDC_RATE = 0.001; // 1 point = 0.001 USDC (1000 points = 1 USDC)

    function updateTradingVolume(category, volumeUSDC) {
      if (!userAddress) return;
      
      // Validate category
      const validCategories = ['crypto', 'stocks', 'commodities', 'forex', 'sports'];
      if (!validCategories.includes(category)) {
        console.warn(`[Volume] Invalid category: ${category}, defaulting to crypto`);
        category = 'crypto';
      }
      
      userTradingVolume[category] += volumeUSDC;
      userTradingVolume.total += volumeUSDC;
      
      // Convert volume to claimable rewards
      const rewardAmount = volumeUSDC * VOLUME_TO_REWARD_RATE;
      volumeRewardsClaimable += rewardAmount;
      
      // Save to localStorage
      saveUserTradingVolume();
      
      console.log(`[Volume] ${category}: +${volumeUSDC.toFixed(2)} USDC | Total: ${userTradingVolume.total.toFixed(2)} USDC | Claimable: ${volumeRewardsClaimable.toFixed(4)} USDC`);
    }

    function saveUserTradingVolume() {
      if (!userAddress) return;
      localStorage.setItem(`tradingVolume_${userAddress}`, JSON.stringify(userTradingVolume));
      localStorage.setItem(`volumeRewards_${userAddress}`, volumeRewardsClaimable.toString());
    }

    function loadUserTradingVolume() {
      if (!userAddress) return;
      
      const savedVolume = localStorage.getItem(`tradingVolume_${userAddress}`);
      if (savedVolume) {
        userTradingVolume = JSON.parse(savedVolume);
      }
      
      const savedRewards = localStorage.getItem(`volumeRewards_${userAddress}`);
      if (savedRewards) {
        const parsed = parseFloat(savedRewards);
        volumeRewardsClaimable = isNaN(parsed) ? 0 : parsed;
      }
      
      // Load learning points (using parseInt since points are always integers)
      const savedPoints = localStorage.getItem(`mogalandPoints_${userAddress}`);
      if (savedPoints) {
        const parsed = parseInt(savedPoints, 10);
        mogalandPoints = isNaN(parsed) ? 0 : parsed;
      }
      
      // Load staked NFTs data
      const savedStakedNFTs = localStorage.getItem(`stakedNFTs_${userAddress}`);
      if (savedStakedNFTs) {
        try {
          stakedNFTsData = JSON.parse(savedStakedNFTs);
        } catch (e) {
          console.error('[NFT] Error parsing staked NFTs data from localStorage:', e);
          stakedNFTsData = [];
        }
      }
    }
    
    // Helper function to save mogaland points to localStorage
    function saveMogalandPoints() {
      if (userAddress) {
        localStorage.setItem(`mogalandPoints_${userAddress}`, mogalandPoints);
      }
    }
    
    // Helper function to save staked NFTs data to localStorage
    function saveStakedNFTsData() {
      if (userAddress) {
        localStorage.setItem(`stakedNFTs_${userAddress}`, JSON.stringify(stakedNFTsData));
      }
    }

    function updateTreasuryDisplay() {
      const el = document.getElementById('treasuryDisplay');
      if (el) el.textContent = `${tokenTreasury.toLocaleString()} MOGA`;
      
      // Treasury USDC display is hidden from users (for dev only)
      // Treasury balance is tracked internally: ${treasuryUSDCBalance.toLocaleString()} USDC
    }
    
    // Process gas fee for actions (now uses ETH instead of USDC)
    async function processGasFee(action = 'action') {
      if (!userAddress || !provider) {
        showNotification('‚ö†Ô∏è Please connect wallet first!', true);
        return false;
      }
      
      try {
        // Check ETH balance for gas fee
        const ethBalanceWei = await provider.getBalance(userAddress);
        const ethBalance = parseFloat(ethers.utils.formatEther(ethBalanceWei));
        
        if (ethBalance < GAS_FEE_ETH) {
          showNotification(`‚õΩ Insufficient ${getNetworkCurrency()} balance for gas fee! Need ${GAS_FEE_ETH} ${getNetworkCurrency()}`, true);
          return false;
        }
        
        showNotification(`‚õΩ Sending gas fee transaction for ${action}...`, false);
        
        // Send real gas fee transaction to treasury
        const signer = provider.getSigner();
        const gasFeeWei = ethers.utils.parseEther(GAS_FEE_ETH.toString());
        
        console.log(`[Gas Fee] Sending ${GAS_FEE_ETH} ${getNetworkCurrency()} to treasury for ${action}`);
        const tx = await signer.sendTransaction({
          to: TREASURY_WALLET_ADDRESS,
          value: gasFeeWei,
          gasLimit: GAS_LIMITS.GAS_FEE_PAYMENT
        });
        
        console.log(`[Gas Fee] Transaction sent: ${tx.hash}`);
        showNotification(`‚õΩ Gas fee transaction sent! Waiting for confirmation...`, false);
        
        await tx.wait();
        console.log(`[Gas Fee] Transaction confirmed: ${tx.hash}`);
        
        recordTransaction(tx.hash, 'Gas Fee', `Gas fee for: ${action}`, {amount: GAS_FEE_ETH, token: getNetworkCurrency(), to: TREASURY_WALLET_ADDRESS});
        showNotification(
          `‚úÖ Gas fee paid: ${GAS_FEE_ETH} ${getNetworkCurrency()}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
          false
        );
        
        return true;
      } catch (error) {
        console.error('[Gas Fee] Error:', error);
        showNotification('‚ö†Ô∏è Error processing gas fee: ' + error.message, true);
        return false;
      }
    }
    
    // Transfer winnings from treasury to user
    function transferFromTreasury(amount) {
      if (treasuryUSDCBalance < amount) {
        showNotification(`‚ö†Ô∏è Treasury has insufficient funds! Available: ${treasuryUSDCBalance.toFixed(2)} USDC`, true);
        return false;
      }
      
      treasuryUSDCBalance -= amount;
      tradingUSDCBalance += amount;
      updateTreasuryDisplay();
      updateTradingBalance();
      
      return true;
    }
    
    // Transfer losses from user to treasury
    function transferToTreasury(amount) {
      treasuryUSDCBalance += amount;
      updateTreasuryDisplay();
      return true;
    }
    
    // Deposit via treasury - User deposits go through treasury
    function depositViaTreasury(token, amount) {
      console.log(`[Treasury] Deposit: ${amount} ${token} ‚Üí Treasury ‚Üí User balance`);
      treasuryUSDCBalance += amount;
      tradingUSDCBalance += amount;
      updateTreasuryDisplay();
      updateTradingBalance();
      showNotification(`‚úÖ Deposited ${amount} ${token} via treasury`, false);
      return true;
    }
    
    // Withdraw via treasury - User withdrawals go through treasury
    async function withdrawViaTreasury(token, amount, toAddress) {
      console.log(`[Treasury] Withdraw: User balance ‚Üí Treasury ‚Üí ${toAddress}`);
      
      if (tradingUSDCBalance < amount) {
        showNotification('Insufficient balance for withdrawal', true);
        return false;
      }
      
      // Deduct from user balance
      tradingUSDCBalance -= amount;
      
      // Treasury processes the withdrawal
      treasuryUSDCBalance -= amount;
      
      updateTreasuryDisplay();
      updateTradingBalance();
      
      showNotification(`‚úÖ Withdrawal of ${amount} ${token} processed via treasury`, false);
      console.log(`[Treasury] Withdrawal complete: ${amount} ${token} sent to ${toAddress}`);
      
      return true;
    }
    
    // Swap via treasury - All swaps go through treasury (LEGACY - for UI compatibility)
    function swapViaTreasury(fromToken, toToken, fromAmount, toAmount, slippage) {
      console.log(`[Treasury] Swap: ${fromAmount} ${fromToken} ‚Üí Treasury ‚Üí ${toAmount} ${toToken}`);
      
      // Treasury receives fromToken
      treasuryUSDCBalance += fromAmount;
      
      // Treasury gives toToken (with slippage applied)
      const finalAmount = toAmount * (1 - slippage / 100);
      treasuryUSDCBalance -= finalAmount;
      
      updateTreasuryDisplay();
      
      showNotification(`‚úÖ Swapped ${fromAmount} ${fromToken} for ${finalAmount.toFixed(6)} ${toToken} via treasury`, false);
      console.log(`[Treasury] Swap complete. Treasury now has net: ${treasuryUSDCBalance.toFixed(2)} USDC`);
      
      return finalAmount;
    }
    
    // Real Uniswap V3 swap function
    async function executeRealSwap(fromToken, toToken, fromAmount, slippage) {
      try {
        if (!provider || !userAddress) {
          throw new Error('Wallet not connected');
        }
        
        const signer = provider.getSigner();
        
        // Get token addresses
        const getTokenAddress = (token) => {
          const addresses = {
            'ETH': WETH9_SEPOLIA,
            'USDC': USDC_SEPOLIA,
            'USDT': USDT_SEPOLIA,
            'LINK': LINK_SEPOLIA,
            'WBTC': WBTC_SEPOLIA,
            'AAVE': AAVE_SEPOLIA,
            'EURO': EURO_SEPOLIA
          };
          return addresses[token];
        };
        
        const tokenInAddress = getTokenAddress(fromToken);
        const tokenOutAddress = getTokenAddress(toToken);
        
        if (!tokenInAddress || !tokenOutAddress) {
          throw new Error(`Unsupported token: ${fromToken} or ${toToken}`);
        }
        
        // Convert amount to wei (18 decimals for most tokens, 8 for WBTC)
        const decimals = fromToken === 'WBTC' ? 8 : (fromToken === 'USDC' || fromToken === 'USDT' ? 6 : 18);
        const amountIn = ethers.utils.parseUnits(fromAmount.toString(), decimals);
        
        // Get quote from Quoter
        const quoterContract = new ethers.Contract(UNISWAP_V3_QUOTER_V2, UNISWAP_V3_QUOTER_ABI, provider);
        const quoteParams = {
          tokenIn: tokenInAddress,
          tokenOut: tokenOutAddress,
          amountIn: amountIn,
          fee: 3000, // 0.3% fee tier
          sqrtPriceLimitX96: 0
        };
        
        console.log('[Swap] Getting quote from Uniswap V3...');
        const quoteResult = await quoterContract.callStatic.quoteExactInputSingle(quoteParams);
        const amountOut = quoteResult[0]; // First element is amountOut
        
        // Apply slippage tolerance: if slippage is 0.5%, multiply by (100 - 0.5) / 100 = 0.995
        const slippageBasisPoints = Math.floor(slippage * 100); // Convert 0.5% to 50 basis points
        const amountOutMin = amountOut.mul(10000 - slippageBasisPoints).div(10000);
        
        console.log(`[Swap] Quote: ${ethers.utils.formatUnits(amountOut, toToken === 'USDC' || toToken === 'USDT' ? 6 : 18)} ${toToken}`);
        console.log(`[Swap] Min amount after ${slippage}% slippage: ${ethers.utils.formatUnits(amountOutMin, toToken === 'USDC' || toToken === 'USDT' ? 6 : 18)} ${toToken}`);
        
        // For ETH swaps, we need to handle WETH wrapping
        if (fromToken === 'ETH') {
          // Swap ETH for token (ETH is automatically wrapped to WETH by the router)
          const routerContract = new ethers.Contract(UNISWAP_V3_ROUTER, UNISWAP_V3_ROUTER_ABI, signer);
          
          const swapParams = {
            tokenIn: tokenInAddress,
            tokenOut: tokenOutAddress,
            fee: 3000,
            recipient: userAddress,
            amountIn: amountIn,
            amountOutMinimum: amountOutMin,
            sqrtPriceLimitX96: 0
          };
          
          console.log('[Swap] Executing swap on Uniswap V3...');
          const tx = await routerContract.exactInputSingle(swapParams, {
            value: amountIn,
            gasLimit: 300000
          });
          
          showNotification(`üîÑ Swap transaction sent! Waiting for confirmation...`, false);
          console.log('[Swap] Transaction hash:', tx.hash);
          
          const receipt = await tx.wait();
          console.log('[Swap] Transaction confirmed!', receipt);
          
          return {
            success: true,
            amountOut: ethers.utils.formatUnits(amountOut, toToken === 'USDC' || toToken === 'USDT' ? 6 : 18),
            txHash: tx.hash
          };
        } else {
          // For ERC20 swaps, need to approve first
          const tokenContract = new ethers.Contract(tokenInAddress, [
            "function approve(address spender, uint256 amount) external returns (bool)",
            "function allowance(address owner, address spender) external view returns (uint256)"
          ], signer);
          
          // Check current allowance
          const currentAllowance = await tokenContract.allowance(userAddress, UNISWAP_V3_ROUTER);
          
          if (currentAllowance.lt(amountIn)) {
            console.log('[Swap] Approving token spend...');
            showNotification(`üìù Approving ${fromToken}... Please confirm in wallet`, false);
            
            const approveTx = await tokenContract.approve(UNISWAP_V3_ROUTER, amountIn);
            await approveTx.wait();
            
            console.log('[Swap] Token approved');
            showNotification(`‚úÖ ${fromToken} approved! Now executing swap...`, false);
          }
          
          const routerContract = new ethers.Contract(UNISWAP_V3_ROUTER, UNISWAP_V3_ROUTER_ABI, signer);
          
          const swapParams = {
            tokenIn: tokenInAddress,
            tokenOut: tokenOutAddress,
            fee: 3000,
            recipient: userAddress,
            amountIn: amountIn,
            amountOutMinimum: amountOutMin,
            sqrtPriceLimitX96: 0
          };
          
          console.log('[Swap] Executing swap on Uniswap V3...');
          const tx = await routerContract.exactInputSingle(swapParams, {
            gasLimit: 300000
          });
          
          showNotification(`üîÑ Swap transaction sent! Waiting for confirmation...`, false);
          console.log('[Swap] Transaction hash:', tx.hash);
          
          const receipt = await tx.wait();
          console.log('[Swap] Transaction confirmed!', receipt);
          
          return {
            success: true,
            amountOut: ethers.utils.formatUnits(amountOut, toToken === 'USDC' || toToken === 'USDT' ? 6 : 18),
            txHash: tx.hash
          };
        }
      } catch (error) {
        console.error('[Swap] Error:', error);
        throw error;
      }
    }
    
    // Bridge via treasury - Cross-chain transfers managed by treasury (LEGACY - for UI compatibility)
    function bridgeViaTreasury(fromChain, toChain, token, amount, slippage) {
      console.log(`[Treasury] Bridge: ${amount} ${token} from ${fromChain} ‚Üí Treasury ‚Üí ${toChain}`);
      
      // Treasury receives tokens from source chain
      treasuryUSDCBalance += amount;
      
      // Treasury sends tokens to destination chain (with slippage and bridge fee)
      const bridgeFee = amount * 0.001; // 0.1% bridge fee
      const finalAmount = (amount - bridgeFee) * (1 - slippage / 100);
      treasuryUSDCBalance -= finalAmount;
      
      updateTreasuryDisplay();
      
      showNotification(`‚úÖ Bridged ${amount} ${token} from ${fromChain} to ${toChain} via treasury (received: ${finalAmount.toFixed(6)})`, false);
      console.log(`[Treasury] Bridge complete. Fee collected: ${bridgeFee.toFixed(6)}. Treasury balance: ${treasuryUSDCBalance.toFixed(2)} USDC`);
      
      return finalAmount;
    }
    
    // Real bridge function - Simulates cross-chain bridge with actual testnet token transfer
    async function executeRealBridge(fromChain, toChain, token, amount, slippage) {
      try {
        if (!provider || !userAddress) {
          throw new Error('Wallet not connected');
        }
        
        const signer = provider.getSigner();
        
        // Get token address
        const getTokenAddress = (token) => {
          const addresses = {
            'ETH': null, // Native ETH
            'USDC': USDC_SEPOLIA,
            'USDT': USDT_SEPOLIA,
            'LINK': LINK_SEPOLIA,
            'WBTC': WBTC_SEPOLIA,
            'AAVE': AAVE_SEPOLIA
          };
          return addresses[token];
        };
        
        const tokenAddress = getTokenAddress(token);
        
        // Calculate bridge fee (0.1%)
        const bridgeFee = amount * 0.001;
        const amountAfterFee = amount - bridgeFee;
        const finalAmount = amountAfterFee * (1 - slippage / 100);
        
        console.log(`[Bridge] Bridging ${amount} ${token} from ${fromChain} to ${toChain}`);
        console.log(`[Bridge] Fee: ${bridgeFee.toFixed(6)} ${token}, Final amount: ${finalAmount.toFixed(6)} ${token}`);
        
        if (token === 'ETH') {
          // For ETH, send to treasury (simulating bridge locking)
          const amountWei = ethers.utils.parseEther(finalAmount.toString());
          
          showNotification(`üåâ Initiating bridge transaction...`, false);
          
          // In a real bridge, this would go through a bridge contract
          // For testnet simulation, we transfer to treasury to simulate locking
          const tx = await signer.sendTransaction({
            to: TREASURY_WALLET_ADDRESS, // Bridge contract would lock tokens here
            value: amountWei,
            gasLimit: 100000
          });
          
          showNotification(`üîÑ Bridge transaction sent! Waiting for confirmation...`, false);
          console.log('[Bridge] Transaction hash:', tx.hash);
          
          const receipt = await tx.wait();
          console.log('[Bridge] Transaction confirmed!', receipt);
          
          return {
            success: true,
            finalAmount: finalAmount,
            txHash: tx.hash,
            fromChain,
            toChain
          };
        } else {
          // For ERC20 tokens
          const decimals = token === 'WBTC' ? 8 : (token === 'USDC' || token === 'USDT' ? 6 : 18);
          const amountInUnits = ethers.utils.parseUnits(finalAmount.toString(), decimals);
          
          const tokenContract = new ethers.Contract(tokenAddress, [
            "function transfer(address to, uint256 amount) external returns (bool)"
          ], signer);
          
          showNotification(`üåâ Initiating bridge transaction for ${token}...`, false);
          
          // In real bridge, would transfer to bridge contract
          // For testnet, transfer to treasury (simulating bridge locking mechanism)
          const tx = await tokenContract.transfer(TREASURY_WALLET_ADDRESS, amountInUnits, {
            gasLimit: 100000
          });
          
          showNotification(`üîÑ Bridge transaction sent! Waiting for confirmation...`, false);
          console.log('[Bridge] Transaction hash:', tx.hash);
          
          const receipt = await tx.wait();
          console.log('[Bridge] Transaction confirmed!', receipt);
          
          return {
            success: true,
            finalAmount: finalAmount,
            txHash: tx.hash,
            fromChain,
            toChain
          };
        }
      } catch (error) {
        console.error('[Bridge] Error:', error);
        throw error;
      }
    }
    
    // Send via treasury - P2P transfers go through treasury
    async function sendViaTreasury(token, amount, toAddress) {
      console.log(`[Treasury] Send: User ‚Üí Treasury ‚Üí ${toAddress}`);
      
      // Validate all conditions before making any changes
      if (tradingUSDCBalance < amount) {
        showNotification(`Insufficient balance! Need ${amount.toFixed(2)} USDC`, true);
        return false;
      }
      
      // Check gas fee separately (ETH balance check in processGasFee)
      const gasPassed = await processGasFee('send');
      if (!gasPassed) {
        return false;
      }
      
      // All validations passed - now execute the transaction
      tradingUSDCBalance -= amount;
      
      // Treasury receives and forwards
      treasuryUSDCBalance += amount;
      treasuryUSDCBalance -= amount; // Sent to recipient
      
      updateTreasuryDisplay();
      updateTradingBalance();
      
      showNotification(`‚úÖ Sent ${amount} ${token} to ${toAddress.slice(0,6)}...${toAddress.slice(-4)} via treasury`, false);
      console.log(`[Treasury] Send complete to ${toAddress}`);
      
      return true;
    }

    // Treasury Management Functions
    async function openTreasuryManagement() {
      // Check if user is connected with treasury wallet
      if (userAddress && userAddress.toLowerCase() !== TREASURY_WALLET_ADDRESS.toLowerCase()) {
        showNotification('‚ö†Ô∏è Only treasury wallet owner can access this feature!', true);
        return;
      }
      
      if (!userAddress) {
        showNotification('‚ö†Ô∏è Please connect treasury wallet first!', true);
        return;
      }

      // Fetch real balances from Sepolia
      showNotification('üîÑ Fetching treasury balances from Sepolia...', false);
      await fetchTreasuryBalances();

      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
          <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
          <h2 style="text-align: center; margin-bottom: 20px;">üè¶ Treasury Management</h2>
          
          <div style="background: linear-gradient(135deg, rgba(16,185,129,0.1), rgba(59,130,246,0.1)); 
                      padding: 20px; border-radius: 12px; margin-bottom: 20px;">
            <div style="text-align: center; margin-bottom: 15px; color: #60a5fa; font-size: 0.9em;">
              Treasury Wallet (${getActiveNetwork().name}): ${TREASURY_WALLET_ADDRESS.slice(0,8)}...${TREASURY_WALLET_ADDRESS.slice(-6)}
              <br><a href="${getActiveNetwork().explorer}/address/${TREASURY_WALLET_ADDRESS}" target="_blank" 
                     style="color: #10b981; font-size: 0.85em;">View on Explorer</a>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; text-align: center;">
              <div>
                <div style="font-size: 0.9em; color: #94a3b8; margin-bottom: 5px;">ETH Balance</div>
                <div style="font-size: 1.5em; font-weight: bold; color: #10b981;" id="treasuryETHDisplay">${treasuryETHBalance.toFixed(4)}</div>
                <div style="font-size: 0.75em; color: #64748b; margin-top: 3px;">Real Balance</div>
              </div>
              <div>
                <div style="font-size: 0.9em; color: #94a3b8; margin-bottom: 5px;">USDC Balance</div>
                <div style="font-size: 1.5em; font-weight: bold; color: #60a5fa;" id="treasuryUSDCDisplay">${treasuryUSDCBalance.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                <div style="font-size: 0.75em; color: #64748b; margin-top: 3px;">Real Balance</div>
              </div>
              <div>
                <div style="font-size: 0.9em; color: #94a3b8; margin-bottom: 5px;">Exchange Rate</div>
                <div style="font-size: 1.2em; font-weight: bold; color: #f59e0b;">1 ETH = ${ETH_TO_USDC_RATE} USDC</div>
              </div>
            </div>
          </div>

          <div style="display: grid; gap: 15px;">
            <button onclick="openSendETHFromTreasury()" 
                    style="background: linear-gradient(135deg, #10b981, #059669); 
                           color: white; padding: 15px; border: none; border-radius: 8px; 
                           cursor: pointer; font-size: 1.1em; font-weight: bold;">
              üì§ Send ETH to Wallet
            </button>
            
            <button onclick="swapTreasuryETHtoUSDC()" 
                    style="background: linear-gradient(135deg, #3b82f6, #2563eb); 
                           color: white; padding: 15px; border: none; border-radius: 8px; 
                           cursor: pointer; font-size: 1.1em; font-weight: bold;">
              üí± Swap ETH to USDC
            </button>

            <button onclick="fetchTreasuryBalances(); setTimeout(() => openTreasuryManagement(), 500); document.querySelectorAll('.modal').forEach(m => m.remove());" 
                    style="background: rgba(59,130,246,0.2); border: 1px solid #3b82f6;
                           color: #60a5fa; padding: 12px; border-radius: 8px; 
                           cursor: pointer; font-size: 0.95em; font-weight: bold;">
              üîÑ Refresh Balances
            </button>
          </div>

          <div style="margin-top: 20px; padding: 15px; background: rgba(234,179,8,0.1); 
                      border-radius: 8px; border-left: 4px solid #eab308;">
            <div style="font-weight: bold; color: #eab308; margin-bottom: 8px;">‚ö†Ô∏è Treasury Operations</div>
            <div style="font-size: 0.85em; color: #94a3b8; line-height: 1.5;">
              ‚Ä¢ These are REAL balances from Sepolia testnet<br>
              ‚Ä¢ Send ETH: Transfer ETH from treasury to any wallet address<br>
              ‚Ä¢ Swap ETH to USDC: Convert treasury ETH to USDC at current rate<br>
              ‚Ä¢ All operations are logged and tracked<br>
              ‚Ä¢ Gas fees apply: 0.01 USDC per transaction
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }

    function openSendETHFromTreasury() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
          <h2 style="text-align: center; margin-bottom: 20px;">üì§ Send ETH from Treasury</h2>
          
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; color: #94a3b8;">Recipient Address:</label>
            <input type="text" id="treasuryRecipientAddress" placeholder="0x..." 
                   style="width: 100%; padding: 12px; background: var(--card-bg); 
                          border: 1px solid var(--border); border-radius: 8px; color: white;">
          </div>

          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; color: #94a3b8;">Amount (ETH):</label>
            <input type="number" id="treasuryETHAmount" placeholder="0.0" step="0.001" 
                   style="width: 100%; padding: 12px; background: var(--card-bg); 
                          border: 1px solid var(--border); border-radius: 8px; color: white;">
            <div style="margin-top: 8px; font-size: 0.85em; color: #94a3b8;">
              Available: ${treasuryETHBalance.toFixed(4)} ETH
            </div>
          </div>

          <button onclick="executeSendETHFromTreasury()" 
                  style="width: 100%; background: linear-gradient(135deg, #10b981, #059669); 
                         color: white; padding: 15px; border: none; border-radius: 8px; 
                         cursor: pointer; font-size: 1.1em; font-weight: bold;">
            ‚úÖ Confirm Send
          </button>
        </div>
      `;
      document.body.appendChild(modal);
    }
    window.openSendETHFromTreasury = openSendETHFromTreasury;

    async function executeSendETHFromTreasury() {
      const recipientAddress = document.getElementById('treasuryRecipientAddress').value.trim();
      const amount = parseFloat(document.getElementById('treasuryETHAmount').value);

      // Validation
      if (!recipientAddress || !recipientAddress.startsWith('0x') || recipientAddress.length !== 42) {
        showNotification('‚ùå Invalid recipient address!', true);
        return;
      }

      if (isNaN(amount) || amount <= 0) {
        showNotification('‚ùå Invalid amount!', true);
        return;
      }

      if (amount > treasuryETHBalance) {
        showNotification(`‚ùå Insufficient treasury ETH! Available: ${treasuryETHBalance.toFixed(4)} ETH`, true);
        return;
      }

      // Process gas fee
      if (!await processGasFee('treasury ETH transfer')) {
        return;
      }

      // Deduct ETH from treasury
      treasuryETHBalance -= amount;

      // In production, this would be a real blockchain transaction
      console.log(`[Treasury] Sending ${amount} ETH to ${recipientAddress}`);
      console.log(`[Treasury] New ETH balance: ${treasuryETHBalance.toFixed(4)} ETH`);

      // Close modals
      document.querySelectorAll('.modal').forEach(m => m.remove());

      showNotification(`‚úÖ Sent ${amount} ETH from treasury to ${recipientAddress.slice(0,6)}...${recipientAddress.slice(-4)}`, false);
      
      // Reopen treasury management to show updated balances
      setTimeout(() => openTreasuryManagement(), 500);
    }
    window.executeSendETHFromTreasury = executeSendETHFromTreasury;

    window.swapTreasuryETHtoUSDC = function() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <span class="close-modal" onclick="this.parentElement.parentElement.remove()">&times;</span>
          <h2 style="text-align: center; margin-bottom: 20px;">üí± Swap ETH to USDC</h2>
          
          <div style="margin-bottom: 20px; padding: 15px; background: rgba(59,130,246,0.1); 
                      border-radius: 8px; text-align: center;">
            <div style="font-size: 0.9em; color: #94a3b8; margin-bottom: 5px;">Exchange Rate</div>
            <div style="font-size: 1.5em; font-weight: bold; color: #60a5fa;">
              1 ETH = ${ETH_TO_USDC_RATE} USDC
            </div>
          </div>

          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; color: #94a3b8;">Amount to Swap (ETH):</label>
            <input type="number" id="treasurySwapAmount" placeholder="0.0" step="0.001" 
                   oninput="updateTreasurySwapPreview()"
                   style="width: 100%; padding: 12px; background: var(--card-bg); 
                          border: 1px solid var(--border); border-radius: 8px; color: white;">
            <div style="margin-top: 8px; font-size: 0.85em; color: #94a3b8;">
              Available: ${treasuryETHBalance.toFixed(4)} ETH
            </div>
          </div>

          <div id="swapPreview" style="margin-bottom: 20px; padding: 15px; 
                                       background: rgba(16,185,129,0.1); border-radius: 8px; 
                                       border-left: 4px solid #10b981;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <span style="color: #94a3b8;">You swap:</span>
              <span style="color: white; font-weight: bold;" id="swapETHAmount">0 ETH</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span style="color: #94a3b8;">You receive:</span>
              <span style="color: #10b981; font-weight: bold;" id="swapUSDCAmount">0 USDC</span>
            </div>
          </div>

          <button onclick="executeSwapTreasuryETHtoUSDC()" 
                  style="width: 100%; background: linear-gradient(135deg, #3b82f6, #2563eb); 
                         color: white; padding: 15px; border: none; border-radius: 8px; 
                         cursor: pointer; font-size: 1.1em; font-weight: bold;">
            ‚úÖ Confirm Swap
          </button>
        </div>
      `;
      document.body.appendChild(modal);
    }

    function updateTreasurySwapPreview() {
      const amount = parseFloat(document.getElementById('treasurySwapAmount').value) || 0;
      const usdcAmount = amount * ETH_TO_USDC_RATE;
      
      document.getElementById('swapETHAmount').textContent = `${amount.toFixed(4)} ETH`;
      document.getElementById('swapUSDCAmount').textContent = `${usdcAmount.toFixed(2)} USDC`;
    }

    window.executeSwapTreasuryETHtoUSDC = async function() {
      const amount = parseFloat(document.getElementById('treasurySwapAmount').value);

      // Validation
      if (isNaN(amount) || amount <= 0) {
        showNotification('‚ùå Invalid amount!', true);
        return;
      }

      if (amount > treasuryETHBalance) {
        showNotification(`‚ùå Insufficient treasury ETH! Available: ${treasuryETHBalance.toFixed(4)} ETH`, true);
        return;
      }

      // Process gas fee
      if (!await processGasFee('treasury ETH to USDC swap')) {
        return;
      }

      // Calculate USDC to receive
      const usdcAmount = amount * ETH_TO_USDC_RATE;

      // Update treasury balances
      treasuryETHBalance -= amount;
      treasuryUSDCBalance += usdcAmount;

      console.log(`[Treasury] Swapped ${amount} ETH to ${usdcAmount} USDC`);
      console.log(`[Treasury] New ETH balance: ${treasuryETHBalance.toFixed(4)} ETH`);
      console.log(`[Treasury] New USDC balance: ${treasuryUSDCBalance.toFixed(2)} USDC`);

      // Close modals
      document.querySelectorAll('.modal').forEach(m => m.remove());

      showNotification(`‚úÖ Swapped ${amount} ETH to ${usdcAmount.toFixed(2)} USDC in treasury`, false);
      
      // Reopen treasury management to show updated balances
      setTimeout(() => openTreasuryManagement(), 500);
    }

    window.showSection = function(id, event) {
      document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
      if (event && event.target) event.target.classList.add('active');

      const content = document.getElementById('content');
      content.innerHTML = '';

      if (id === 'learning') {
        content.innerHTML = `
          <div class="flex-container">
            <div class="progress-box">
              <h4 id="progressTitle">TASKS: ${completedTasks}/100</h4>
              <div class="reach">COMPLETE 100 TASKS TO MINT NFT</div>
              <div class="nft-container">
                <div class="nft-placeholder">
                  <div class="nft-gradient"></div>
                  <div class="nft-label" id="nftStatus">${nftMinted ? '‚úÖ NFT Minted!' : 'üîí Complete 100 Tasks'}</div>
                </div>
              </div>
              <div class="progress-section">
                <div class="progress-bar-long">
                  <div class="progress-fill-long" id="progressFill" style="width: ${(completedTasks/100)*100}%;"></div>
                </div>
                <span class="progress-label" id="progressLabel">${completedTasks}/100 Tasks Completed</span>
              </div>
              ${nftMinted ? '' : (completedTasks === 100 ? '<button class="btn-primary" style="margin-top:16px;" onclick="mintNFTFromLearning()">üéâ Mint Your NFT!</button>' : '')}
            </div>

            <div class="question-box">
              <div class="question-card">
                <div class="question-number" id="qNumber">Question ${currentQuestionIndex + 1}/100</div>
                <p class="question-title" id="qTitle"></p>
                <div style="margin:20px 0;" id="optionsContainer"></div>
                <div class="btn-group">
                  <button class="btn-primary" onclick="submitAnswer()">Submit Answer</button>
                  <button class="btn-primary" style="background:linear-gradient(90deg,#6b7280,#9ca3af);" onclick="saveProgress()">Save Progress</button>
                </div>
                <p style="margin-top:12px; font-size:0.9em; color:#94a3b8;">‚úÖ Correct: +100 points | ‚ùå Wrong: -100 points</p>
              </div>
            </div>

            <div style="flex:1; min-width:320px;">
              <div class="card">
                <h3>üí∞ Stake USDC (${getActiveNetwork().name})</h3>
                <p style="margin-bottom:8px; font-size:0.9em;">Your Balance: <span id="usdcBalanceDisplay">0.00</span> USDC</p>
                <p style="margin-bottom:12px; font-size:0.9em;">Stake to participate in learning rewards</p>
                <input type="number" id="stakeAmount" placeholder="Enter USDC amount" step="0.01" style="width:100%; padding:12px; background:#0f172a; border:1px solid var(--border); border-radius:8px; color:white; margin-bottom:16px;"/>
                <button class="btn-primary" onclick="stakeUSDC()">Stake USDC</button>
                <p class="stake-info" id="stakedDisplay">Staked: 0.00 USDC</p>

                <p style="margin:16px 0 8px;">Unstake amount</p>
                <input type="number" id="unstakeAmount" placeholder="Amount to unstake" step="0.01" style="width:100%; padding:12px; background:#0f172a; border:1px solid var(--border); border-radius:8px; color:white; margin-bottom:16px;"/>
                <button class="btn-primary" style="background:linear-gradient(90deg,var(--danger),#f87171);" onclick="unstakeUSDC()">Unstake USDC</button>
              </div>

              <div class="card" style="margin-top:20px;">
                <h3>üéØ Learning Points</h3>
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                  <span>Your Points</span>
                  <span style="font-weight:bold; color:#10b981;" id="pointDisplay">0 POINTS</span>
                </div>
                <div class="progress-bar">
                  <div class="progress-fill" id="pointProgress" style="width:0%;"></div>
                </div>
                <p style="margin-top:8px; font-size:0.9em; color:#94a3b8;">Conversion Rate: 1000 points = 1 USDC</p>
                <p style="margin-top:4px; font-size:0.85em; color:#f59e0b;">‚õΩ Gas Fee: ${GAS_FEE_ETH} ${getNetworkCurrency()} per answer</p>
                <button class="btn-primary btn-success" style="margin-top:16px;" onclick="convertPointsToUSDC()" ${mogalandPoints < 1000 ? 'disabled' : ''}>Convert to USDC</button>
                <div class="history" id="historyLog" style="margin-top:16px;">
                  <strong>Answer History (Recent 5):</strong><br>
                  <div id="historyItems" style="max-height:200px; overflow-y:auto;"></div>
                </div>
              </div>
            </div>
          </div>
        `;

        loadQuestion();
        updatePointDisplay();
        updateProgressDisplay();
        updateAnswerHistoryDisplay();
        updateStakedDisplay();
        updateUSDCBalance();
      }
      else if (id === 'market') {
        content.innerHTML = `
          <div style="max-width:1600px; margin:0 auto; padding:20px; color:white;">
            <h2 style="text-align:center; margin-bottom:10px; color:#60a5fa;">Mogaland-Plume Market Prediction</h2>
            <p style="text-align:center; opacity:0.8; margin-bottom:20px;">Live Trading Demo ‚Äî Trade with leverage using Sepolia USDC!</p>

            <div style="display:flex; justify-content:center; align-items:center; gap:8px; margin-bottom:25px; flex-wrap:wrap;">
              <button class="nav-btn active" data-tab="crypto">Crypto</button>
              <button class="nav-btn" data-tab="stocks">Stocks</button>
              <button class="nav-btn" data-tab="commodities">Commodities</button>
              <button class="nav-btn" data-tab="forex">Forex</button>
              <button class="nav-btn" data-tab="sports">Sports</button>
              <button class="btn-primary" onclick="showVolumeLeaderboard()" style="margin-left:16px; background:linear-gradient(90deg,#fbbf24,#f59e0b); padding:10px 20px;">
                üèÜ Volume Leaderboard
              </button>
            </div>

            <div class="flex-container" style="gap:25px; align-items:stretch;">
              <div class="card" style="flex:1; max-width:380px; overflow-y:auto; overflow-x:hidden; max-height:680px; padding:15px;">
                <h3 style="color:#60a5fa; text-align:center;" id="assetListTitle">Assets</h3>
                <div id="assetList" style="display:flex; flex-direction:column; gap:8px;"></div>
              </div>

              <div class="card" style="flex:2; min-height:580px; padding:20px;">
                <h3 id="viewTitle" style="color:#60a5fa; text-align:center; margin-bottom:15px;">Select Asset to Trade</h3>
                <div id="priceChart" style="min-height:420px; display:none;"></div>
                <div id="clubHistoryView" style="display:none; color:#e2e8f0; font-size:1.05em; line-height:1.6; padding:15px; background:rgba(13,110,253,0.08); border-radius:12px;"></div>
                <div id="chartFooter" style="text-align:center; margin-top:15px; font-size:0.95em; opacity:0.8; display:none;">
                  Live price data from TradingView
                </div>
              </div>

              <div class="card" style="flex:1; max-width:400px; padding:20px;">
                <h3 style="color:#60a5fa;">Trade Position</h3>
                <p>Asset: <strong id="selectedAsset">None</strong></p>
                <p style="font-size:0.95em; opacity:0.8; margin-bottom:8px;">Your Balance: <strong id="usdcBalanceTrading">0.00 USDC</strong></p>
                <div id="currentPriceDisplay" style="font-size:1.1em; margin-bottom:12px; display:none;">Current Price: <strong style="color:#10b981;" id="currentPrice">-</strong></div>
                
                <label style="display:block; margin:12px 0 6px;">Leverage</label>
                <select id="leverageSelect" style="width:100%; padding:10px; background:#0f172a; border:1px solid var(--border); border-radius:8px; color:white;">
                  <option value="1">1x (No Leverage)</option>
                  <option value="2">2x Leverage</option>
                  <option value="5" selected>5x Leverage</option>
                  <option value="10">10x Leverage</option>
                  <option value="20">20x Leverage</option>
                </select>

                <label style="display:block; margin:12px 0 6px;">Position Amount (USDC)</label>
                <input type="number" id="positionAmount" placeholder="Enter USDC amount" min="1" step="0.01" style="width:100%; padding:12px; margin-bottom:12px; background:#0f172a; border:1px solid var(--border); border-radius:8px; color:white;"/>
                
                <div id="leverageInfo" style="font-size:0.85em; color:#94a3b8; margin-bottom:12px; padding:12px; background:rgba(13,110,253,0.1); border-radius:6px; display:none;">
                  <div style="margin-bottom:4px;">üí∞ Entry Price: <span id="entryPrice" style="color:#10b981; font-weight:bold;">-</span></div>
                  <div style="margin-bottom:4px;">üìä Leverage: <span id="leverageAmount" style="color:#60a5fa; font-weight:bold;">-</span></div>
                  <div style="margin-bottom:4px;">üìà Trade Size: <span id="tradeSize" style="color:#10b981; font-weight:bold;">0</span> USDC</div>
                  <div style="margin-bottom:4px;">üíµ Required Margin: <span id="requiredMargin" style="color:#fbbf24; font-weight:bold;">0</span> USDC</div>
                  <div style="margin-bottom:4px;">üìâ Liquidation Price: <span id="liquidationPrice" style="color:#ef4444; font-weight:bold;">-</span></div>
                  <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                    <div style="font-size:0.9em; opacity:0.9;">Estimated PNL at +/-1%: <span id="estimatedPnl" style="color:#10b981; font-weight:bold;">-</span></div>
                  </div>
                </div>

                <div style="margin:16px 0; display:flex; gap:10px;">
                  <button class="btn-primary" style="flex:1; background:#10b981;" onclick="openPosition('long')">üîº LONG</button>
                  <button class="btn-primary" style="flex:1; background:#ef4444;" onclick="openPosition('short')">üîΩ SHORT</button>
                </div>

                <p id="tradeStatus" style="margin-top:15px; font-weight:bold; min-height:40px; font-size:0.9em;"></p>
                
                <p style="font-size:0.85em; color:#f59e0b; margin-top:8px;">‚õΩ Gas Fee: ${GAS_FEE_ETH} ${getNetworkCurrency()} per trade</p>

                <div style="margin-top:20px;">
                  <h4 style="color:#60a5fa; margin-bottom:8px;">Open Positions</h4>
                  <div id="openPositions" style="font-size:0.85em; max-height:120px; overflow-y:auto; color:#94a3b8;"></div>
                </div>

                <div style="margin-top:20px;">
                  <h4 style="color:#60a5fa; margin-bottom:8px;">Trade History</h4>
                  <div id="tradeHistory" style="font-size:0.85em; max-height:120px; overflow-y:auto; color:#94a3b8;"></div>
                </div>
              </div>
            </div>
          </div>
        `;

        const assetsData = {
          crypto: [
            {symbol: "BTCUSD", name: "Bitcoin", tvSymbol: "BINANCE:BTCUSDT", basePrice: 45000, volatility: 0.025},
            {symbol: "ETHUSD", name: "Ethereum", tvSymbol: "BINANCE:ETHUSDT", basePrice: 2500, volatility: 0.030},
            {symbol: "BNBUSD", name: "BNB", tvSymbol: "BINANCE:BNBUSDT", basePrice: 320, volatility: 0.028},
            {symbol: "SOLUSD", name: "Solana", tvSymbol: "BINANCE:SOLUSDT", basePrice: 100, volatility: 0.040},
            {symbol: "ADAUSD", name: "Cardano", tvSymbol: "BINANCE:ADAUSDT", basePrice: 0.50, volatility: 0.035},
            {symbol: "XRPUSD", name: "Ripple", tvSymbol: "BINANCE:XRPUSDT", basePrice: 0.60, volatility: 0.032},
            {symbol: "DOTUSD", name: "Polkadot", tvSymbol: "BINANCE:DOTUSDT", basePrice: 7.50, volatility: 0.038},
            {symbol: "MATICUSD", name: "Polygon", tvSymbol: "BINANCE:MATICUSDT", basePrice: 0.85, volatility: 0.042},
            {symbol: "LINKUSD", name: "Chainlink", tvSymbol: "BINANCE:LINKUSDT", basePrice: 15.00, volatility: 0.036},
            {symbol: "UNIUSD", name: "Uniswap", tvSymbol: "BINANCE:UNIUSDT", basePrice: 6.50, volatility: 0.040}
          ],
          stocks: [
            {symbol: "AAPL", name: "Apple Inc.", tvSymbol: "NASDAQ:AAPL", basePrice: 190, volatility: 0.015},
            {symbol: "TSLA", name: "Tesla Inc.", tvSymbol: "NASDAQ:TSLA", basePrice: 250, volatility: 0.045},
            {symbol: "GOOGL", name: "Alphabet", tvSymbol: "NASDAQ:GOOGL", basePrice: 140, volatility: 0.020},
            {symbol: "MSFT", name: "Microsoft", tvSymbol: "NASDAQ:MSFT", basePrice: 380, volatility: 0.018},
            {symbol: "AMZN", name: "Amazon", tvSymbol: "NASDAQ:AMZN", basePrice: 155, volatility: 0.025},
            {symbol: "NVDA", name: "NVIDIA", tvSymbol: "NASDAQ:NVDA", basePrice: 500, volatility: 0.040},
            {symbol: "META", name: "Meta Platforms", tvSymbol: "NASDAQ:META", basePrice: 350, volatility: 0.030}
          ],
          commodities: [
            {symbol: "GOLD", name: "Gold", tvSymbol: "TVC:GOLD", basePrice: 2050, volatility: 0.010},
            {symbol: "SILVER", name: "Silver", tvSymbol: "TVC:SILVER", basePrice: 24, volatility: 0.020},
            {symbol: "OIL", name: "Crude Oil", tvSymbol: "TVC:USOIL", basePrice: 75, volatility: 0.025},
            {symbol: "NATGAS", name: "Natural Gas", tvSymbol: "TVC:NATURALGAS", basePrice: 2.80, volatility: 0.035}
          ],
          forex: [
            {symbol: "EURUSD", name: "EUR/USD", tvSymbol: "FX:EURUSD", basePrice: 1.085, volatility: 0.005},
            {symbol: "GBPUSD", name: "GBP/USD", tvSymbol: "FX:GBPUSD", basePrice: 1.270, volatility: 0.006},
            {symbol: "USDJPY", name: "USD/JPY", tvSymbol: "FX:USDJPY", basePrice: 148.5, volatility: 0.007},
            {symbol: "AUDUSD", name: "AUD/USD", tvSymbol: "FX:AUDUSD", basePrice: 0.660, volatility: 0.008}
          ],
          sports: [
            {symbol: "Real Madrid", type: "football", teamId: "133602", league: "La Liga", strength: 0.85, nextMatch: "vs Barcelona", recentForm: [
              "Feb 5, 2026: W 3-1 vs Barcelona (La Liga)",
              "Jan 29, 2026: W 2-0 vs Atletico Madrid (Copa)",
              "Jan 22, 2026: L 1-2 vs Bayern Munich (UCL)"
            ]},
            {symbol: "Barcelona", type: "football", teamId: "133604", league: "La Liga", strength: 0.82, nextMatch: "vs Real Madrid", recentForm: [
              "Feb 4, 2026: W 2-1 vs Atletico Madrid",
              "Jan 28, 2026: L 0-2 vs Bayern Munich",
              "Jan 21, 2026: W 3-0 vs Sevilla"
            ]},
            {symbol: "Man City", type: "football", teamId: "133613", league: "Premier League", strength: 0.88, nextMatch: "vs Liverpool", recentForm: [
              "Feb 5, 2026: W 4-1 vs Chelsea",
              "Jan 29, 2026: W 3-0 vs Arsenal",
              "Jan 22, 2026: D 2-2 vs Liverpool"
            ]},
            {symbol: "Liverpool", type: "football", teamId: "133602", league: "Premier League", strength: 0.83, nextMatch: "vs Man City", recentForm: [
              "Feb 4, 2026: W 3-2 vs Chelsea",
              "Jan 28, 2026: L 1-3 vs Arsenal",
              "Jan 21, 2026: D 2-2 vs Man City"
            ]},
            {symbol: "Lakers", type: "basketball", teamId: "134864", league: "NBA", strength: 0.78, nextMatch: "vs Warriors", recentForm: [
              "Feb 5, 2026: W 112-108 vs Warriors",
              "Feb 1, 2026: L 98-105 vs Celtics",
              "Jan 28, 2026: W 120-115 vs Nets"
            ]},
            {symbol: "Warriors", type: "basketball", teamId: "134865", league: "NBA", strength: 0.81, nextMatch: "vs Lakers", recentForm: [
              "Feb 5, 2026: L 108-112 vs Lakers",
              "Feb 2, 2026: W 118-110 vs Celtics",
              "Jan 29, 2026: W 125-120 vs Nets"
            ]},
            {symbol: "Celtics", type: "basketball", teamId: "134859", league: "NBA", strength: 0.85, nextMatch: "vs Bucks", recentForm: [
              "Feb 4, 2026: W 118-105 vs Nets",
              "Feb 1, 2026: W 105-98 vs Lakers",
              "Jan 27, 2026: W 112-108 vs Heat"
            ]}
          ]
        };

        // Fetch real sports data from TheSportsDB API
        async function fetchSportsData(team) {
          if (!team.teamId) return;
          
          try {
            const API_KEY = '3'; // Free test key
            const eventsUrl = `https://www.thesportsdb.com/api/v1/json/${API_KEY}/eventslast.php?id=${team.teamId}`;
            const nextUrl = `https://www.thesportsdb.com/api/v1/json/${API_KEY}/eventsnext.php?id=${team.teamId}`;
            
            const [eventsRes, nextRes] = await Promise.all([
              fetch(eventsUrl).catch(() => null),
              fetch(nextUrl).catch(() => null)
            ]);
            
            if (eventsRes && eventsRes.ok) {
              const eventsData = await eventsRes.json();
              if (eventsData.results) {
                team.recentForm = eventsData.results.slice(0, 6).map(event => {
                  const date = new Date(event.dateEvent).toLocaleDateString('en-US', {month: 'short', day: 'numeric', year: 'numeric'});
                  const isHome = event.idHomeTeam === team.teamId;
                  const opponent = isHome ? event.strAwayTeam : event.strHomeTeam;
                  const score = isHome ? `${event.intHomeScore}-${event.intAwayScore}` : `${event.intAwayScore}-${event.intHomeScore}`;
                  
                  let result = 'D';
                  if (event.intHomeScore && event.intAwayScore) {
                    if (isHome) {
                      result = parseInt(event.intHomeScore) > parseInt(event.intAwayScore) ? 'W' : 
                               parseInt(event.intHomeScore) < parseInt(event.intAwayScore) ? 'L' : 'D';
                    } else {
                      result = parseInt(event.intAwayScore) > parseInt(event.intHomeScore) ? 'W' : 
                               parseInt(event.intAwayScore) < parseInt(event.intHomeScore) ? 'L' : 'D';
                    }
                  }
                  
                  return `${date}: ${result} ${score} vs ${opponent}`;
                });
              }
            }
            
            if (nextRes && nextRes.ok) {
              const nextData = await nextRes.json();
              if (nextData.events && nextData.events.length > 0) {
                const nextEvent = nextData.events[0];
                const isHome = nextEvent.idHomeTeam === team.teamId;
                const opponent = isHome ? nextEvent.strAwayTeam : nextEvent.strHomeTeam;
                const date = new Date(nextEvent.dateEvent).toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
                team.nextMatch = `${date} vs ${opponent}`;
              }
            }
          } catch (error) {
            console.log('Sports API error:', error);
          }
        }

        // Auto-update sports data periodically
        let sportsUpdateInterval = null;
        
        function startSportsAutoUpdate() {
          // Clear existing interval if any
          if (sportsUpdateInterval) {
            clearInterval(sportsUpdateInterval);
          }
          
          // Update sports data every 5 minutes
          sportsUpdateInterval = setInterval(() => {
            if (currentTab === 'sports') {
              console.log('Auto-updating sports data...');
              assetsData.sports.forEach(team => {
                fetchSportsData(team);
              });
              
              // Refresh display if on sports tab
              if (selectedAsset && selectedAsset.type) {
                setTimeout(() => {
                  showClubHistory(selectedAsset);
                }, 2000);
              }
            }
          }, 5 * 60 * 1000); // 5 minutes
          
          // Initial update for sports teams
          if (assetsData.sports) {
            assetsData.sports.forEach(team => {
              fetchSportsData(team);
            });
          }
        }

        function stopSportsAutoUpdate() {
          if (sportsUpdateInterval) {
            clearInterval(sportsUpdateInterval);
            sportsUpdateInterval = null;
          }
        }

        let currentTab = 'crypto';
        let selectedAsset = null;
        let chart = null;
        let priceHistory = [];
        let currentBet = null;
        let openPositions = [];
        let tradeHistoryList = [];
        let liquidationHistory = []; // Track liquidation events
        let liquidationMonitorInterval = null; // Interval for checking liquidations
        let binanceWebSocket = null; // WebSocket connection to Binance
        let priceUpdateMethod = 'websocket'; // 'websocket' or 'polling'
        // Note: tradingUSDCBalance is now declared in global scope
        
        // Fetch real USDC balance for trading
        async function fetchTradingBalance() {
          if (!provider || !userAddress) {
            tradingUSDCBalance = 0;
            updateTradingBalance();
            return;
          }
          
          try {
            const usdcContract = new ethers.Contract(USDC_SEPOLIA_ADDRESS, USDC_ABI, provider);
            const balance = await usdcContract.balanceOf(userAddress);
            const decimals = await usdcContract.decimals();
            tradingUSDCBalance = parseFloat(ethers.utils.formatUnits(balance, decimals));
            updateTradingBalance();
            console.log('‚úÖ Trading balance loaded:', tradingUSDCBalance, 'USDC');
          } catch (error) {
            console.error('Failed to fetch trading balance:', error);
            showNotification("Failed to load trading balance", true);
          }
        }
        
        // Call fetchTradingBalance when market section is opened
        if (provider && userAddress) {
          fetchTradingBalance();
        }

        // Update leverage info display
        function updateLeverageInfo() {
          const amount = parseFloat(document.getElementById('positionAmount')?.value || 0);
          const leverage = parseInt(document.getElementById('leverageSelect')?.value || 1);
          
          if (amount > 0 && selectedAsset) {
            const tradeSize = amount * leverage;
            const entryPrice = selectedAsset.basePrice || 0;
            
            // Calculate liquidation price based on leverage
            // For long: liquidation when price drops by (100% / leverage)
            // For short: liquidation when price rises by (100% / leverage)
            const liquidationThreshold = LIQUIDATION_CONFIG.LIQUIDATION_THRESHOLD_PERCENT / 100; // 0.15 = 15%
            const priceChangeToLiquidation = liquidationThreshold / leverage;
            const longLiquidationPrice = entryPrice * (1 - priceChangeToLiquidation);
            const shortLiquidationPrice = entryPrice * (1 + priceChangeToLiquidation);
            
            // Calculate estimated PNL at +/-1% price movement
            const priceChange1Percent = 0.01;
            const pnlPercentPerLeverage = priceChange1Percent * leverage * 100; // In percentage
            const pnlUSDC = amount * pnlPercentPerLeverage / 100;
            
            // Update display
            document.getElementById('tradeSize').textContent = tradeSize.toFixed(2);
            document.getElementById('requiredMargin').textContent = amount.toFixed(2);
            document.getElementById('leverageAmount').textContent = leverage + 'x';
            document.getElementById('entryPrice').textContent = entryPrice > 0 ? `$${entryPrice.toLocaleString()}` : '-';
            document.getElementById('liquidationPrice').textContent = entryPrice > 0 
              ? `Long: $${longLiquidationPrice.toFixed(2)} | Short: $${shortLiquidationPrice.toFixed(2)}`
              : '-';
            document.getElementById('estimatedPnl').textContent = `¬±$${pnlUSDC.toFixed(2)} (${pnlPercentPerLeverage.toFixed(1)}%)`;
            document.getElementById('leverageInfo').style.display = 'block';
          } else {
            document.getElementById('leverageInfo').style.display = 'none';
          }
        }

        // === LIQUIDATION SYSTEM ===
        
        /**
         * Calculate position equity percentage
         * Equity = (Current Value - Initial Value) / Margin
         * Where Current Value = Position Amount √ó Leverage √ó (Current Price / Entry Price)
         */
        function calculatePositionEquity(position, currentPrice) {
          if (!position.entryPrice || position.entryPrice === 0) return 100;
          
          const priceChange = (currentPrice - position.entryPrice) / position.entryPrice;
          const positionPnL = priceChange * position.leverage;
          
          // For long positions: profit when price goes up
          // For short positions: profit when price goes down
          const effectivePnL = position.type === 'long' ? positionPnL : -positionPnL;
          
          // Equity % = 100% + P&L%
          const equityPercent = 100 + (effectivePnL * 100);
          
          return equityPercent;
        }
        
        /**
         * Check if position should be liquidated
         * Returns { shouldLiquidate: boolean, equityPercent: number, reason: string }
         */
        function checkLiquidation(position, currentPrice) {
          const equityPercent = calculatePositionEquity(position, currentPrice);
          
          if (equityPercent <= LIQUIDATION_CONFIG.LIQUIDATION_THRESHOLD_PERCENT) {
            return {
              shouldLiquidate: true,
              equityPercent: equityPercent,
              reason: `Equity fell to ${equityPercent.toFixed(2)}% (below ${LIQUIDATION_CONFIG.LIQUIDATION_THRESHOLD_PERCENT}% threshold)`
            };
          }
          
          return {
            shouldLiquidate: false,
            equityPercent: equityPercent,
            reason: null
          };
        }
        
        /**
         * Execute liquidation for a position
         * Transfers remaining equity to treasury (acts as insurance fund)
         */
        function liquidatePosition(position, idx, currentPrice, reason) {
          console.log(`üî¥ LIQUIDATING POSITION #${idx}:`, position);
          
          // Calculate final values
          const equityPercent = calculatePositionEquity(position, currentPrice);
          const remainingEquity = position.amount * (equityPercent / 100);
          const loss = position.amount - remainingEquity;
          const liquidationFee = remainingEquity * (LIQUIDATION_CONFIG.LIQUIDATION_FEE_PERCENT / 100);
          const returnToUser = Math.max(0, remainingEquity - liquidationFee);
          
          // Transfer remaining equity to treasury (insurance fund)
          if (remainingEquity > 0) {
            // Note: Position amount already in treasury, liquidation fee stays there
            console.log(`üí∞ Liquidation fee (${LIQUIDATION_CONFIG.LIQUIDATION_FEE_PERCENT}%): ${liquidationFee.toFixed(4)} USDC to treasury`);
          }
          
          // Return remaining funds to user if any
          if (returnToUser > 0) {
            if (transferFromTreasury(returnToUser)) {
              console.log(`‚Ü©Ô∏è Returned ${returnToUser.toFixed(4)} USDC to user after liquidation`);
            }
          }
          
          // Record liquidation event
          const liquidationEvent = {
            timestamp: new Date().toISOString(),
            position: {...position},
            liquidationPrice: currentPrice,
            equityPercent: equityPercent,
            amountLost: loss,
            liquidationFee: liquidationFee,
            returnedToUser: returnToUser,
            reason: reason
          };
          
          liquidationHistory.push(liquidationEvent);
          
          // Add to trade history with liquidation flag
          tradeHistoryList.push({
            asset: position.asset,
            type: position.type,
            leverage: position.leverage,
            amount: position.amount,
            entryPrice: position.entryPrice,
            exitPrice: currentPrice,
            pnl: -(loss),
            closeTime: new Date().toLocaleTimeString(),
            liquidated: true
          });
          
          // Remove from open positions
          openPositions.splice(idx, 1);
          
          // Show liquidation notification
          showNotification(
            `‚ö†Ô∏è LIQUIDATED: ${position.asset.symbol} ${position.type.toUpperCase()} position | ` +
            `Lost: $${loss.toFixed(2)} | Returned: $${returnToUser.toFixed(2)} | ` +
            `Reason: ${reason}`,
            true
          );
          
          // Update displays
          updatePositionsDisplay();
          updateTradeHistory();
          updateTradingBalance();
          
          console.log(`üìä Liquidation complete. Treasury now holds: ${treasuryUSDCBalance.toFixed(2)} USDC`);
        }
        
        /**
         * Monitor all open positions for liquidation
         */
        function monitorLiquidations() {
          if (openPositions.length === 0) return;
          
          openPositions.forEach((position, idx) => {
            // Skip sports bets (they have their own settlement)
            if (position.isSportsBet) return;
            
            // Get current price for this asset
            const currentPrice = priceHistory.length > 0 ? 
              priceHistory[priceHistory.length - 1]?.c : 
              position.entryPrice;
            
            if (!currentPrice || currentPrice === 0) return;
            
            // Check liquidation status
            const liquidationCheck = checkLiquidation(position, currentPrice);
            
            if (liquidationCheck.shouldLiquidate) {
              liquidatePosition(position, idx, currentPrice, liquidationCheck.reason);
            }
          });
        }
        
        /**
         * Start liquidation monitoring system
         */
        function startLiquidationMonitoring() {
          if (liquidationMonitorInterval) {
            clearInterval(liquidationMonitorInterval);
          }
          
          liquidationMonitorInterval = setInterval(() => {
            monitorLiquidations();
          }, LIQUIDATION_CONFIG.CHECK_INTERVAL_MS);
          
          console.log('üîÑ Liquidation monitoring started (checking every 5 seconds)');
        }
        
        /**
         * Stop liquidation monitoring system
         */
        function stopLiquidationMonitoring() {
          if (liquidationMonitorInterval) {
            clearInterval(liquidationMonitorInterval);
            liquidationMonitorInterval = null;
            console.log('‚èπÔ∏è Liquidation monitoring stopped');
          }
        }

        // Update positions display
        function updatePositionsDisplay() {
          const container = document.getElementById('openPositions');
          if (!container) return;
          
          if (openPositions.length === 0) {
            container.innerHTML = '<div style="opacity:0.6;">No open positions</div>';
            return;
          }
          
          container.innerHTML = openPositions.map((pos, idx) => {
            // Handle sports bets
            if (pos.isSportsBet) {
              const betType = pos.type === 'long' ? 'WIN' : 'LOSE';
              return `
                <div style="padding:8px; background:rgba(251,191,36,0.1); border-radius:6px; margin-bottom:6px;">
                  <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                    <span><strong>${pos.asset.symbol}</strong> ${pos.leverage}x</span>
                    <span style="color:#fbbf24">üèÜ ${betType}</span>
                  </div>
                  <div style="font-size:0.85em; opacity:0.8;">
                    Bet: ${pos.amount.toFixed(2)} USDC
                  </div>
                  <div style="color:#fbbf24; font-weight:bold; margin-top:4px;">
                    ‚è≥ Waiting for match result...
                  </div>
                </div>
              `;
            }
            
            // Handle regular trading positions
            const currentPrice = selectedAsset && selectedAsset.symbol === pos.asset.symbol ? 
              (priceHistory[priceHistory.length - 1]?.c || pos.entryPrice) : pos.entryPrice;
            const priceDiff = currentPrice - pos.entryPrice;
            const pnl = pos.type === 'long' ? priceDiff * pos.leverage * (pos.amount / pos.entryPrice) : 
                                             -priceDiff * pos.leverage * (pos.amount / pos.entryPrice);
            const pnlPercent = (pnl / pos.amount) * 100;
            const pnlColor = pnl >= 0 ? '#10b981' : '#ef4444';
            
            // Calculate equity and liquidation risk
            const equityPercent = calculatePositionEquity(pos, currentPrice);
            let riskIndicator = '';
            let riskColor = '#10b981';
            
            if (equityPercent <= LIQUIDATION_CONFIG.LIQUIDATION_THRESHOLD_PERCENT) {
              riskIndicator = '‚ö†Ô∏è LIQUIDATION IMMINENT';
              riskColor = '#ef4444';
            } else if (equityPercent <= LIQUIDATION_CONFIG.WARNING_THRESHOLD_PERCENT) {
              riskIndicator = '‚ö° HIGH RISK';
              riskColor = '#f59e0b';
            } else if (equityPercent <= 50) {
              riskIndicator = '‚ö†Ô∏è MODERATE RISK';
              riskColor = '#eab308';
            } else {
              riskIndicator = '‚úì HEALTHY';
              riskColor = '#10b981';
            }
            
            return `
              <div style="padding:8px; background:rgba(13,110,253,0.08); border:${equityPercent <= LIQUIDATION_CONFIG.WARNING_THRESHOLD_PERCENT ? '2px solid ' + riskColor : '1px solid rgba(255,255,255,0.1)'}; border-radius:6px; margin-bottom:6px;">
                <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                  <span><strong>${pos.asset.symbol}</strong> ${pos.leverage}x</span>
                  <span style="color:${pos.type === 'long' ? '#10b981' : '#ef4444'}">${pos.type.toUpperCase()}</span>
                </div>
                <div style="font-size:0.85em; opacity:0.8;">
                  Entry: $${pos.entryPrice.toFixed(2)} | Amount: ${pos.amount.toFixed(2)} USDC
                </div>
                <div style="color:${pnlColor}; font-weight:bold; margin-top:4px;">
                  P&L: ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)
                </div>
                <div style="margin-top:4px; font-size:0.85em;">
                  <div style="color:${riskColor}; font-weight:600;">Equity: ${equityPercent.toFixed(1)}% ${riskIndicator}</div>
                  <div style="opacity:0.7; font-size:0.9em;">Liquidation at ${LIQUIDATION_CONFIG.LIQUIDATION_THRESHOLD_PERCENT}% equity</div>
                </div>
                <button onclick="closePosition(${idx})" style="margin-top:6px; padding:4px 8px; background:#ef4444; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85em;">Close</button>
              </div>
            `;
          }).join('');
        }

        // Update trade history
        function updateTradeHistory() {
          const container = document.getElementById('tradeHistory');
          if (!container) return;
          
          if (tradeHistoryList.length === 0) {
            container.innerHTML = '<div style="opacity:0.6;">No trades yet</div>';
            return;
          }
          
          container.innerHTML = tradeHistoryList.slice(-5).reverse().map(trade => {
            const pnlColor = trade.pnl >= 0 ? '#10b981' : '#ef4444';
            const liquidationBadge = trade.liquidated ? 
              '<span style="background:#ef4444; color:white; padding:2px 5px; border-radius:3px; font-size:0.75em; margin-left:4px; font-weight:bold;">LIQ</span>' : 
              '';
            
            return `
              <div style="padding:6px; border-bottom:1px solid rgba(255,255,255,0.1); font-size:0.85em;">
                <div><strong>${trade.asset.symbol}</strong> ${trade.leverage}x ${trade.type.toUpperCase()} ${liquidationBadge}</div>
                <div style="opacity:0.8;">${trade.amount.toFixed(2)} USDC</div>
                <div style="color:${pnlColor};">P&L: ${trade.pnl >= 0 ? '+' : ''}$${trade.pnl.toFixed(2)}</div>
              </div>
            `;
          }).join('');
        }

        // Update USDC balance display
        function updateTradingBalance() {
          const el = document.getElementById('usdcBalanceTrading');
          if (el) el.textContent = tradingUSDCBalance.toFixed(2) + ' USDC';
        }

        function renderAssets() {
          const container = document.getElementById('assetList');
          const titleEl = document.getElementById('assetListTitle');
          if (!container || !titleEl) return;

          container.innerHTML = '';
          titleEl.textContent = currentTab === 'sports' ? 'Football & Basketball Teams' : 'Assets';

          const tabAssets = assetsData[currentTab] || [];
          tabAssets.forEach(asset => {
            const div = document.createElement('div');
            div.style.padding = '12px 10px';
            div.style.background = 'rgba(13,110,253,0.1)';
            div.style.borderRadius = '8px';
            div.style.cursor = 'pointer';
            div.style.marginBottom = '6px';
            
            const displayName = asset.name || asset.symbol;
            const subtitle = asset.type ? ` (${asset.type})` : asset.league ? ` - ${asset.league}` : '';
            
            div.innerHTML = `<strong>${displayName}</strong><span style="opacity:0.7; font-size:0.85em;">${subtitle}</span>`;
            div.onclick = currentTab === 'sports' ? () => showClubHistory(asset) : () => selectAsset(asset);
            container.appendChild(div);
          });
        }

        function showClubHistory(asset) {
          selectedAsset = asset;
          document.getElementById('selectedAsset').textContent = asset.symbol;
          document.getElementById('viewTitle').textContent = `${asset.symbol} - ${asset.type === 'football' ? 'Football' : 'Basketball'}`;

          document.getElementById('priceChart').style.display = 'none';
          document.getElementById('chartFooter').style.display = 'none';
          document.getElementById('currentPriceDisplay').style.display = 'none';

          const view = document.getElementById('clubHistoryView');
          view.style.display = 'block';
          
          // Show loading state
          view.innerHTML = `
            <div style="text-align:center; padding:20px;">
              <div style="font-size:1.2em; margin-bottom:10px;">üìä Loading real match data...</div>
              <div style="opacity:0.6;">Fetching from TheSportsDB API</div>
            </div>
          `;
          
          // Fetch real sports data
          fetchSportsData(asset).then(() => {
            // Calculate win rate from recent form using single reduce operation
            const { wins, losses, draws } = asset.recentForm.reduce((acc, match) => {
              if (match.includes(': W ')) acc.wins++;
              else if (match.includes(': L ')) acc.losses++;
              else if (match.includes(': D ')) acc.draws++;
              return acc;
            }, { wins: 0, losses: 0, draws: 0 });
            
            const totalGames = asset.recentForm.length;
            const winRate = totalGames > 0 ? ((wins / totalGames) * 100).toFixed(0) : '0';
            
            // Display with enhanced stats including win percentage
            view.innerHTML = `
              <div style="background:rgba(16,185,129,0.1); padding:12px; border-radius:8px; margin-bottom:16px;">
                <strong>üìä Team Performance:</strong><br>
                League: ${asset.league}<br>
                <div style="margin-top:8px; display:flex; justify-content:space-between; align-items:center;">
                  <div>
                    <span style="color:#10b981; font-weight:bold; font-size:1.2em;">${winRate}%</span> Win Rate<br>
                    <span style="font-size:0.9em; opacity:0.8;">Strength: ${(asset.strength * 100).toFixed(0)}%</span>
                  </div>
                  <div style="text-align:right; font-size:0.9em;">
                    <span style="color:#10b981;">‚úì ${wins}W</span> | 
                    <span style="color:#fbbf24;">‚àí ${draws}D</span> | 
                    <span style="color:#ef4444;">‚úó ${losses}L</span>
                  </div>
                </div>
                <div style="margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1);">
                  <strong>üîú Next Match: ${asset.nextMatch}</strong>
                </div>
              </div>
              
              <div style="background:rgba(59,130,246,0.1); padding:10px; border-radius:8px; margin-bottom:12px; font-size:0.9em;">
                <strong>üì° Live Scores:</strong> 
                <span style="opacity:0.8;">Visit <a href="https://www.livescore.com/en/" target="_blank" style="color:#60a5fa;">LiveScore.com</a> for real-time match updates</span>
              </div>
              
              <strong>üìã Recent Results:</strong><br><br>
              ${totalGames > 0 ? asset.recentForm.map(matchResult => {
                const result = matchResult.match(/: ([WLD]) /)?.[1];
                const color = result === 'W' ? '#10b981' : result === 'L' ? '#ef4444' : '#fbbf24';
                return `<div style="padding:6px; margin:4px 0; background:rgba(255,255,255,0.05); border-left:3px solid ${color}; border-radius:4px;">${matchResult}</div>`;
              }).join('') : '<div style="opacity:0.6;">No recent matches available</div>'}
              <br>
              <div style="background:rgba(59,130,246,0.1); padding:12px; border-radius:8px; margin-top:12px;">
                <strong>üí∞ Place Your Bet with Sepolia USDC:</strong><br>
                Predict if <strong>${asset.symbol}</strong> will WIN or LOSE their next match!<br>
                <span style="font-size:0.9em; opacity:0.9;">Win Probability: <span style="color:#10b981; font-weight:bold;">${winRate}%</span> | Use the controls on the right to place your bet with leverage.</span>
              </div>
            `;
          }).catch(error => {
            console.error('Error fetching sports data:', error);
            view.innerHTML = `
              <div style="background:rgba(239,68,68,0.1); padding:12px; border-radius:8px; text-align:center;">
                <strong>‚ö†Ô∏è Unable to fetch real-time data</strong><br>
                Using cached match history<br><br>
                ${asset.recentForm.map(matchResult => `<div style="padding:4px;">${matchResult}</div>`).join('')}
              </div>
            `;
          });
          
          updateTradingBalance();
          // Update leverage info to show entry price and other details
          updateLeverageInfo();
        }

        function selectAsset(asset) {
          if (!asset) return;
          selectedAsset = asset;
          document.getElementById('selectedAsset').textContent = asset.symbol;
          document.getElementById('viewTitle').textContent = `${asset.symbol} Chart`;

          document.getElementById('priceChart').style.display = 'block';
          document.getElementById('chartFooter').style.display = 'block';
          document.getElementById('clubHistoryView').style.display = 'none';

          // Show current price
          document.getElementById('currentPriceDisplay').style.display = 'block';

          initChart(asset);
          
          // Priority 1: Use Chainlink on-chain oracle for supported assets
          // Priority 2: Use Binance WebSocket for crypto
          // Priority 3: Use CoinGecko polling for others
          if (hasChainlinkFeed(asset.symbol)) {
            console.log(`[Price Updates] Using Chainlink Price Feed for ${asset.symbol}`);
            startRealTimePriceUpdates(); // Uses Chainlink in fetchTradingViewPrice
          } else if (currentTab === 'crypto' && asset.symbol.includes('USD')) {
            console.log(`[Price Updates] Using Binance WebSocket for ${asset.symbol}`);
            connectBinanceWebSocket(asset.symbol);
          } else {
            console.log(`[Price Updates] Using CoinGecko polling for ${asset.symbol}`);
            startRealTimePriceUpdates();
          }
          
          updateTradingBalance();
          // Update leverage info to show entry price and other details
          updateLeverageInfo();
        }

        // Open a new position
        window.openPosition = async function(type) {
          // Check wallet connection first
          if (!provider || !userAddress) {
            showNotification('‚ö†Ô∏è Please connect your wallet to start trading!', true);
            connectWalletFromApp();
            return;
          }
          
          if (!selectedAsset) {
            showNotification('Please select an asset/team first!', true);
            return;
          }

          const amount = parseFloat(document.getElementById('positionAmount')?.value || 0);
          const leverage = parseInt(document.getElementById('leverageSelect')?.value || 1);
          
          if (amount <= 0 || isNaN(amount)) {
            showNotification('Please enter a valid amount!', true);
            return;
          }

          // Check USDC balance for position
          if (amount > tradingUSDCBalance) {
            showNotification(`Insufficient USDC balance! Need ${amount.toFixed(2)} USDC for position`, true);
            return;
          }

          try {
            showNotification(`üîÑ Opening ${type.toUpperCase()} position...`, false);
            
            const signer = provider.getSigner();
            const currentPrice = priceHistory[priceHistory.length - 1]?.c || selectedAsset.basePrice;
            
            // For real implementation: Transfer USDC to trading contract
            // For testnet demo: Send small ETH transaction to record position on-chain
            // Note: Cannot include data field when sending to EOA (treasury wallet)
            const tx = await signer.sendTransaction({
              to: TREASURY_WALLET_ADDRESS, // In real implementation, this would be trading contract
              value: ethers.utils.parseEther('0.0001'), // Small amount to record on-chain
              gasLimit: GAS_LIMITS.POSITION_OPEN
            });
            
            showNotification(`üîÑ Transaction sent! Waiting for confirmation...`, false);
            console.log('[Trading] Position transaction hash:', tx.hash);
            
            await tx.wait();
            console.log('[Trading] Position recorded on-chain!');

            // For sports betting
            if (currentTab === 'sports') {
              const position = {
                asset: selectedAsset,
                type: type, // 'long' = WIN, 'short' = LOSE
                amount: amount,
                leverage: leverage,
                openTime: new Date().toLocaleTimeString(),
                isSportsBet: true,
                txHash: tx.hash,
                category: 'sports' // Store category for volume tracking
              };

              openPositions.push(position);
              tradingUSDCBalance -= amount;
              transferToTreasury(amount); // Move bet amount to treasury

              const betType = type === 'long' ? 'WIN' : 'LOSE';
              recordTransaction(tx.hash, 'Sports Bet', `${selectedAsset.symbol} ${betType} ${leverage}x on ${amount.toFixed(2)} USDC`, {amount: amount, token: 'USDC', to: TREASURY_WALLET_ADDRESS});
              showNotification(
                `üèÜ Sports bet placed: ${selectedAsset.symbol} to ${betType}<br>${leverage}x leverage on ${amount.toFixed(2)} USDC<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
                false
              );
              
              // Track trading volume for leaderboard (opening bet)
              updateTradingVolume('sports', amount);
              
              document.getElementById('positionAmount').value = '';
              document.getElementById('leverageInfo').style.display = 'none';
              
              // Simulate match result after 15 seconds
              setTimeout(() => {
                const idx = openPositions.findIndex(p => p === position);
                if (idx !== -1) {
                  // Use team strength to determine outcome
                  const winChance = type === 'long' ? selectedAsset.strength : (1 - selectedAsset.strength);
                  const won = Math.random() < winChance;
                  
                  const profit = amount * leverage * 0.9; // 90% profit if win
                  
                  if (won) {
                    // Transfer winnings from treasury to user
                    const totalPayout = amount + profit; // Return bet + profit
                    if (transferFromTreasury(totalPayout)) {
                      tradeHistoryList.push({
                        asset: selectedAsset,
                        type: type === 'long' ? 'WIN' : 'LOSE',
                        leverage: leverage,
                        amount: amount,
                        pnl: profit,
                        closeTime: new Date().toLocaleTimeString()
                      });
                      showNotification(`üèÜ Match result: ${selectedAsset.symbol} - You won $${profit.toFixed(2)} from treasury!`, false);
                    }
                  } else {
                    // Loss - money stays in treasury
                    tradeHistoryList.push({
                      asset: selectedAsset,
                      type: type === 'long' ? 'WIN' : 'LOSE',
                      leverage: leverage,
                      amount: amount,
                      pnl: -amount,
                      closeTime: new Date().toLocaleTimeString()
                    });
                    showNotification(`üèÜ Match result: ${selectedAsset.symbol} - You lost $${amount.toFixed(2)} to treasury`, true);
                  }
                  
                  // Track trading volume for leaderboard (closing bet)
                  const category = position.category || 'sports';
                  updateTradingVolume(category, amount);
                  
                  openPositions.splice(idx, 1);
                  
                  updatePositionsDisplay();
                  updateTradeHistory();
                  updateTradingBalance();
                }
              }, 15000);
              
              updatePositionsDisplay();
              updateTradingBalance();
              
              const statusEl = document.getElementById('tradeStatus');
              if (statusEl) {
                statusEl.textContent = `‚è≥ Bet placed: ${selectedAsset.symbol} to ${betType} | Result in 15s`;
                statusEl.style.color = '#fbbf24';
              }
              return;
            }

            // For regular trading (crypto, stocks, commodities, forex)
            const category = currentTab || 'crypto'; // Save category for later tracking
            const position = {
              asset: selectedAsset,
              type: type,
              entryPrice: currentPrice,
              amount: amount,
              leverage: leverage,
              openTime: new Date().toLocaleTimeString(),
              txHash: tx.hash,
              category: category // Store category for volume tracking on close
            };

            openPositions.push(position);
            tradingUSDCBalance -= amount;
            transferToTreasury(amount); // Move position to treasury
            
            // Start liquidation monitoring when first position is opened
            if (openPositions.length === 1) {
              startLiquidationMonitoring();
            }

          recordTransaction(tx.hash, 'Market', `Opened ${type.toUpperCase()} ${selectedAsset.symbol} ${leverage}x at $${currentPrice.toFixed(2)}`, {amount: amount, token: 'USDC', to: TREASURY_WALLET_ADDRESS});
          showNotification(
            `üîì Opened ${type.toUpperCase()} position: ${selectedAsset.symbol} ${leverage}x at $${currentPrice.toFixed(2)}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
            false
          );
          
          // Track trading volume for leaderboard (use category already defined at line 5233)
          updateTradingVolume(category, amount);
          
          document.getElementById('positionAmount').value = '';
          document.getElementById('leverageInfo').style.display = 'none';
          
          updatePositionsDisplay();
          updateTradingBalance();
          
          const statusEl = document.getElementById('tradeStatus');
          if (statusEl) {
            statusEl.textContent = `‚úÖ Position opened: ${type.toUpperCase()} ${selectedAsset.symbol} ${leverage}x`;
            statusEl.style.color = type === 'long' ? '#10b981' : '#ef4444';
          }
          
          } catch (error) {
            console.error('[Trading] Error opening position:', error);
            showNotification(`‚ùå Failed to open position: ${error.message}`, true);
          }
        }

        // Close a position
        async function closePosition(idx) {
          if (idx < 0 || idx >= openPositions.length) return;
          
          const position = openPositions[idx];
          
          // Handle sports bets separately
          if (position.isSportsBet) {
            showNotification('Sports bets are settled automatically after 15 seconds!', true);
            return;
          }
          
          // Check wallet connection
          if (!provider || !userAddress) {
            showNotification('‚ö†Ô∏è Please connect your wallet to close position!', true);
            connectWalletFromApp();
            return;
          }
          
          try {
            showNotification('üîÑ Closing position...', false);
            
            const currentPrice = priceHistory[priceHistory.length - 1]?.c || position.entryPrice;
            const priceDiff = currentPrice - position.entryPrice;
            const pnl = position.type === 'long' ? 
              priceDiff * position.leverage * (position.amount / position.entryPrice) : 
              -priceDiff * position.leverage * (position.amount / position.entryPrice);
            
            // Send close position transaction on-chain
            // Note: Cannot include data field when sending to EOA (treasury wallet)
            const signer = provider.getSigner();
            
            const tx = await signer.sendTransaction({
              to: TREASURY_WALLET_ADDRESS,
              value: ethers.utils.parseEther('0.0001'), // Small amount to record on-chain
              gasLimit: GAS_LIMITS.POSITION_CLOSE
            });
            
            console.log('[Trading] Close position transaction hash:', tx.hash);
            await tx.wait();
            console.log('[Trading] Position close recorded on-chain!');
            
            // Handle treasury transfers based on profit/loss
            if (pnl >= 0) {
              // Profit: Return position + profit from treasury
              const totalPayout = position.amount + pnl;
              if (transferFromTreasury(totalPayout)) {
                recordTransaction(tx.hash, 'Market', `Closed ${position.type.toUpperCase()} ${position.asset} with profit $${pnl.toFixed(2)}`, {amount: pnl, token: 'USDC', to: userAddress});
                showNotification(
                  `‚úÖ Position closed with profit: $${pnl.toFixed(2)}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
                  false
                );
              }
            } else {
              // Loss: User loses position amount (already in treasury), no payout
              recordTransaction(tx.hash, 'Market', `Closed ${position.type.toUpperCase()} ${position.asset} with loss $${Math.abs(pnl).toFixed(2)}`, {amount: Math.abs(pnl), token: 'USDC', to: TREASURY_WALLET_ADDRESS});
              showNotification(
                `‚úÖ Position closed with loss: $${Math.abs(pnl).toFixed(2)}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
                true
              );
            }
            
            // Add to history
            tradeHistoryList.push({
              asset: position.asset,
              type: position.type,
              leverage: position.leverage,
              amount: position.amount,
              entryPrice: position.entryPrice,
              exitPrice: currentPrice,
              pnl: pnl,
              closeTime: new Date().toLocaleTimeString(),
              txHash: tx.hash
            });
            
            // Track trading volume for leaderboard (closing trade)
            const category = position.category || currentTab || 'crypto';
            updateTradingVolume(category, position.amount);
            
            // Remove from open positions
            openPositions.splice(idx, 1);
            
            // Stop liquidation monitoring if no positions remain
            if (openPositions.length === 0) {
              stopLiquidationMonitoring();
            }
            
            updatePositionsDisplay();
            updateTradeHistory();
            updateTradingBalance();
          } catch (error) {
            console.error('[Trading] Error closing position:', error);
            showNotification(`‚ùå Failed to close position: ${error.message}`, true);
          }
        }
        window.closePosition = closePosition;

        // DEPRECATED: Old function replaced by generateOHLCFromRealPrice
        // Kept for backward compatibility with initialization that doesn't fetch real price yet
        function generateOHLC(basePrice, count = 40) {
          console.warn('[DEPRECATED] Using generateOHLC with basePrice. Should use generateOHLCFromRealPrice with real fetched price.');
          return generateOHLCFromRealPrice(basePrice || 1000, count);
        }

        function initChart(asset) {
          const container = document.getElementById('priceChart');
          if (!container) return;

          // Clear previous content
          container.innerHTML = '';
          container.style.display = 'block';

          // Use TradingView widget if tvSymbol is available
          if (asset.tvSymbol && typeof TradingView !== 'undefined') {
            try {
              // Create TradingView Advanced Chart Widget
              new TradingView.widget({
                "width": container.offsetWidth || 700,
                "height": CHART_HEIGHT,
                "symbol": asset.tvSymbol,
                "interval": "15",
                "timezone": "Etc/UTC",
                "theme": "dark",
                "style": "1",
                "locale": "en",
                "toolbar_bg": "#0a2540",
                "enable_publishing": false,
                "hide_side_toolbar": false,
                "allow_symbol_change": false,
                "container_id": "priceChart",
                "backgroundColor": "#0a2540",
                "gridColor": "rgba(255, 255, 255, 0.06)",
                "hide_legend": false,
                "save_image": false
              });
              
              // Fetch current price from TradingView
              fetchTradingViewPrice(asset);
              
              return;
            } catch (e) {
              console.log('TradingView widget error, trying CoinGecko:', e);
            }
          }

          // Second fallback: Try CoinGecko chart for crypto assets
          if (currentTab === 'crypto' && asset.symbol) {
            try {
              const coinGeckoIds = {
                'BTCUSD': 'bitcoin',
                'ETHUSD': 'ethereum',
                'BNBUSD': 'binancecoin',
                'SOLUSD': 'solana',
                'ADAUSD': 'cardano',
                'XRPUSD': 'ripple',
                'DOTUSD': 'polkadot',
                'MATICUSD': 'matic-network',
                'LINKUSD': 'chainlink',
                'UNIUSD': 'uniswap'
              };
              
              const coinId = coinGeckoIds[asset.symbol];
              if (coinId) {
                container.innerHTML = `
                  <div style="background: var(--card-bg); border-radius: 12px; padding: 16px; height: ${CHART_HEIGHT}px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                    <iframe 
                      src="https://www.coingecko.com/en/coins/${coinId}/chart_widget?height=${CHART_HEIGHT - 40}&width=100%" 
                      style="border: none; width: 100%; height: ${CHART_HEIGHT - 40}px; border-radius: 8px;"
                      frameborder="0"
                      scrolling="no"
                    ></iframe>
                    <p style="margin-top: 8px; font-size: 0.85em; color: #94a3b8;">Data from CoinGecko</p>
                  </div>
                `;
                
                // Fetch current price
                fetchCoinGeckoPrice(asset, coinId);
                return;
              }
            } catch (e) {
              console.log('CoinGecko chart error:', e);
            }
          }

          // Third fallback: Use canvas-based chart
          const canvas = document.createElement('canvas');
          canvas.id = 'priceChart';
          canvas.height = CHART_HEIGHT;
          container.appendChild(canvas);
          
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          if (chart) chart.destroy();

          priceHistory = generateOHLC(asset.basePrice);

          // Try Chart.js if available
          if (typeof Chart !== 'undefined') {
            try {
              chart = new Chart(ctx, {
                type: 'candlestick',
                data: {
                  datasets: [{
                    label: asset.symbol,
                    data: priceHistory
                  }, {
                    label: 'Volume',
                    type: 'bar',
                    data: priceHistory.map(d => ({x: d.x, y: d.v || Math.floor(Math.random()*10000)})),
                    yAxisID: 'volume',
                    backgroundColor: 'rgba(59,130,246,0.4)'
                  }]
                },
                options: {
                  scales: {
                    x: { type: 'time', time: { unit: 'minute' }, title: { display: true, text: 'Time' } },
                    y: { title: { display: true, text: 'Price ($)' } },
                    volume: { position: 'right', title: { display: true, text: 'Vol' }, grid: { drawOnChartArea: false } }
                  },
                  plugins: { legend: { display: false } }
                }
              });
            } catch (e) {
              console.log('Chart.js error, using simple chart');
              drawSimpleChart(canvas, ctx, priceHistory, asset);
            }
          } else {
            drawSimpleChart(canvas, ctx, priceHistory, asset);
          }
        }

        // Fetch real-time price from a public API
        async function fetchTradingViewPrice(asset) {
          try {
            // Priority 1: Try Chainlink on-chain price feed (most reliable for supported assets)
            if (asset.symbol && hasChainlinkFeed(asset.symbol)) {
              const chainlinkPrice = await fetchChainlinkPrice(asset.symbol);
              if (chainlinkPrice && chainlinkPrice > 0) {
                updatePriceDisplay(chainlinkPrice);
                
                // Update priceHistory with Chainlink price data
                if (priceHistory.length > 0) {
                  const last = priceHistory[priceHistory.length - 1];
                  const now = Date.now();
                  
                  // Dynamic threshold: 0.1% of current price
                  const changeThreshold = calculatePriceChangeThreshold(last.c);
                  
                  // If price has changed significantly, add new candle with real data
                  if (Math.abs(last.c - chainlinkPrice) > changeThreshold) {
                    priceHistory.push({
                      x: now,
                      o: last.c,
                      h: Math.max(last.c, chainlinkPrice),
                      l: Math.min(last.c, chainlinkPrice),
                      c: chainlinkPrice
                    });
                    
                    if (priceHistory.length > 80) priceHistory.shift();
                    
                    // Update chart if exists
                    if (chart) chart.update();
                    
                    // Update positions display with new price
                    updatePositionsDisplay();
                  }
                } else {
                  // Initialize priceHistory with current Chainlink price
                  priceHistory = generateOHLCFromRealPrice(chainlinkPrice);
                }
                
                console.log(`[Chainlink] Real price for ${asset.symbol}: $${chainlinkPrice.toFixed(2)}`);
                return;
              }
            }
            
            // Priority 2: Use CoinGecko API for real crypto prices (with CORS proxy fallback)
            if (asset.symbol.includes('USD') && currentTab === 'crypto') {
              const symbol = asset.symbol.replace('USD', '').toLowerCase();
              const coinIdMap = {
                'btc': 'bitcoin',
                'eth': 'ethereum',
                'bnb': 'binancecoin',
                'sol': 'solana',
                'xrp': 'ripple',
                'ada': 'cardano',
                'doge': 'dogecoin',
                'matic': 'matic-network',
                'dot': 'polkadot',
                'avax': 'avalanche-2'
              };
              
              const coinId = coinIdMap[symbol] || symbol;
              
              // Try fetch with CORS fallback
              try {
                const data = await fetchWithCORSFallback(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true`);
                
                if (data && data[coinId]) {
                  const price = data[coinId].usd;
                  const change24h = data[coinId].usd_24h_change || 0;
                  
                  updatePriceDisplay(price);
                  
                  // Update priceHistory with real price data
                  if (priceHistory.length > 0) {
                    const last = priceHistory[priceHistory.length - 1];
                    const now = Date.now();
                    
                    // Dynamic threshold: 0.1% of current price
                    const changeThreshold = calculatePriceChangeThreshold(last.c);
                    
                    // If price has changed significantly, add new candle with real data
                    if (Math.abs(last.c - price) > changeThreshold) {
                      priceHistory.push({
                        x: now,
                        o: last.c,
                        h: Math.max(last.c, price),
                        l: Math.min(last.c, price),
                        c: price
                      });
                      
                      if (priceHistory.length > 80) priceHistory.shift();
                      
                      // Update chart if exists
                      if (chart) chart.update();
                      
                      // Update positions display with new price
                      updatePositionsDisplay();
                    }
                  } else {
                    // Initialize priceHistory with current real price
                    priceHistory = generateOHLCFromRealPrice(price);
                  }
                  
                  console.log(`[CoinGecko] Real price for ${asset.symbol}: $${price.toFixed(2)} (24h: ${change24h.toFixed(2)}%)`);
                  return;
                }
              } catch (innerError) {
                console.log(`[TradingView] CoinGecko API error for ${asset.symbol}:`, innerError.message);
                console.log('[TradingView] Falling back to base price');
              }
            }
            
            // Fallback to base price
            updatePriceDisplay(asset.basePrice);
          } catch (error) {
            console.log('Price fetch error:', error);
            updatePriceDisplay(asset.basePrice);
          }
        }
        
        // Helper function to update price display safely
        function updatePriceDisplay(price) {
          const priceEl = document.getElementById('currentPrice');
          if (priceEl) {
            priceEl.textContent = `$${price.toLocaleString()}`;
          }
        }
        
        // Generate initial OHLC data based on real current price
        function generateOHLCFromRealPrice(currentPrice, count = 40) {
          const data = [];
          const now = Date.now();
          
          // Start from slightly lower price and trend towards current
          let price = currentPrice * 0.98;
          const increment = (currentPrice - price) / count;
          
          for (let i = 0; i < count; i++) {
            const open = price;
            const close = price + increment + (Math.random() - 0.5) * (currentPrice * 0.005);
            const high = Math.max(open, close) * (1 + Math.random() * 0.003);
            const low = Math.min(open, close) * (1 - Math.random() * 0.003);
            
            data.push({
              x: now - (count - i - 1) * 600000,
              o: open,
              h: high,
              l: low,
              c: close
            });
            
            price = close;
          }
          
          return data;
        }

        // Fetch price from CoinGecko API with CORS fallback
        async function fetchCoinGeckoPrice(asset, coinId) {
          try {
            const data = await fetchWithCORSFallback(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
            
            if (data && data[coinId]) {
              const price = data[coinId].usd;
              updatePriceDisplay(price);
              return;
            }
            
            // Fallback to base price if no data
            console.log('CoinGecko: No price data available for', coinId);
            updatePriceDisplay(asset.basePrice);
          } catch (error) {
            console.log('CoinGecko price fetch error:', error.message);
            updatePriceDisplay(asset.basePrice);
          }
        }

        function drawSimpleChart(canvas, ctx, data, asset) {
          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Set canvas size
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight || CHART_HEIGHT;
          
          if (data.length === 0) return;
          
          // Find min and max prices
          const prices = data.map(d => d.c);
          const minPrice = Math.min(...prices);
          const maxPrice = Math.max(...prices);
          const priceRange = maxPrice - minPrice || 1;
          
          // Draw background
          ctx.fillStyle = '#1e293b';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw grid
          ctx.strokeStyle = '#334155';
          ctx.lineWidth = 1;
          for (let i = 0; i < 5; i++) {
            const y = (canvas.height / 5) * i;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          }
          
          // Draw price line
          ctx.strokeStyle = '#10b981';
          ctx.lineWidth = 2;
          ctx.beginPath();
          
          data.forEach((point, i) => {
            const x = (canvas.width / (data.length - 1)) * i;
            const y = canvas.height - ((point.c - minPrice) / priceRange) * (canvas.height * 0.9) - (canvas.height * 0.05);
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          });
          ctx.stroke();
          
          // Draw current price
          const lastPrice = data[data.length - 1].c;
          ctx.fillStyle = '#60a5fa';
          ctx.font = '14px Arial';
          ctx.fillText(`${asset.symbol}: $${lastPrice.toFixed(2)}`, 10, 20);
        }

        // Real-time price updates using CoinGecko API
        let priceUpdateInterval = null;
        
        // Helper function to fetch real price for asset initialization
        async function fetchRealPriceForAsset(asset) {
          try {
            // Priority 1: Try Chainlink on-chain price feed
            if (asset.symbol && hasChainlinkFeed(asset.symbol)) {
              const chainlinkPrice = await fetchChainlinkPrice(asset.symbol);
              if (chainlinkPrice && chainlinkPrice > 0) {
                return chainlinkPrice;
              }
            }
            
            // Priority 2: Try CoinGecko API
            if (asset.symbol.includes('USD') && currentTab === 'crypto') {
              const symbol = asset.symbol.replace('USD', '').toLowerCase();
              const coinIdMap = {
                'btc': 'bitcoin',
                'eth': 'ethereum',
                'bnb': 'binancecoin',
                'sol': 'solana',
                'xrp': 'ripple',
                'ada': 'cardano',
                'doge': 'dogecoin',
                'matic': 'matic-network',
                'dot': 'polkadot',
                'avax': 'avalanche-2'
              };
              
              const coinId = coinIdMap[symbol] || symbol;
              const data = await fetchWithCORSFallback(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`);
              
              if (data && data[coinId]) {
                return data[coinId].usd;
              }
            }
          } catch (error) {
            console.log('[Price Fetch] Error:', error);
          }
          return null;
        }
        
        function startRealTimePriceUpdates() {
          if (priceUpdateInterval) {
            clearInterval(priceUpdateInterval);
          }
          
          priceUpdateInterval = setInterval(async () => {
            if (selectedAsset && currentTab !== 'sports' && priceHistory.length > 0) {
              // Fetch real price from TradingView/CoinGecko
              await fetchTradingViewPrice(selectedAsset);
            }
          }, 5000); // Update every 5 seconds with real data
          
          console.log('üîÑ Started real-time price updates (every 5 seconds)');
        }
        
        function stopRealTimePriceUpdates() {
          if (priceUpdateInterval) {
            clearInterval(priceUpdateInterval);
            priceUpdateInterval = null;
            console.log('‚èπÔ∏è Stopped real-time price updates');
          }
        }
        
        // === BINANCE WEBSOCKET INTEGRATION ===
        
        /**
         * Connect to Binance WebSocket for real-time price updates
         * Much faster than polling - updates arrive every ~100ms
         */
        function connectBinanceWebSocket(symbol) {
          // Close existing connection
          disconnectBinanceWebSocket();
          
          // Map our symbols to Binance format
          const binanceSymbolMap = {
            'BTCUSD': 'btcusdt',
            'ETHUSD': 'ethusdt',
            'BNBUSD': 'bnbusdt',
            'SOLUSD': 'solusdt',
            'XRPUSD': 'xrpusdt',
            'ADAUSD': 'adausdt',
            'DOGEUSD': 'dogeusdt',
            'MATICUSD': 'maticusdt',
            'DOTUSD': 'dotusdt',
            'AVAXUSD': 'avaxusdt'
          };
          
          const binanceSymbol = binanceSymbolMap[symbol];
          if (!binanceSymbol) {
            console.log(`[Binance WS] Symbol ${symbol} not supported, falling back to polling`);
            startRealTimePriceUpdates();
            return;
          }
          
          try {
            // Connect to Binance WebSocket Stream
            const wsUrl = `wss://stream.binance.com:9443/ws/${binanceSymbol}@trade`;
            binanceWebSocket = new WebSocket(wsUrl);
            
            binanceWebSocket.onopen = () => {
              console.log(`üîó Connected to Binance WebSocket for ${symbol}`);
              priceUpdateMethod = 'websocket';
            };
            
            binanceWebSocket.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                const price = parseFloat(data.p); // Trade price
                const timestamp = data.T; // Trade time
                
                if (priceHistory.length > 0 && price > 0) {
                  const last = priceHistory[priceHistory.length - 1];
                  
                  // Update if price changed significantly (>0.01%)
                  if (Math.abs(last.c - price) / last.c > 0.0001) {
                    priceHistory.push({
                      x: timestamp,
                      o: last.c,
                      h: Math.max(last.c, price),
                      l: Math.min(last.c, price),
                      c: price
                    });
                    
                    // Keep history manageable
                    if (priceHistory.length > 100) priceHistory.shift();
                    
                    // Update chart
                    if (chart) chart.update();
                    
                    // Update price display
                    const priceEl = document.getElementById('currentPrice');
                    if (priceEl) {
                      priceEl.textContent = `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                      const change = price - last.c;
                      priceEl.style.color = change >= 0 ? '#10b981' : '#ef4444';
                    }
                    
                    // Update positions display
                    updatePositionsDisplay();
                  }
                }
              } catch (error) {
                console.error('[Binance WS] Parse error:', error);
              }
            };
            
            binanceWebSocket.onerror = (error) => {
              console.error('[Binance WS] Error:', error);
              // Fallback to polling
              disconnectBinanceWebSocket();
              startRealTimePriceUpdates();
            };
            
            binanceWebSocket.onclose = () => {
              console.log('[Binance WS] Connection closed');
              binanceWebSocket = null;
            };
            
          } catch (error) {
            console.error('[Binance WS] Connection error:', error);
            // Fallback to polling
            startRealTimePriceUpdates();
          }
        }
        
        /**
         * Disconnect from Binance WebSocket
         */
        function disconnectBinanceWebSocket() {
          if (binanceWebSocket) {
            try {
              binanceWebSocket.close();
              console.log('üîå Disconnected from Binance WebSocket');
            } catch (error) {
              console.error('[Binance WS] Disconnect error:', error);
            }
            binanceWebSocket = null;
          }
          priceUpdateMethod = 'polling';
        }
        
        /**
         * Connect to OKX WebSocket (alternative exchange)
         */
        function connectOKXWebSocket(symbol) {
          // OKX WebSocket implementation
          // Similar structure to Binance but uses OKX's format
          // wss://ws.okx.com:8443/ws/v5/public
          console.log('[OKX WS] Not implemented yet, using Binance');
          connectBinanceWebSocket(symbol);
        }

        function placeBet(direction) {
          if (!selectedAsset) return showNotification("Select first!", true);
          currentBet = { asset: selectedAsset.symbol, direction, odds: parseFloat(document.getElementById('betOdds').value) || 2.2 };
          document.getElementById('betStatus').textContent = `Bet: ${direction.toUpperCase()} on ${selectedAsset.symbol}`;
        }

        function confirmBet() {
          const amt = parseFloat(document.getElementById('betAmount').value);
          if (!currentBet || isNaN(amt) || amt < 10) return showNotification("Min 10 MOGA", true);
          if (amt > mogalandPoints) return showNotification("Not enough!", true);

          mogalandPoints -= amt;
          
          // Save updated points to localStorage
          saveMogalandPoints();

          let timeLeft = 10;
          document.getElementById('timerDisplay').textContent = `Result in ${timeLeft}s`;
          const interval = setInterval(() => {
            timeLeft--;
            document.getElementById('timerDisplay').textContent = timeLeft > 0 ? `Result in ${timeLeft}s` : '';
            if (timeLeft <= 0) {
              clearInterval(interval);
              const win = Math.random() > 0.5;
              if (win) {
                const profit = Math.round(amt * (currentBet.odds - 1));
                mogalandPoints += amt + profit;
                
                // Save updated points to localStorage
                saveMogalandPoints();
                
                showNotification(`WIN! +${profit} MOGA`, false);
              } else {
                showNotification(`LOSE -${amt} MOGA`, true);
              }
              document.getElementById('timerDisplay').textContent = '';
            }
          }, 1000);
        }

        renderAssets();
        if (assetsData.crypto.length > 0) selectAsset(assetsData.crypto[0]);
        updateTradingBalance();
        updatePositionsDisplay();
        updateTradeHistory();

        // Add event listeners for leverage calculation
        const positionInput = document.getElementById('positionAmount');
        const leverageSelect = document.getElementById('leverageSelect');
        if (positionInput) positionInput.addEventListener('input', updateLeverageInfo);
        if (leverageSelect) leverageSelect.addEventListener('change', updateLeverageInfo);

        document.querySelectorAll('[data-tab]').forEach(btn => {
          btn.onclick = () => {
            document.querySelectorAll('[data-tab]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentTab = btn.dataset.tab;
            renderAssets();
            selectedAsset = null;
            document.getElementById('selectedAsset').textContent = 'None';
            document.getElementById('viewTitle').textContent = currentTab === 'sports' ? 'Select Team to View History' : 'Select Asset to Trade';
            document.getElementById('priceChart').style.display = 'none';
            document.getElementById('clubHistoryView').style.display = 'none';
            document.getElementById('currentPriceDisplay').style.display = 'none';
            document.getElementById('chartFooter').style.display = 'none';
            if (chart) chart.destroy();
            chart = null;
          };
        });
      } 
      else if (id === 'swap') {
        content.innerHTML = `
          <div style="max-width: 480px; margin: 40px auto; padding: 0 12px;">
            <h2 style="text-align: center; color: #60a5fa; font-size: 1.8em; margin-bottom: 24px; font-weight: 600;">
              Swap on Sepolia
            </h2>

            ${!userAddress ? `
              <div style="background: rgba(220,53,69,0.12); border: 1px solid #dc3545; color: #ffcccc; padding: 12px; border-radius: 10px; margin-bottom: 20px; text-align: center; font-size: 0.95em;">
                Connect wallet to swap on Sepolia testnet
              </div>
            ` : ''}

            <div style="padding: 20px; border-radius: 16px; background: var(--card-bg); border: 1px solid var(--border); box-shadow: 0 4px 16px rgba(0,0,0,0.3); margin-bottom: 20px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <select id="fromTokenSelect" onchange="updateSwapEstimate(); updateSelectedTokenBalance();" style="padding: 8px; background: var(--darker); border: 1px solid var(--border); border-radius: 8px; color: white; font-size: 1em;">
                  <option value="ETH">ETH Sepolia</option>
                  <option value="USDC">USDC Sepolia</option>
                  <option value="USDT">USDT Sepolia</option>
                  <option value="LINK">LINK Sepolia</option>
                  <option value="WBTC">WBTC Sepolia</option>
                  <option value="AAVE">AAVE Sepolia</option>
                  <option value="EURO">EURO Sepolia</option>
                </select>

                <button onclick="toggleSwapDirection()" style="background: #0d6efd; width: 48px; height: 48px; border-radius: 50%; border: none; font-size: 1.5em; color: white; cursor: pointer; box-shadow: 0 4px 12px rgba(13,110,253,0.4); transition: transform 0.2s;">
                  ‚Üî
                </button>

                <select id="toTokenSelect" onchange="updateSwapEstimate()" style="padding: 8px; background: var(--darker); border: 1px solid var(--border); border-radius: 8px; color: white; font-size: 1em;">
                  <option value="USDC">USDC Sepolia</option>
                  <option value="ETH">ETH Sepolia</option>
                  <option value="USDT">USDT Sepolia</option>
                  <option value="LINK">LINK Sepolia</option>
                  <option value="WBTC">WBTC Sepolia</option>
                  <option value="AAVE">AAVE Sepolia</option>
                  <option value="EURO">EURO Sepolia</option>
                </select>
              </div>

              <input id="fromInput" type="number" placeholder="0.0" min="0" step="any" style="width: 100%; font-size: 2.4em; font-weight: 500; background: transparent; border: none; color: white; text-align: right; outline: none;" oninput="updateSwapEstimate()" />

              <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 0.9em; color: #94a3b8;">
                <span>Balance: <strong id="plumeBalance" style="color: white;">Loading...</strong></span>
                <span>~$<span id="fromUSD">0.00</span></span>
              </div>
            </div>

            <div id="swapEstimate" style="margin: 16px 0; padding: 10px; background: rgba(16,185,129,0.08); border-radius: 10px; font-size: 1em; color: #10b981; text-align: center;">
              Estimasi: 0.00 (1 ETH ‚âà 2000 USDC)
            </div>

            <div style="margin: 24px 0; padding: 14px; background: rgba(13,110,253,0.08); border-radius: 14px; border: 1px solid var(--border);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <label style="font-size: 1em; color: #60a5fa;">Slippage Tolerance</label>
                <span id="currentSlippage" style="font-weight: bold; color: #10b981; font-size: 1em;">0.5%</span>
              </div>
              <div style="display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;">
                <button class="slippage-chip" data-value="0.1" onclick="setSlippage(0.1)">0.1%</button>
                <button class="slippage-chip active" data-value="0.5" onclick="setSlippage(0.5)">0.5%</button>
                <button class="slippage-chip" data-value="1.0" onclick="setSlippage(1.0)">1.0%</button>
                <button class="slippage-chip" data-value="2.0" onclick="setSlippage(2.0)">2.0%</button>
                <input id="customSlippage" type="number" placeholder="Custom" min="0" max="10" step="0.1" style="width: 80px; padding: 8px; background: var(--darker); border: 1px solid var(--border); border-radius: 10px; color: white; text-align: center; font-size: 0.9em;" onchange="setSlippage(this.value)" />
              </div>
              <p id="slippageWarning" style="margin-top: 10px; font-size: 0.85em; color: #ffcc00; text-align: center; display: none;">
                High slippage may result in unfavorable rates
              </p>
            </div>

            <button class="btn-primary" style="width: 100%; padding: 16px; font-size: 1.25em; border-radius: 14px;" onclick="confirmSwap()">
              Swap Now
            </button>
            
            <p style="text-align: center; margin-top: 12px; color: #f59e0b; font-size: 0.85em;">
              ‚õΩ Gas Fee: ${GAS_FEE_ETH} ${getNetworkCurrency()} per swap
            </p>

            <p style="text-align: center; margin-top: 12px; color: #94a3b8; font-size: 0.9em;">
              ${getActiveNetwork().name} ‚Ä¢ ${getNetworkCurrency()} ‚Üî USDC/USDT/LINK/WBTC/AAVE/EURO ‚Ä¢ Demo Mode
            </p>
          </div>
        `;

        setTimeout(() => {
          if (userAddress) {
            updateTokenBalances();
            updateSelectedTokenBalance();
          }
          updateSwapEstimate();
          setSlippage(0.5);
        }, 100);
      }
      else if (id === 'bridge') {
        content.innerHTML = `
          <div style="max-width: 520px; margin: 60px auto 140px; padding: 0 16px;">
            <h2 style="text-align: center; color: #60a5fa; font-size: 2.4em; margin-bottom: 16px; font-weight: 600;">
              Bridge Assets
            </h2>
            <p style="text-align: center; color: #94a3b8; margin-bottom: 32px; font-size: 1.1em;">
              Transfer tokens between Ethereum Testnets to Sepolia
            </p>

            <div style="background: #13151f; border: 1px solid #1e2130; border-radius: 24px; padding: 32px 24px; box-shadow: 0 12px 48px rgba(0,0,0,0.7);">
              <div style="margin-bottom: 32px;">
                <label style="display: block; color: #94a3b8; font-size: 1em; margin-bottom: 10px; font-weight: 500;">From Network</label>
                <div style="background: #1e2130; border-radius: 16px; padding: 20px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 12px;">
                    <select id="fromChain" onchange="updateBridgeEstimate()" style="background: #2a2f45; color: white; font-size: 1.2em; border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; min-width: 180px; cursor: pointer;">
                      <option value="goerli">Goerli Testnet</option>
                      <option value="holesky">Holesky Testnet</option>
                      <option value="mumbai">Mumbai (Polygon)</option>
                      <option value="bsc-testnet">BSC Testnet</option>
                    </select>
                    <span style="color: #94a3b8; font-size: 0.95em;">Balance: <span id="fromBalance">0.00</span></span>
                  </div>
                  <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px;">
                    <input type="number" id="bridgeAmount" placeholder="0.00" oninput="updateBridgeEstimate()" style="background: transparent; border: none; color: white; font-size: 3em; font-weight: 600; flex: 1; min-width: 120px; outline: none;" />
                    <select id="bridgeToken" onchange="updateBridgeEstimate()" style="background: #2a2f45; color: white; border: none; padding: 12px 16px; border-radius: 14px; font-size: 1.15em; cursor: pointer; min-width: 140px;">
                      <option value="USDT">USDT</option>
                      <option value="USDC">USDC</option>
                      <option value="ETH">ETH</option>
                    </select>
                  </div>
                  <div style="text-align: right; color: #94a3b8; font-size: 0.95em; margin-top: 8px;">~$<span id="fromUSDValue">0.00</span></div>
                </div>
              </div>

              <div style="display: flex; justify-content: center; margin: 28px 0;">
                <button id="swapChainsBtn" onclick="swapBridgeChains()" style="background: #1e2130; border: 4px solid #13151f; border-radius: 50%; width: 68px; height: 68px; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                  <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="#ec4899" stroke-width="2.8">
                    <path d="M19 14l-7 7m0 0l-7-7m7 7V3" />
                  </svg>
                </button>
              </div>

              <div style="margin-bottom: 32px;">
                <label style="display: block; color: #94a3b8; font-size: 1em; margin-bottom: 10px; font-weight: 500;">To Network</label>
                <div style="background: #1e2130; border-radius: 16px; padding: 20px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 12px;">
                    <select id="toChain" onchange="updateBridgeEstimate()" style="background: #2a2f45; color: white; font-size: 1.2em; border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; min-width: 180px; cursor: pointer;">
                      <option value="sepolia" selected>Sepolia Testnet</option>
                    </select>
                    <span style="color: #94a3b8; font-size: 0.95em;">Balance: <span id="toBalance">0.00</span></span>
                  </div>
                  <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px;">
                    <input type="number" id="bridgeReceiveAmount" placeholder="0.00" disabled style="background: transparent; border: none; color: #6b7280; font-size: 3em; font-weight: 600; flex: 1; min-width: 120px; outline: none;" />
                    <select disabled style="background: #2a2f45; color: white; border: none; padding: 12px 16px; border-radius: 14px; font-size: 1.15em; cursor: not-allowed; min-width: 140px;">
                      <option id="receiveToken">USDT</option>
                    </select>
                  </div>
                  <div style="text-align: right; color: #94a3b8; font-size: 0.95em; margin-top: 8px;">~$<span id="toUSDValue">0.00</span></div>
                </div>
              </div>

              <div style="margin: 24px 0; padding: 14px; background: rgba(13,110,253,0.08); border-radius: 14px; border: 1px solid var(--border);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                  <label style="font-size: 1em; color: #60a5fa;">Slippage Tolerance</label>
                  <span id="bridgeSlippage" style="font-weight: bold; color: #10b981; font-size: 1em;">0.5%</span>
                </div>
                <div style="display: flex; gap: 6px; flex-wrap: wrap; justify-content: center;">
                  <button class="slippage-chip" data-value="0.1" onclick="setBridgeSlippage(0.1)">0.1%</button>
                  <button class="slippage-chip active" data-value="0.5" onclick="setBridgeSlippage(0.5)">0.5%</button>
                  <button class="slippage-chip" data-value="1.0" onclick="setBridgeSlippage(1.0)">1.0%</button>
                  <button class="slippage-chip" data-value="2.0" onclick="setBridgeSlippage(2.0)">2.0%</button>
                </div>
              </div>

              <div style="background: rgba(236,72,153,0.08); border-radius: 14px; padding: 16px; margin-bottom: 28px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px; color: #94a3b8;">
                  <span>Estimated Fee</span>
                  <span id="bridgeFee">~$3.50 ‚Äì $8.00</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px; color: #94a3b8;">
                  <span>Estimated Time</span>
                  <span>~1-8 minutes</span>
                </div>
                <div style="display: flex; justify-content: space-between; color: #94a3b8;">
                  <span>You will receive (after slippage)</span>
                  <span id="receiveAfterSlippage">0.00</span>
                </div>
              </div>

              <button class="btn-primary" style="width: 100%; padding: 20px; font-size: 1.35em; border-radius: 16px;" onclick="confirmBridge()">
                Bridge Now
              </button>
              
              <p style="text-align: center; margin-top: 12px; color: #f59e0b; font-size: 0.9em;">
                ‚õΩ Gas Fee: ${GAS_FEE_ETH} ${getNetworkCurrency()} per bridge transaction
              </p>

              <p style="text-align: center; margin-top: 12px; color: #94a3b8; font-size: 0.95em;">
                Testnet Bridge Simulator ‚Ä¢ Real bridges support CCTP, LayerZero, etc.
              </p>
            </div>
          </div>
        `;

        // Initialize bridge functions
        window.updateBridgeEstimate = function() {
          const amount = parseFloat(document.getElementById('bridgeAmount')?.value || 0);
          const token = document.getElementById('bridgeToken')?.value || 'USDT';
          const slippage = parseFloat(document.getElementById('bridgeSlippage')?.textContent || '0.5');
          
          const receiveAmount = amount * (1 - slippage / 100);
          document.getElementById('bridgeReceiveAmount').value = receiveAmount.toFixed(6);
          document.getElementById('receiveAfterSlippage').textContent = `${receiveAmount.toFixed(6)} ${token}`;
          document.getElementById('fromUSDValue').textContent = amount.toFixed(2);
          document.getElementById('toUSDValue').textContent = receiveAmount.toFixed(2);
          document.getElementById('receiveToken').textContent = token;
        };

        window.swapBridgeChains = function() {
          showNotification("Destination is always Sepolia for this bridge", false);
        };

        window.setBridgeSlippage = function(value) {
          document.querySelectorAll('.slippage-chip').forEach(btn => btn.classList.remove('active'));
          document.querySelector(`[data-value="${value}"]`)?.classList.add('active');
          document.getElementById('bridgeSlippage').textContent = `${value}%`;
          updateBridgeEstimate();
        };

        window.confirmBridge = async function() {
          // Check wallet connection FIRST
          if (!userAddress || !provider) {
            showNotification("‚ö†Ô∏è Please connect wallet first!", true);
            connectWalletFromApp();
            return;
          }
          
          const amount = parseFloat(document.getElementById('bridgeAmount')?.value || 0);
          const fromChainSelect = document.getElementById('fromChain');
          const fromChain = fromChainSelect?.options[fromChainSelect?.selectedIndex]?.text || 'Goerli';
          const token = document.getElementById('bridgeToken')?.value || 'USDT';
          const slippage = parseFloat(document.getElementById('bridgeSlippage')?.textContent || '0.5');
          
          if (amount <= 0) {
            showNotification('Please enter an amount to bridge', true);
            return;
          }
          
          try {
            // Execute real bridge transaction
            showNotification(`üåâ Preparing bridge: ${amount} ${token} from ${fromChain} to ${getActiveNetwork().name}...`, false);
            
            const result = await executeRealBridge(fromChain, getActiveNetwork().name, token, amount, slippage);
            
            if (result.success) {
              recordTransaction(result.txHash, 'Bridge', `Bridged ${amount.toFixed(6)} ${token} from ${fromChain} to ${getActiveNetwork().name}`, {amount: amount, token: token});
              showNotification(
                `‚úÖ Bridge successful!<br>${amount.toFixed(6)} ${token} from ${fromChain} to ${getActiveNetwork().name}<br>Received: ${result.finalAmount.toFixed(6)} ${token}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${result.txHash}" target="_blank" style="color:#60a5fa;">${result.txHash.slice(0, 10)}...</a>`,
                false
              );
              
              console.log(`[Bridge] Real transaction completed: ${amount} ${token} from ${fromChain} to ${getActiveNetwork().name}`);
              console.log(`[Bridge] Transaction hash: ${result.txHash}`);
              
              // Refresh balances
              setTimeout(() => {
                fetchAndDisplayBalances();
              }, 2000);
            }
          } catch (error) {
            console.error('[Bridge] Error:', error);
            showNotification(`‚ùå Bridge failed: ${error.message}`, true);
          }
        };

        setBridgeSlippage(0.5);
      }
      else if (id === 'nft') {
        loadUserNFTs(); // Load NFTs from wallet
        content.innerHTML = `
          <h2 style="text-align:center; margin:40px 0; color:#60a5fa;">NFT Staking</h2>
          <p style="text-align:center; font-size:1.2em; color:#94a3b8; margin-bottom:16px;">
            Stake your Mogaland NFTs and earn rewards on ${getActiveNetwork().name}
          </p>
          <p style="text-align:center; font-size:0.9em; color:#64748b; margin-bottom:8px;">
            NFT Contract (${getActiveNetwork().name}): <span style="color:#60a5fa; font-family:monospace;">${NFT_CONTRACT_ADDRESS}</span> | 
            <a href="${getActiveNetwork().explorer}/address/${NFT_CONTRACT_ADDRESS}" target="_blank" style="color:#60a5fa;">View on Explorer</a>
          </p>
          <p style="text-align:center; font-size:0.9em; color:#64748b; margin-bottom:8px;">
            Collection Owner: <span style="color:#10b981; font-family:monospace;">${TREASURY_WALLET_ADDRESS.slice(0,8)}...${TREASURY_WALLET_ADDRESS.slice(-6)}</span> | 
            <a href="${getActiveNetwork().explorer}/address/${TREASURY_WALLET_ADDRESS}" target="_blank" style="color:#60a5fa;">View Treasury</a>
          </p>

          <!-- OpenSea Marketplace Integration -->
          <div style="background:linear-gradient(135deg,rgba(37,99,235,0.1),rgba(139,92,246,0.1)); border:1px solid rgba(59,130,246,0.3); border-radius:16px; padding:24px; margin:20px 0; text-align:center;">
            <h3 style="color:#60a5fa; margin-bottom:16px;">üåä OpenSea Marketplace</h3>
            <p style="color:#94a3b8; margin-bottom:20px; font-size:0.95em;">
              Trade Mogaland NFTs on OpenSea Testnet ‚Ä¢ All sales proceeds go to treasury
            </p>
            <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
              <a href="https://testnets.opensea.io/assets/sepolia/${NFT_CONTRACT_ADDRESS}" target="_blank" 
                 style="background:linear-gradient(90deg,#2563eb,#1e40af); color:white; padding:12px 24px; border-radius:10px; text-decoration:none; font-weight:600; display:inline-flex; align-items:center; gap:8px; transition:all 0.3s;">
                üì¶ View Collection
              </a>
              <a href="https://testnets.opensea.io/${TREASURY_WALLET_ADDRESS}" target="_blank"
                 style="background:linear-gradient(90deg,#8b5cf6,#7c3aed); color:white; padding:12px 24px; border-radius:10px; text-decoration:none; font-weight:600; display:inline-flex; align-items:center; gap:8px; transition:all 0.3s;">
                üè™ Treasury Marketplace
              </a>
              <button onclick="openListNFTModal()" 
                      style="background:linear-gradient(90deg,#10b981,#059669); color:white; padding:12px 24px; border-radius:10px; border:none; font-weight:600; cursor:pointer; display:inline-flex; align-items:center; gap:8px; transition:all 0.3s;">
                üè∑Ô∏è List Your NFT
              </button>
            </div>
            <div style="margin-top:16px; padding-top:16px; border-top:1px solid rgba(255,255,255,0.1);">
              <div style="display:flex; gap:24px; justify-content:center; font-size:0.9em; color:#94a3b8;">
                <div>
                  <span style="color:#60a5fa;">Collection:</span> Mogaland NFTs
                </div>
                <div>
                  <span style="color:#60a5fa;">Network:</span> ${getActiveNetwork().name}
                </div>
                <div>
                  <span style="color:#60a5fa;">Royalty:</span> 5% to Treasury
                </div>
              </div>
            </div>
          </div>

          <div class="stats-grid">
            <div class="stats-card">
              <h4>Your NFTs</h4>
              <div class="stats-value" style="color:#60a5fa;">${userNFTs.length + mintedNFTs.length}</div>
            </div>
            <div class="stats-card">
              <h4>Staked NFTs</h4>
              <div class="stats-value" style="color:#10b981;">${stakedNFTsData.length}</div>
            </div>
            <div class="stats-card">
              <h4>Total Claimable</h4>
              <div class="stats-value" style="color:#fbbf24;">${(calculateTotalRewards() + (volumeRewardsClaimable || 0) + (mogalandPoints * LEARNING_POINTS_TO_USDC_RATE)).toFixed(4)} USDC</div>
              <div style="font-size:0.75em; color:#94a3b8; margin-top:4px;">
                ${calculateTotalRewards().toFixed(4)} NFT + ${(volumeRewardsClaimable || 0).toFixed(4)} Volume + ${(mogalandPoints * LEARNING_POINTS_TO_USDC_RATE).toFixed(4)} Points
              </div>
            </div>
            <div class="stats-card">
              <h4>Trading Volume</h4>
              <div class="stats-value" style="color:#c084fc;">${(userTradingVolume.total || 0).toFixed(2)} USDC</div>
            </div>
          </div>

          ${!walletConnected && loginMethod !== 'wallet' ? `
            <div style="background:rgba(239,68,68,0.1); border:1px solid #ef4444; border-radius:12px; padding:20px; margin:20px 0; text-align:center;">
              <p style="color:#ef4444; font-size:1.1em; margin-bottom:12px;">‚ö†Ô∏è Wallet Not Connected</p>
              <p style="color:#94a3b8; margin-bottom:16px;">Connect your wallet to interact with NFTs</p>
              <button class="btn-primary" onclick="connectWalletFromApp()">Connect Wallet</button>
            </div>
          ` : ''}

          <div style="display:flex; justify-content:space-between; align-items:center; margin:32px 0 16px;">
            <h3 style="color:#60a5fa;">Available NFTs (${userNFTs.length + mintedNFTs.length})</h3>
            ${mogalandPoints >= 1000 ? `
              <button class="btn-primary" style="background:linear-gradient(90deg,#c084fc,#a855f7);" onclick="redeemPointsForUSDC()">
                üéÅ Redeem ${mogalandPoints} Points ‚Üí ${(mogalandPoints/1000).toFixed(2)} USDC
              </button>
            ` : `
              <span style="color:#64748b;">Need 1000+ points to redeem</span>
            `}
          </div>
          
          <div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(240px, 1fr)); gap:20px; margin-bottom:60px;">
            ${generateNFTCardsFromWallet(false)}
          </div>

          <h3 style="color:#60a5fa; margin:32px 0 16px;">Staked NFTs (${stakedNFTsData.length})</h3>
          <div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(240px, 1fr)); gap:20px;">
            ${generateNFTCardsFromWallet(true)}
          </div>

          <div style="position:fixed; bottom:90px; left:50%; transform:translateX(-50%); background:rgba(15,23,42,0.95); backdrop-filter:blur(10px); border:1px solid var(--border); border-radius:60px; padding:12px 32px; display:flex; gap:16px; z-index:90; box-shadow:0 8px 30px rgba(0,0,0,0.6);">
            <button class="btn-primary" style="padding:14px 28px;" onclick="stakeSelectedNFTs()">Stake Selected</button>
            <button class="btn-primary" style="background:linear-gradient(90deg,var(--danger),#f87171); padding:14px 28px;" onclick="unstakeSelectedNFTs()">Unstake</button>
            <button class="btn-primary" style="background:linear-gradient(90deg,#10b981,#34d399); padding:14px 28px;" onclick="claimAllRewards()">Claim Rewards</button>
          </div>
          
          <p style="text-align:center; margin-top:40px; color:#64748b; font-size:0.9em;">
            ‚õΩ Gas Fee: ${GAS_FEE_ETH} ${getNetworkCurrency()} per transaction | APY varies by NFT rarity
          </p>
        `;} else {
        content.innerHTML = `
          <h2 style="text-align:center; margin:40px 0;">${id.charAt(0).toUpperCase() + id.slice(1)}</h2>
          <p style="text-align:center; font-size:1.2em;">Coming soon ‚Äì ${id} simulator in progress üöß</p>
        `;
      }
    }

    // NFT Staking functions
    function generateNFTCards(count, isStaked = false) {
      let html = '';
      for (let i = 1; i <= count; i++) {
        const id = isStaked ? i + 100 : i;
        const rarity = ['Common', 'Rare', 'Epic', 'Legendary'][Math.floor(Math.random() * 4)];
        html += `
          <div class="nft-card" style="border: 2px solid ${isStaked ? '#10b981' : 'var(--border)'}; ${selectedNFTs.has(id) ? 'border-color:#60a5fa; transform:scale(1.04);' : ''}">
            ${isStaked ? '<div class="nft-staked-badge">STAKED</div>' : ''}
            <div class="nft-image-placeholder">MOGA #${String(id).padStart(4, '0')}</div>
            <div style="padding:16px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                <div style="font-weight:bold;">MOGA #${String(id).padStart(4,'0')}</div>
                <div style="color:#c084fc;">${rarity}</div>
              </div>
              <button class="btn-primary" style="${isStaked ? 'background:linear-gradient(90deg,var(--danger),#f87171);' : ''}" onclick="toggleSelectNFT(${id})">
                ${selectedNFTs.has(id) ? (isStaked ? 'Deselect' : 'Selected') : (isStaked ? 'Select to Unstake' : 'Select to Stake')}
              </button>
            </div>
          </div>
        `;
      }
      return html;
    }

    window.toggleSelectNFT = function(id) {
      if (selectedNFTs.has(id)) selectedNFTs.delete(id);
      else selectedNFTs.add(id);
      showSection('nft');
      showNotification(selectedNFTs.has(id) ? `NFT #${id} dipilih` : `NFT #${id} dibatalkan`, false);
    }

    window.stakeSelectedNFTs = async function() {
      if (selectedNFTs.size === 0) return showNotification("No NFTs selected!", true);
      
      // Check and process gas fee before staking
      if (!await processGasFee('NFT staking')) {
        return;
      }
      
      const count = selectedNFTs.size;
      stakedNFTs += count;
      nftRewards += count * 2.5;
      selectedNFTs.clear();
      showSection('nft');
      showNotification(`‚úÖ Successfully staked ${count} NFT(s) | Gas: ${GAS_FEE_ETH} ${getNetworkCurrency()}`);
      console.log(`[NFT] Staked ${count} NFTs with gas fee`);
    }

    window.unstakeSelectedNFTs = async function() {
      if (selectedNFTs.size === 0) return showNotification("No staked NFTs selected!", true);
      
      // Check and process gas fee before unstaking
      if (!await processGasFee('NFT unstaking')) {
        return;
      }
      
      const count = selectedNFTs.size;
      stakedNFTs = Math.max(0, stakedNFTs - count);
      selectedNFTs.clear();
      showSection('nft');
      showNotification(`‚úÖ Successfully unstaked ${count} NFT(s) | Gas: ${GAS_FEE_ETH} ${getNetworkCurrency()}`);
      console.log(`[NFT] Unstaked ${count} NFTs with gas fee`);
    }

    async function claimNFTRewards() {
      if (nftRewards <= 0) return showNotification("No rewards available", true);
      
      // Check and process gas fee before claiming
      if (!await processGasFee('NFT rewards claim')) {
        return;
      }
      
      const claimed = nftRewards;
      nftRewards = 0;
      
      // Reset staking times for all staked NFTs to prevent reward recalculation
      const now = Date.now();
      stakedNFTsData.forEach(nft => {
        nft.stakedTime = now;
      });
      
      // Save updated staking data to localStorage
      if (userAddress) {
        localStorage.setItem(`stakedNFTs_${userAddress}`, JSON.stringify(stakedNFTsData));
      }
      
      showSection('nft');
      showNotification(`‚úÖ Claimed ${claimed.toFixed(2)} PLUME rewards | Gas: ${GAS_FEE_ETH} ${getNetworkCurrency()}`);
      console.log(`[NFT] Claimed ${claimed.toFixed(2)} PLUME rewards with gas fee. Reset staking times for ${stakedNFTsData.length} NFTs.`);
    }

    // === NFT Web3 Integration Functions ===
    
    async function loadUserNFTs() {
      if (!provider || !userAddress) {
        console.log('[NFT] No wallet connected, using demo NFTs');
        userNFTs = []; // Clear NFTs when not connected
        showNotification("üí° Connect wallet to load your NFTs", false);
        return;
      }
      
      try {
        showNotification("üîÑ Loading your NFTs...", false);
        
        // Check if contract exists by testing code at address
        const code = await provider.getCode(NFT_CONTRACT_ADDRESS);
        if (code === '0x') {
          console.log('[NFT] Contract not deployed at this address');
          userNFTs = [];
          showNotification("üì¶ NFT contract not deployed yet. Complete learning to mint your first NFT!", false);
          return;
        }
        
        const nftContract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, provider);
        
        // Try to get balance with better error handling
        let balance;
        try {
          balance = await nftContract.balanceOf(userAddress);
        } catch (balanceError) {
          console.log('[NFT] balanceOf call failed:', balanceError.message);
          userNFTs = [];
          showNotification("üì¶ No NFTs found or contract not compatible. Complete learning to mint!", false);
          return;
        }
        
        userNFTs = [];
        const balanceNum = balance.toNumber();
        
        if (balanceNum === 0) {
          showNotification("üì¶ No NFTs found. Complete learning to mint your first NFT!", false);
          return;
        }
        
        for (let i = 0; i < balanceNum; i++) {
          try {
            const tokenId = await nftContract.tokenOfOwnerByIndex(userAddress, i);
            const tokenURI = await nftContract.tokenURI(tokenId);
            userNFTs.push({
              id: tokenId.toString(),
              uri: tokenURI,
              rarity: getRarityFromTokenId(tokenId.toNumber()),
              apy: nftAPYs[getRarityFromTokenId(tokenId.toNumber())]
            });
          } catch (tokenError) {
            console.log(`[NFT] Error loading token ${i}:`, tokenError.message);
          }
        }
        
        console.log(`[NFT] Loaded ${userNFTs.length} NFTs from wallet`);
        if (userNFTs.length > 0) {
          showNotification(`‚úÖ Loaded ${userNFTs.length} NFT(s) from your wallet`, false);
        } else {
          showNotification("üì¶ No NFTs found. Complete learning to mint your first NFT!", false);
        }
      } catch (error) {
        console.error('[NFT] Error loading NFTs:', error);
        userNFTs = [];
        // More user-friendly error message
        showNotification("üí° NFT loading skipped. Connect wallet and complete learning to mint NFTs!", false);
      }
    }
    
    function getRarityFromTokenId(tokenId) {
      const mod = tokenId % 100;
      if (mod < 50) return 'Common';
      if (mod < 80) return 'Rare';
      if (mod < 95) return 'Epic';
      return 'Legendary';
    }
    
    function generateNFTCardsFromWallet(isStaked) {
      let html = '';
      const nftsToShow = isStaked ? stakedNFTsData : [...userNFTs, ...mintedNFTs];
      
      if (nftsToShow.length === 0) {
        return `<div style="grid-column:1/-1; text-align:center; padding:40px; color:#64748b;">
          ${isStaked ? 'No staked NFTs' : 'No NFTs available. Complete 100 learning tasks to mint your first NFT!'}
        </div>`;
      }
      
      nftsToShow.forEach((nft, index) => {
        const nftId = isStaked ? nft.nftId : (nft.id || index);
        const rarity = isStaked ? nft.rarity : (nft.rarity || 'Common');
        const apy = isStaked ? nft.apy : (nft.apy || nftAPYs[rarity]);
        const rewards = isStaked ? calculateNFTRewards(nft) : 0;
        
        html += `
          <div class="nft-card" style="border: 2px solid ${isStaked ? '#10b981' : 'var(--border)'}; ${selectedNFTs.has(nftId) ? 'border-color:#60a5fa; transform:scale(1.04);' : ''}">
            ${isStaked ? '<div class="nft-staked-badge">STAKED</div>' : ''}
            <div class="nft-image-placeholder">
              MOGA #${String(nftId).padStart(4, '0')}
              ${isStaked ? `<div style="font-size:0.7em; margin-top:4px; color:#10b981;">+${apy}% APY</div>` : ''}
            </div>
            <div style="padding:16px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                <div style="font-weight:bold;">MOGA #${String(nftId).padStart(4,'0')}</div>
                <div style="color:#c084fc;">${rarity}</div>
              </div>
              ${isStaked ? `
                <div style="font-size:0.85em; color:#10b981; margin-bottom:8px;">
                  üìà Rewards: ${rewards.toFixed(4)} USDC
                </div>
              ` : `
                <div style="font-size:0.85em; color:#60a5fa; margin-bottom:8px;">
                  APY: ${apy}%
                </div>
              `}
              <button class="btn-primary" style="${isStaked ? 'background:linear-gradient(90deg,var(--danger),#f87171);' : ''}" onclick="toggleSelectNFT('${nftId}')">
                ${selectedNFTs.has(nftId) ? (isStaked ? 'Deselect' : 'Selected ‚úì') : (isStaked ? 'Select to Unstake' : 'Select to Stake')}
              </button>
            </div>
          </div>
        `;
      });
      
      return html;
    }
    
    function calculateNFTRewards(stakedNFT) {
      const now = Date.now();
      const stakedDuration = (now - stakedNFT.stakedTime) / (1000 * 60 * 60 * 24); // days
      const dailyRate = stakedNFT.apy / 365 / 100; // Daily rate from APY
      const baseAmount = 100; // Assume 100 USDC equivalent staked value per NFT
      return stakedDuration * dailyRate * baseAmount;
    }
    
    function calculateTotalRewards() {
      let total = 0;
      stakedNFTsData.forEach(nft => {
        total += calculateNFTRewards(nft);
      });
      return total;
    }
    
    async function stakeSelectedNFTs() {
      if (selectedNFTs.size === 0) return showNotification("No NFTs selected!", true);
      
      // Proper wallet validation
      if (!userAddress || !provider) {
        showNotification("‚ö†Ô∏è Please connect your wallet to stake NFTs!", true);
        connectWalletFromApp();
        return;
      }
      
      try {
        const nftCount = selectedNFTs.size;
        const selectedArray = Array.from(selectedNFTs);
        
        showNotification(`üîÑ Preparing to stake ${nftCount} NFT(s)...`, false);
        
        const signer = provider.getSigner();
        const nftContract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, signer);
        
        // In a real implementation, we would:
        // 1. Approve staking contract to transfer NFTs
        // 2. Call stake() on staking contract
        // For now, we'll use setApprovalForAll and send transaction to treasury
        
        console.log('[NFT] Approving NFTs for staking...');
        const approveTx = await nftContract.setApprovalForAll(NFT_STAKING_CONTRACT, true, {
          gasLimit: 100000
        });
        
        showNotification(`üîÑ Approval transaction sent! Waiting for confirmation...`, false);
        await approveTx.wait();
        
        console.log('[NFT] Approval confirmed, sending stake transaction...');
        
        // Send transaction to treasury to record stake on-chain
        // Note: Cannot include data field when sending to EOA (treasury wallet)
        const stakeTx = await signer.sendTransaction({
          to: TREASURY_WALLET_ADDRESS,
          value: ethers.utils.parseEther(GAS_FEE_ETH.toString()),
          gasLimit: GAS_LIMITS.NFT_STAKE_TX
        });
        
        showNotification(`üîÑ Stake transaction sent! Waiting for confirmation...`, false);
        await stakeTx.wait();
        
        console.log('[NFT] Stake transaction confirmed:', stakeTx.hash);
        
        // Update local state (in production, this would come from staking contract)
        selectedArray.forEach(nftId => {
          const nft = [...userNFTs, ...mintedNFTs].find(n => (n.id || n) === nftId);
          if (nft) {
            stakedNFTsData.push({
              nftId: nft.id || nftId,
              rarity: nft.rarity || 'Common',
              apy: nft.apy || nftAPYs[nft.rarity || 'Common'],
              stakedTime: Date.now(),
              rewards: 0
            });
            
            // Remove from available
            const userIndex = userNFTs.findIndex(n => n.id === nftId);
            if (userIndex !== -1) userNFTs.splice(userIndex, 1);
            const mintedIndex = mintedNFTs.findIndex(n => n === nftId);
            if (mintedIndex !== -1) mintedNFTs.splice(mintedIndex, 1);
          }
        });
        
        selectedNFTs.clear();
        showSection('nft');
        
        recordTransaction(stakeTx.hash, 'NFT Stake', `Staked ${nftCount} NFT(s)`, {to: NFT_CONTRACT_ADDRESS});
        showNotification(
          `‚úÖ Successfully staked ${nftCount} NFT(s)!<br>Approval TX: <a href="${getActiveNetwork().explorer}/tx/${approveTx.hash}" target="_blank" style="color:#60a5fa;">${approveTx.hash.slice(0, 10)}...</a><br>Stake TX: <a href="${getActiveNetwork().explorer}/tx/${stakeTx.hash}" target="_blank" style="color:#60a5fa;">${stakeTx.hash.slice(0, 10)}...</a>`,
          false
        );
        console.log(`[NFT] Staked ${nftCount} NFTs. Approval: ${approveTx.hash}, Stake: ${stakeTx.hash}`);
        
      } catch (error) {
        console.error('[NFT] Staking error:', error);
        showNotification(`‚ùå Staking failed: ${error.message}`, true);
      }
    }
    window.stakeSelectedNFTs = stakeSelectedNFTs;
    
    async function unstakeSelectedNFTs() {
      if (selectedNFTs.size === 0) return showNotification("No staked NFTs selected!", true);
      
      // Proper wallet validation
      if (!userAddress || !provider) {
        showNotification("‚ö†Ô∏è Please connect your wallet to unstake NFTs!", true);
        connectWalletFromApp();
        return;
      }
      
      // Check and process gas fee
      if (!await processGasFee('NFT unstaking')) {
        return;
      }
      
      const selectedArray = Array.from(selectedNFTs);
      selectedArray.forEach(nftId => {
        const stakedIndex = stakedNFTsData.findIndex(n => n.nftId === nftId);
        if (stakedIndex !== -1) {
          const stakedNFT = stakedNFTsData[stakedIndex];
          
          // Return to available NFTs
          userNFTs.push({
            id: stakedNFT.nftId,
            rarity: stakedNFT.rarity,
            apy: stakedNFT.apy
          });
          
          stakedNFTsData.splice(stakedIndex, 1);
        }
      });
      
      const count = selectedNFTs.size;
      selectedNFTs.clear();
      showSection('nft');
      showNotification(`‚úÖ Successfully unstaked ${count} NFT(s) | Gas: ${GAS_FEE_ETH} ${getNetworkCurrency()}`);
      console.log(`[NFT] Unstaked ${count} NFTs with gas fee`);
    }
    window.unstakeSelectedNFTs = unstakeSelectedNFTs;
    
    window.claimAllRewards = async function() {
      // Calculate all claimable rewards
      const nftRewards = calculateTotalRewards();
      const volumeRewards = volumeRewardsClaimable || 0;
      const learningPointsRewards = mogalandPoints * LEARNING_POINTS_TO_USDC_RATE;
      const totalRewards = nftRewards + volumeRewards + learningPointsRewards;
      
      if (totalRewards <= 0) {
        return showNotification("No rewards available to claim!", true);
      }
      
      // Proper wallet validation
      if (!userAddress || !provider) {
        showNotification("‚ö†Ô∏è Please connect your wallet to claim rewards!", true);
        connectWalletFromApp();
        return;
      }
      
      // Show detailed breakdown before claiming
      const breakdown = [];
      if (nftRewards > 0) breakdown.push(`NFT Staking: ${nftRewards.toFixed(4)} USDC`);
      if (volumeRewards > 0) breakdown.push(`Trading Volume: ${volumeRewards.toFixed(4)} USDC`);
      if (learningPointsRewards > 0) breakdown.push(`Learning Points (${mogalandPoints}): ${learningPointsRewards.toFixed(4)} USDC`);
      
      // Check and process gas fee
      if (!await processGasFee('rewards claim')) {
        return;
      }
      
      // Transfer rewards from treasury
      if (transferFromTreasury(totalRewards)) {
        // Reset staking times after claim
        if (nftRewards > 0) {
          stakedNFTsData.forEach(nft => {
            nft.stakedTime = Date.now();
          });
          lastRewardClaim = Date.now();
          
          // Save updated staking data to localStorage
          saveStakedNFTsData();
        }
        
        // Reset volume rewards
        if (volumeRewards > 0) {
          volumeRewardsClaimable = 0;
          saveUserTradingVolume();
        }
        
        // Reset learning points
        if (learningPointsRewards > 0) {
          mogalandPoints = 0;
          
          // Save updated learning points to localStorage
          saveMogalandPoints();
        }
        
        showSection('nft');
        showNotification(
          `‚úÖ Claimed ${totalRewards.toFixed(4)} USDC total!<br>` + 
          breakdown.join('<br>') + 
          `<br>Gas: ${GAS_FEE_ETH} ${getNetworkCurrency()}`,
          false
        );
        console.log(`[Rewards] Total claimed: ${totalRewards.toFixed(4)} USDC (${breakdown.join(', ')})`);
      }
    }
    
    window.redeemPointsForUSDC = async function() {
      if (mogalandPoints < 1000) {
        return showNotification("Need at least 1000 points to redeem!", true);
      }
      
      // Proper wallet validation
      if (!userAddress || !provider) {
        showNotification("‚ö†Ô∏è Please connect your wallet to redeem rewards!", true);
        connectWalletFromApp();
        return;
      }
      
      // Check and process gas fee
      if (!await processGasFee('points redemption')) {
        return;
      }
      
      const usdcAmount = mogalandPoints / 1000; // 1000 points = 1 USDC
      
      // Transfer USDC from treasury
      if (transferFromTreasury(usdcAmount)) {
        mogalandPoints = 0;
        
        // Save updated points to localStorage
        saveMogalandPoints();
        
        showSection('nft');
        showNotification(`‚úÖ Redeemed points for ${usdcAmount.toFixed(2)} USDC | Gas: ${GAS_FEE_ETH} ${getNetworkCurrency()}`);
        console.log(`[NFT] Redeemed points for ${usdcAmount.toFixed(2)} USDC`);
      }
    }
    
    // Enhanced mintNFT with treasury gas fee
    window.mintNFTFromLearning = async function() {
      if (completedTasks < 100) {
        showNotification("Complete all 100 tasks first!", true);
        return;
      }
      
      if (nftMinted) {
        showNotification("You've already minted your learning NFT!", false);
        return;
      }
      
      if (!provider || !userAddress) {
        showNotification("Please connect your wallet first!", true);
        return;
      }
      
      // Check and process gas fee
      if (!await processGasFee('NFT minting')) {
        return;
      }
      
      try {
        showNotification("Minting your Learning Achievement NFT...", false);
        
        // For demo: Add to minted NFTs
        const newNFTId = Date.now() % 10000;
        const rarity = 'Epic'; // Learning achievement NFTs are Epic
        mintedNFTs.push({
          id: newNFTId,
          rarity: rarity,
          apy: nftAPYs[rarity],
          source: 'learning'
        });
        
        // Simulate minting time
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        nftMinted = true;
        
        // Minting revenue goes to treasury
        const mintPrice = 0.05; // 0.05 ETH mint price
        treasuryUSDCBalance += mintPrice * 2500; // Convert ETH to USDC (assuming 2500 USD/ETH)
        console.log(`[Treasury] Received ${mintPrice * 2500} USDC from NFT mint`);
        
        showNotification("üéâ Learning Achievement NFT minted! View in NFT Staking section", false);
        showSection('learning');
        
        // In production: Call actual smart contract
        // const nftContract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, signer);
        // const tx = await nftContract.mint(userAddress);
        // await tx.wait();
        
      } catch (error) {
        console.error('Minting error:', error);
        showNotification("Failed to mint NFT: " + error.message, true);
      }
    }

    // OpenSea Marketplace Integration Functions
    window.openListNFTModal = function() {
      if (!userAddress) {
        showNotification("Please connect wallet to list NFTs", true);
        return;
      }
      
      const totalNFTs = userNFTs.length + mintedNFTs.length;
      if (totalNFTs === 0) {
        showNotification("You don't have any NFTs to list", true);
        return;
      }
      
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:10000;';
      
      modal.innerHTML = `
        <div style="background:var(--card-bg); border:1px solid var(--border); border-radius:20px; padding:32px; max-width:500px; width:90%;">
          <h3 style="color:#60a5fa; margin-bottom:20px; text-align:center;">üè∑Ô∏è List NFT on OpenSea</h3>
          
          <div style="background:rgba(59,130,246,0.1); border:1px solid rgba(59,130,246,0.3); border-radius:12px; padding:20px; margin-bottom:24px;">
            <p style="color:#94a3b8; font-size:0.95em; line-height:1.6; margin-bottom:12px;">
              To list your NFT on OpenSea Sepolia testnet:
            </p>
            <ol style="color:#94a3b8; font-size:0.9em; line-height:1.8; padding-left:24px;">
              <li>Visit OpenSea Testnet</li>
              <li>Connect your wallet (${userAddress.slice(0,6)}...${userAddress.slice(-4)})</li>
              <li>Navigate to your profile</li>
              <li>Select the NFT you want to list</li>
              <li>Click "Sell" and set your price</li>
              <li>Confirm the listing transaction</li>
            </ol>
          </div>
          
          <div style="background:rgba(16,185,129,0.1); border:1px solid rgba(16,185,129,0.3); border-radius:12px; padding:16px; margin-bottom:24px;">
            <p style="color:#10b981; font-size:0.9em; margin-bottom:8px;">
              üí∞ <strong>Treasury Integration</strong>
            </p>
            <p style="color:#94a3b8; font-size:0.85em; line-height:1.5;">
              All sales proceeds are automatically sent to the treasury wallet:
              <br/>
              <span style="color:#60a5fa; font-family:monospace; font-size:0.8em;">${TREASURY_WALLET_ADDRESS}</span>
            </p>
            <p style="color:#94a3b8; font-size:0.85em; margin-top:8px;">
              5% royalty on secondary sales also goes to treasury.
            </p>
          </div>
          
          <div style="display:flex; gap:12px;">
            <button onclick="window.open('https://testnets.opensea.io/${userAddress}', '_blank'); this.closest('div[style*=fixed]').remove();" 
                    style="flex:1; background:linear-gradient(90deg,#2563eb,#1e40af); color:white; padding:14px; border:none; border-radius:10px; font-weight:600; cursor:pointer; font-size:1em;">
              üåä Open OpenSea
            </button>
            <button onclick="this.closest('div[style*=fixed]').remove();" 
                    style="flex:1; background:rgba(239,68,68,0.2); color:#ef4444; padding:14px; border:1px solid #ef4444; border-radius:10px; font-weight:600; cursor:pointer; font-size:1em;">
              Cancel
            </button>
          </div>
          
          <p style="text-align:center; color:#64748b; font-size:0.85em; margin-top:16px;">
            <a href="https://testnets.opensea.io/assets/sepolia/${NFT_CONTRACT_ADDRESS}" target="_blank" style="color:#60a5fa;">
              View Collection on OpenSea ‚Üí
            </a>
          </p>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Log to console for tracking
      console.log(`[OpenSea] Opening listing modal for user: ${userAddress}`);
      console.log(`[OpenSea] User has ${totalNFTs} NFTs available to list`);
      console.log(`[OpenSea] Collection contract: ${NFT_CONTRACT_ADDRESS}`);
      console.log(`[OpenSea] Treasury wallet: ${TREASURY_WALLET_ADDRESS}`);
    }

    window.viewOpenSeaCollection = function() {
      const url = `https://testnets.opensea.io/assets/sepolia/${NFT_CONTRACT_ADDRESS}`;
      window.open(url, '_blank');
      showNotification('Opening OpenSea collection...', false);
    }

    window.viewTreasuryMarketplace = function() {
      const url = `https://testnets.opensea.io/${TREASURY_WALLET_ADDRESS}`;
      window.open(url, '_blank');
      showNotification('Opening treasury marketplace...', false);
    }

    // Swap functions
    async function updateTokenBalances() {
      if (!provider || !userAddress) {
        plumeBalance = "0.00";
        mogaBalance = 0;
      } else {
        try {
          const balanceWei = await provider.getBalance(userAddress);
          plumeBalance = ethers.utils.formatEther(balanceWei);
          mogaBalance = mogalandPoints;
        } catch (err) {
          showNotification("Failed to load balance", true);
          plumeBalance = "Error";
          mogaBalance = 0;
        }
      }

      document.querySelectorAll('#plumeBalance').forEach(el => el.textContent = parseFloat(plumeBalance).toFixed(4));
    }

    async function updateSelectedTokenBalance() {
      const fromToken = document.getElementById('fromTokenSelect')?.value || 'ETH';
      const balanceEl = document.getElementById('plumeBalance');
      
      if (!balanceEl) return;
      
      if (!provider || !userAddress) {
        balanceEl.textContent = '0.0000';
        return;
      }
      
      try {
        let balance = 0;
        
        if (fromToken === 'ETH') {
          const balanceWei = await provider.getBalance(userAddress);
          balance = parseFloat(ethers.utils.formatEther(balanceWei));
        } else {
          // Get token contract address
          const tokenAddresses = {
            'USDC': USDC_SEPOLIA,
            'USDT': USDT_SEPOLIA,
            'LINK': LINK_SEPOLIA,
            'WBTC': WBTC_SEPOLIA,
            'AAVE': AAVE_SEPOLIA,
            'EURO': EURO_SEPOLIA
          };
          
          // Get token decimals
          const tokenDecimals = {
            'USDC': 6,
            'USDT': 6,
            'LINK': 18,
            'WBTC': 8,
            'AAVE': 18,
            'EURO': 6
          };
          
          const tokenAddress = tokenAddresses[fromToken];
          const decimals = tokenDecimals[fromToken] || 18;
          
          if (tokenAddress) {
            const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
            const balanceRaw = await tokenContract.balanceOf(userAddress);
            balance = parseFloat(ethers.utils.formatUnits(balanceRaw, decimals));
          }
        }
        
        balanceEl.textContent = balance.toFixed(4);
      } catch (err) {
        console.error('[Swap] Error fetching token balance:', err);
        balanceEl.textContent = 'Error';
      }
    }
    window.updateSelectedTokenBalance = updateSelectedTokenBalance;

    function updateSwapEstimate() {
      const fromAmt = parseFloat(document.getElementById('fromInput')?.value) || 0;
      const fromToken = document.getElementById('fromTokenSelect')?.value || 'ETH';
      const toToken = document.getElementById('toTokenSelect')?.value || 'USDC';

      // Use live ETH_TO_USDC_RATE from Uniswap for ETH/USDC swaps
      const exchangeRates = {
        'ETH': ETH_TO_USDC_RATE,  // Live rate from Uniswap
        'USDC': 1,
        'USDT': 1,
        'LINK': 15,
        'WBTC': 45000,
        'AAVE': 100,
        'EURO': 1.08
      };

      const fromValue = fromAmt * (exchangeRates[fromToken] || 1);
      const toAmount = fromValue / (exchangeRates[toToken] || 1);
      const rate = (exchangeRates[fromToken] || 1) / (exchangeRates[toToken] || 1);

      // Use 4 decimals for consistency with other displays
      const estOut = toAmount.toFixed(4);
      const impact = fromAmt > 0 ? `~0.12% impact (${currentSlippageTolerance.toFixed(1)}% tolerance)` : "";

      const estEl = document.getElementById('swapEstimate');
      if (estEl) {
        estEl.innerHTML = `Estimasi: <strong>${estOut} ${toToken}</strong> (1 ${fromToken} ‚âà ${rate.toFixed(4)} ${toToken})<br><small style="color:#94a3b8;">${impact}</small>`;
      }
    }
    window.updateSwapEstimate = updateSwapEstimate;

    window.setSlippage = function(value) {
      const val = parseFloat(value);
      if (isNaN(val) || val < 0 || val > 10) {
        showNotification("Slippage harus 0‚Äì10%", true);
        return;
      }

      currentSlippageTolerance = val;
      document.getElementById('currentSlippage').textContent = val.toFixed(1) + '%';

      document.querySelectorAll('.slippage-chip').forEach(btn => {
        btn.classList.remove('active');
        if (parseFloat(btn.dataset.value) === val) btn.classList.add('active');
      });

      document.getElementById('customSlippage').value = val;

      document.getElementById('slippageWarning').style.display = (val > 3) ? 'block' : 'none';

      updateSwapEstimate();
    }

    window.confirmSwap = async function() {
      // Check wallet connection FIRST
      if (!userAddress || !provider) {
        showNotification("‚ö†Ô∏è Please connect wallet first!", true);
        connectWalletFromApp();
        return;
      }
      
      const amt = parseFloat(document.getElementById('fromInput')?.value) || 0;
      if (amt <= 0) {
        showNotification("Enter amount > 0", true);
        return;
      }

      const fromToken = document.getElementById('fromTokenSelect')?.value || 'ETH';
      const toToken = document.getElementById('toTokenSelect')?.value || 'USDC';
      
      if (fromToken === toToken) {
        showNotification("‚ùå Cannot swap same token", true);
        return;
      }
      
      try {
        // Execute real Uniswap swap
        showNotification(`üîÑ Preparing swap: ${amt} ${fromToken} ‚Üí ${toToken}...`, false);
        
        const result = await executeRealSwap(fromToken, toToken, amt, currentSlippageTolerance);
        
        if (result.success) {
          recordTransaction(result.txHash, 'Swap', `${amt.toFixed(6)} ${fromToken} ‚Üí ${parseFloat(result.amountOut).toFixed(6)} ${toToken}`, {amount: amt, token: fromToken});
          showNotification(
            `‚úÖ Swap successful!<br>${amt.toFixed(6)} ${fromToken} ‚Üí ${parseFloat(result.amountOut).toFixed(6)} ${toToken}<br>TX: <a href="${getActiveNetwork().explorer}/tx/${result.txHash}" target="_blank" style="color:#60a5fa;">${result.txHash.slice(0, 10)}...</a>`,
            false
          );
          
          console.log(`[Swap] Real transaction completed: ${amt} ${fromToken} ‚Üí ${result.amountOut} ${toToken}`);
          console.log(`[Swap] Transaction hash: ${result.txHash}`);
          
          // Refresh balances
          setTimeout(() => {
            fetchAndDisplayBalances();
          }, 2000);
        }
      } catch (error) {
        console.error('[Swap] Error:', error);
        showNotification(`‚ùå Swap failed: ${error.message}`, true);
      }
    }

    window.toggleSwapDirection = function() {
      const fromSelect = document.getElementById('fromTokenSelect');
      const toSelect = document.getElementById('toTokenSelect');
      if (fromSelect && toSelect) {
        const temp = fromSelect.value;
        fromSelect.value = toSelect.value;
        toSelect.value = temp;
        updateSwapEstimate();
        showNotification(`Direction swap diubah menjadi ${fromSelect.value} ‚Üí ${toSelect.value}`, false);
      }
    }

    // Quiz & Stake functions
    function loadQuestion() {
      // Show optional staking prompt if not staked yet, but don't block learning
      if (stakedUSDC <= 0 && currentQuestionIndex === 0) {
        showNotification("üí° Tip: Stake USDC to earn additional rewards while learning!", false);
      }
      
      if (currentQuestionIndex >= questions.length) {
        document.getElementById('qTitle').textContent = "üéâ Congratulations! All 100 questions completed!";
        document.getElementById('optionsContainer').innerHTML = '';
        const btnGroup = document.querySelector('.btn-group');
        if (btnGroup) {
          btnGroup.innerHTML = '<button class="btn-primary" onclick="restartQuiz()">Start Over</button>';
        }
        return;
      }

      const q = questions[currentQuestionIndex];
      document.getElementById('qNumber').textContent = `Question ${currentQuestionIndex + 1}/100`;
      document.getElementById('qTitle').textContent = q.question;

      const container = document.getElementById('optionsContainer');
      container.innerHTML = '';
      q.options.forEach((opt, index) => {
        container.innerHTML += `
          <label style="display:block; margin:12px 0; font-size:1.1em; cursor:pointer;">
            <input type="radio" name="q" value="${index}"> ${opt}
          </label>
        `;
      });
    }

    window.submitAnswer = async function() {
      const selected = document.querySelector('input[name="q"]:checked');
      
      if (!selected) {
        showNotification("Please select an answer first!", true);
        return;
      }

      // Check wallet connection for gas fee
      if (!userAddress || !provider) {
        showNotification("‚ö†Ô∏è Please connect wallet first to submit answers!", true);
        connectWalletFromApp();
        return;
      }

      // Request wallet confirmation for gas fee
      const confirmed = await requestWalletConfirmation('Submit Learning Answer', {
        amount: `Gas Fee: ${GAS_FEE_USDC} USDC`,
        gasLimit: GAS_LIMITS.LEARNING
      });
      
      if (!confirmed) {
        showNotification('‚ùå Answer submission cancelled', true);
        return;
      }

      // Check and process gas fee before submitting answer
      if (!await processGasFee('learning answer')) {
        return;
      }

      const chosenIndex = parseInt(selected.value);
      const correctIndex = questions[currentQuestionIndex].correct;
      const questionText = questions[currentQuestionIndex].question;
      const timestamp = new Date().toLocaleString();

      if (chosenIndex === correctIndex) {
        mogalandPoints += 100;
        completedTasks++;
        
        // Save updated points to localStorage
        saveMogalandPoints();
        
        // Add to answer history
        answerHistory.push({
          question: questionText,
          correct: true,
          pointChange: +100,
          timestamp: timestamp,
          totalPoints: mogalandPoints
        });
        
        // Show enhanced notification with point change
        showNotification(`‚úÖ Correct! +100 Points | Total: ${mogalandPoints} points`, false);
        
        // Update displays immediately
        updatePointDisplay();
        updateProgressDisplay();
        updateAnswerHistoryDisplay();
        
        // Move to next question
        currentQuestionIndex++;
        loadQuestion();
        
        // Check if all 100 tasks completed
        if (completedTasks === 100 && !nftMinted) {
          showNotification("üéâ Amazing! You've completed all 100 tasks! You can now mint your NFT!", false);
          setTimeout(() => showSection('learning'), 500);
        }
      } else {
        const pointLoss = 100;
        mogalandPoints = Math.max(0, mogalandPoints - pointLoss);
        
        // Save updated points to localStorage
        saveMogalandPoints();
        
        // Add to answer history
        answerHistory.push({
          question: questionText,
          correct: false,
          pointChange: -pointLoss,
          timestamp: timestamp,
          totalPoints: mogalandPoints
        });
        
        // Show enhanced notification with point change
        showNotification(`‚ùå Wrong! -100 Points | Total: ${mogalandPoints} points. Try again!`, true);
        
        // Update displays immediately
        updatePointDisplay();
        updateAnswerHistoryDisplay();
      }
    }

    window.restartQuiz = function() {
      currentQuestionIndex = 0;
      loadQuestion();
      updateProgressDisplay();
    }

    function updatePointDisplay() {
      const el = document.getElementById('pointDisplay');
      if (el) {
        el.textContent = `${mogalandPoints} POINTS`;
        const progressPercent = Math.min((mogalandPoints / 10000) * 100, 100);
        const progEl = document.getElementById('pointProgress');
        if (progEl) progEl.style.width = `${progressPercent}%`;
      }
    }

    function updateProgressDisplay() {
      const title = document.getElementById('progressTitle');
      if (title) {
        title.textContent = `TASKS: ${completedTasks}/100`;
      }

      const fill = document.getElementById('progressFill');
      const label = document.getElementById('progressLabel');
      if (fill && label) {
        const percent = (completedTasks / 100) * 100;
        fill.style.width = percent + '%';
        label.textContent = `${completedTasks}/100 Tasks Completed`;
      }
      
      const nftStatus = document.getElementById('nftStatus');
      if (nftStatus) {
        nftStatus.textContent = nftMinted ? '‚úÖ NFT Minted!' : (completedTasks === 100 ? 'üéÅ Ready to Mint!' : 'üîí Complete 100 Tasks');
      }
    }
    
    // Function to update answer history display
    function updateAnswerHistoryDisplay() {
      const historyItems = document.getElementById('historyItems');
      if (historyItems) {
        // Show last 5 answers
        const recentAnswers = answerHistory.slice(-5).reverse();
        historyItems.innerHTML = recentAnswers.map(answer => {
          const icon = answer.correct ? '‚úÖ' : '‚ùå';
          const color = answer.correct ? '#10b981' : '#ef4444';
          const pointChange = answer.pointChange > 0 ? `+${answer.pointChange}` : answer.pointChange;
          // Comprehensive XSS sanitization
          const safeQuestion = answer.question
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .substring(0, 30);
          return `<div style="padding:6px 0; font-size:0.85em; border-bottom:1px solid rgba(255,255,255,0.1);">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="color:${color};">${icon} ${safeQuestion}...</span>
              <span style="color:${color}; font-weight:bold;">${pointChange}</span>
            </div>
            <div style="font-size:0.75em; color:#94a3b8; margin-top:2px;">Total: ${answer.totalPoints} pts | ${answer.timestamp}</div>
          </div>`;
        }).join('');
        
        if (recentAnswers.length === 0) {
          historyItems.innerHTML = '<div style="padding:8px; text-align:center; color:#94a3b8; font-size:0.85em;">No answers yet. Start the quiz!</div>';
        }
      }
    }

    // USDC Staking Functions
    async function updateUSDCBalance() {
      if (!provider || !userAddress) {
        document.getElementById('usdcBalanceDisplay').textContent = '0.00';
        return;
      }

      try {
        const usdcContract = new ethers.Contract(USDC_SEPOLIA_ADDRESS, USDC_ABI, provider);
        const balance = await usdcContract.balanceOf(userAddress);
        const decimals = await usdcContract.decimals();
        usdcBalance = ethers.utils.formatUnits(balance, decimals);
        document.getElementById('usdcBalanceDisplay').textContent = parseFloat(usdcBalance).toFixed(2);
      } catch (error) {
        console.error('Error fetching USDC balance:', error);
        document.getElementById('usdcBalanceDisplay').textContent = '0.00';
      }
    }

    window.stakeUSDC = async function() {
      const amount = parseFloat(document.getElementById('stakeAmount').value);
      if (isNaN(amount) || amount <= 0) {
        showNotification("Please enter a valid amount!", true);
        return;
      }

      if (!provider || !userAddress) {
        showNotification("Please connect your wallet first!", true);
        return;
      }

      try {
        // Request wallet confirmation with gas fee
        const confirmed = await requestWalletConfirmation('Stake USDC', {
          amount: `${amount} USDC`,
          from: 'Learning Section',
          gasLimit: GAS_LIMITS.STAKE_BASE
        });
        
        if (!confirmed) {
          showNotification('‚ùå Staking cancelled by user', true);
          return;
        }

        // Process gas fee
        if (!await processGasFee('stake')) {
          return;
        }

        showNotification("Processing USDC stake transaction...", false);
        
        const signer = provider.getSigner();
        const usdcContract = new ethers.Contract(USDC_SEPOLIA_ADDRESS, USDC_ABI, signer);
        const decimals = await usdcContract.decimals();
        const amountInWei = ethers.utils.parseUnits(amount.toString(), decimals);
        
        // For demo: we'll just track it locally. In production, you'd interact with a staking contract
        stakedUSDC += amount;
        updateStakedDisplay();
        document.getElementById('stakeAmount').value = '';
        showNotification(`‚úÖ Successfully staked ${amount} USDC!`, false);
        updateUSDCBalance();
      } catch (error) {
        console.error('Stake error:', error);
        showNotification("Failed to stake USDC: " + error.message, true);
      }
    }

    window.unstakeUSDC = async function() {
      const amount = parseFloat(document.getElementById('unstakeAmount').value);
      if (isNaN(amount) || amount <= 0) {
        showNotification("Please enter a valid amount!", true);
        return;
      }

      if (amount > stakedUSDC) {
        showNotification("Insufficient staked balance!", true);
        return;
      }

      if (!provider || !userAddress) {
        showNotification("Please connect your wallet first!", true);
        return;
      }

      try {
        // Request wallet confirmation with gas fee
        const confirmed = await requestWalletConfirmation('Unstake USDC', {
          amount: `${amount} USDC`,
          from: 'Learning Section',
          gasLimit: GAS_LIMITS.STAKE_BASE
        });
        
        if (!confirmed) {
          showNotification('‚ùå Unstaking cancelled by user', true);
          return;
        }

        // Process gas fee
        if (!await processGasFee('unstake')) {
          return;
        }

        showNotification("Processing USDC unstake transaction...", false);
        
        // For demo: we'll just track it locally
        stakedUSDC -= amount;
        updateStakedDisplay();
        document.getElementById('unstakeAmount').value = '';
        showNotification(`‚úÖ Successfully unstaked ${amount} USDC!`, false);
        updateUSDCBalance();
      } catch (error) {
        console.error('Unstake error:', error);
        showNotification("Failed to unstake USDC: " + error.message, true);
      }
    }

    function updateStakedDisplay() {
      const el = document.getElementById('stakedDisplay');
      if (el) el.textContent = `Staked: ${stakedUSDC.toFixed(2)} USDC`;
    }

    window.convertPointsToUSDC = async function() {
      if (mogalandPoints < 1000) {
        showNotification("You need at least 1000 points to convert!", true);
        return;
      }

      if (!provider || !userAddress) {
        showNotification("‚ö†Ô∏è Wallet not connected. Please connect your wallet to convert points.", true);
        connectWalletFromApp();
        return;
      }

      try {
        const usdcAmount = Math.floor(mogalandPoints / 1000);
        const pointsToConvert = usdcAmount * 1000;
        
        // Show confirmation
        const confirmed = await requestWalletConfirmation('Convert Points to USDC', {
          amount: `${pointsToConvert} points ‚Üí ${usdcAmount} USDC`,
          from: 'Learning Points',
          to: 'Treasury USDC',
          gasLimit: GAS_LIMITS.SWAP
        });
        
        if (!confirmed) {
          showNotification('‚ùå Conversion cancelled', true);
          return;
        }
        
        showNotification(`Converting ${pointsToConvert} points to ${usdcAmount} USDC from treasury...`, false);
        
        // Deduct points immediately
        mogalandPoints -= pointsToConvert;
        
        // Save updated points to localStorage
        saveMogalandPoints();
        
        updatePointDisplay();
        
        // Check treasury balance and transfer USDC
        if (treasuryUSDCBalance >= usdcAmount) {
          treasuryUSDCBalance -= usdcAmount;
          showNotification(`‚úÖ Successfully converted ${pointsToConvert} points to ${usdcAmount} USDC from treasury!`, false);
          
          // Update user's USDC balance display
          if (typeof fetchRealBalances === 'function') {
            setTimeout(() => fetchRealBalances(), 1000);
          }
        } else {
          // Treasury has insufficient funds
          showNotification(`‚ö†Ô∏è Treasury balance insufficient. Conversion recorded but USDC transfer pending. Treasury: ${treasuryUSDCBalance.toFixed(2)} USDC, Needed: ${usdcAmount} USDC`, true);
        }
        
        // Log the conversion to answer history for tracking
        const timestamp = new Date().toLocaleString();
        answerHistory.push({
          question: 'Points Conversion',
          correct: true,
          pointChange: -pointsToConvert,
          timestamp: timestamp,
          totalPoints: mogalandPoints,
          note: `Converted to ${usdcAmount} USDC from treasury`
        });
        
        updateAnswerHistoryDisplay();
        showNotification(`‚úÖ Successfully converted ${pointsToConvert} points to ${usdcAmount} USDC from treasury!`, false);
        
        // Note: In production, you would:
        // 1. Call a smart contract function to burn points
        // 2. Contract would transfer USDC from treasury to user
        // const tx = await contract.convertPointsToUSDC(usdcAmount);
        // await tx.wait();
        
      } catch (error) {
        console.error('Conversion error:', error);
        showNotification("Failed to convert points: " + error.message, true);
      }
    }

    async function mintNFT() {
      if (completedTasks < 100) {
        showNotification("Complete all 100 tasks first!", true);
        return;
      }

      if (nftMinted) {
        showNotification("You've already minted your NFT!", false);
        return;
      }

      if (!provider || !userAddress) {
        showNotification("Please connect your wallet first!", true);
        return;
      }

      try {
        showNotification("üé® Minting your achievement NFT...", false);
        
        const signer = provider.getSigner();
        const nftContract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, signer);
        
        // Check if contract exists
        const code = await provider.getCode(NFT_CONTRACT_ADDRESS);
        if (code === '0x') {
          // Contract not deployed - achievement recorded locally but not on-chain
          // User can retry minting once contract is deployed
          showNotification("‚ö†Ô∏è NFT contract not deployed yet. Your achievement is recorded! Try again later when contract is deployed.", false);
          // DO NOT set nftMinted = true here, allow retry when contract is deployed
          showSection('learning');
          return;
        }
        
        console.log('[NFT] Minting achievement NFT for completing 100 tasks...');
        
        // Call mint function on NFT contract
        const tx = await nftContract.mint(userAddress, {
          gasLimit: 200000
        });
        
        showNotification("üîÑ Mint transaction sent! Waiting for confirmation...", false);
        console.log('[NFT] Transaction hash:', tx.hash);
        
        const receipt = await tx.wait();
        console.log('[NFT] NFT minted successfully!', receipt);
        
        nftMinted = true;
        
        recordTransaction(tx.hash, 'NFT Mint', 'Minted Learning Achievement NFT', {to: NFT_CONTRACT_ADDRESS});
        showNotification(
          `üéâ Congratulations! Your Learning Achievement NFT has been minted!<br>TX: <a href="${getActiveNetwork().explorer}/tx/${tx.hash}" target="_blank" style="color:#60a5fa;">${tx.hash.slice(0, 10)}...</a>`,
          false
        );
        
        showSection('learning');
        
        // Refresh NFTs
        setTimeout(() => {
          loadUserNFTs();
        }, 2000);
        
      } catch (error) {
        console.error('[NFT] Minting error:', error);
        showNotification("‚ùå Failed to mint NFT: " + error.message, true);
      }
    }

    function confirmStake() {
      stakeUSDC();
    }

    function unstake() {
      unstakeUSDC();
    }

    window.saveProgress = function() {
      showNotification("Progress saved successfully!", false);
    }

    window.convertPoints = function() {
      convertPointsToUSDC();
    }
    
    // Volume Leaderboard Function
    window.showVolumeLeaderboard = function() {
      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); display:flex; justify-content:center; align-items:center; z-index:10000; padding:20px; overflow-y:auto;';
      
      const content = document.createElement('div');
      content.style.cssText = 'background:linear-gradient(135deg,#1e293b 0%,#0f172a 100%); padding:30px; border-radius:20px; max-width:900px; width:100%; border:2px solid #fbbf24; box-shadow:0 20px 60px rgba(251,191,36,0.3); max-height:90vh; overflow-y:auto;';
      
      // User's volume stats (with safe access in case variables are undefined)
      const userTotalVolume = (userTradingVolume?.total) || 0;
      const userClaimable = volumeRewardsClaimable || 0;
      const cryptoVol = (userTradingVolume?.crypto) || 0;
      const stocksVol = (userTradingVolume?.stocks) || 0;
      const commoditiesVol = (userTradingVolume?.commodities) || 0;
      const forexVol = (userTradingVolume?.forex) || 0;
      const sportsVol = (userTradingVolume?.sports) || 0;
      
      content.innerHTML = `
        <div style="text-align:center; margin-bottom:30px;">
          <h2 style="color:#fbbf24; font-size:2em; margin-bottom:10px;">üèÜ Trading Volume Leaderboard</h2>
          <p style="color:#94a3b8; font-size:1.1em;">Top traders by total trading volume across all markets</p>
        </div>
        
        <!-- Your Stats Card -->
        <div style="background:linear-gradient(135deg,rgba(251,191,36,0.15),rgba(245,158,11,0.1)); border:2px solid #fbbf24; border-radius:16px; padding:24px; margin-bottom:30px;">
          <h3 style="color:#fbbf24; text-align:center; margin-bottom:20px;">üìä Your Trading Statistics</h3>
          <div style="display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:16px; margin-bottom:20px;">
            <div style="text-align:center;">
              <div style="color:#94a3b8; font-size:0.9em; margin-bottom:4px;">Crypto</div>
              <div style="color:#60a5fa; font-size:1.3em; font-weight:bold;">${cryptoVol.toFixed(2)}</div>
            </div>
            <div style="text-align:center;">
              <div style="color:#94a3b8; font-size:0.9em; margin-bottom:4px;">Stocks</div>
              <div style="color:#10b981; font-size:1.3em; font-weight:bold;">${stocksVol.toFixed(2)}</div>
            </div>
            <div style="text-align:center;">
              <div style="color:#94a3b8; font-size:0.9em; margin-bottom:4px;">Commodities</div>
              <div style="color:#f59e0b; font-size:1.3em; font-weight:bold;">${commoditiesVol.toFixed(2)}</div>
            </div>
            <div style="text-align:center;">
              <div style="color:#94a3b8; font-size:0.9em; margin-bottom:4px;">Forex</div>
              <div style="color:#8b5cf6; font-size:1.3em; font-weight:bold;">${forexVol.toFixed(2)}</div>
            </div>
            <div style="text-align:center;">
              <div style="color:#94a3b8; font-size:0.9em; margin-bottom:4px;">Sports</div>
              <div style="color:#ec4899; font-size:1.3em; font-weight:bold;">${sportsVol.toFixed(2)}</div>
            </div>
          </div>
          <div style="border-top:1px solid rgba(251,191,36,0.3); padding-top:16px; display:flex; justify-content:space-between; align-items:center;">
            <div>
              <div style="color:#94a3b8; font-size:0.9em;">Total Volume</div>
              <div style="color:#fbbf24; font-size:1.8em; font-weight:bold;">${userTotalVolume.toFixed(2)} USDC</div>
            </div>
            <div style="text-align:right;">
              <div style="color:#94a3b8; font-size:0.9em;">Claimable Rewards</div>
              <div style="color:#10b981; font-size:1.8em; font-weight:bold;">${userClaimable.toFixed(4)} USDC</div>
            </div>
          </div>
          <div style="margin-top:16px; padding:12px; background:rgba(16,185,129,0.1); border-radius:8px; text-align:center;">
            <p style="color:#10b981; font-size:0.95em; margin:0;">
              üí° <strong>Earn 0.1%</strong> of your trading volume as claimable USDC rewards!<br>
              <span style="font-size:0.85em; opacity:0.9;">Claim your rewards in the NFT Staking section</span>
            </p>
          </div>
        </div>
        
        <!-- Global Leaderboard -->
        <div style="background:rgba(15,23,42,0.6); border:1px solid #334155; border-radius:12px; padding:20px;">
          <h3 style="color:#60a5fa; margin-bottom:16px; text-align:center;">üåê Global Top Traders</h3>
          <div style="color:#94a3b8; text-align:center; padding:40px; font-size:1.1em;">
            <div style="font-size:3em; margin-bottom:16px;">üèóÔ∏è</div>
            <p>Global leaderboard coming soon!</p>
            <p style="font-size:0.9em; margin-top:12px; opacity:0.8;">
              Keep trading to build your volume stats.<br>
              Rankings will be displayed when competitive mode launches.
            </p>
          </div>
        </div>
        
        <button id="closeLeaderboardBtn" 
                style="width:100%; margin-top:24px; padding:16px; background:linear-gradient(90deg,#ef4444,#dc2626); color:white; border:none; border-radius:12px; font-size:1.1em; font-weight:600; cursor:pointer; transition:all 0.3s;">
          Close
        </button>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // Close button click handler
      document.getElementById('closeLeaderboardBtn').addEventListener('click', () => modal.remove());
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });
    }
    
    } // End of startApp()

    // Helper function to calculate total claimable rewards
    function calculateTotalClaimableRewards() {
      const nftRewards = (typeof calculateTotalRewards === 'function') ? calculateTotalRewards() : 0;
      const volumeRewards = (typeof volumeRewardsClaimable !== 'undefined') ? volumeRewardsClaimable : 0;
      const learningRewards = (typeof mogalandPoints !== 'undefined' && typeof LEARNING_POINTS_TO_USDC_RATE !== 'undefined') 
        ? mogalandPoints * LEARNING_POINTS_TO_USDC_RATE 
        : 0;
      
      return {
        nft: nftRewards,
        volume: volumeRewards,
        learning: learningRewards,
        total: nftRewards + volumeRewards + learningRewards
      };
    }

    // Init - Wait for ethers to load, then start app
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }
  </script>
</body>
</html>